"

#include \"gauche_cv_imgproc.h\"
#include <opencv2/imgproc/imgproc_c.h>

#include \"core_type.gen.h\"
#include \"imgproc_type.gen.h\"

typedef void* _pvoid_t;
typedef unsigned char _char_t;
typedef signed char _schar_t;
typedef signed short _short_t;
typedef unsigned short _ushort_t;
typedef int _int_t;
typedef unsigned int _uint_t;
typedef float _float_t;
typedef double _double_t;

"

(include "./cv_type.stub.header")
(include "./imgproc_type.gen.stub.header")

(eval-in-current-module
  (use srfi-13)
  )

(define-cise-stmt (list-to-ary l a c-elem-type elem-assign)
  (let ([c (gensym "img__")]
        [ary (gensym "img__")]
        [index (gensym "img__")]
        [pair (gensym "img__")]
        [c-ary-type (string-append (symbol->string c-elem-type) "*")]
        [ary-sizeof-type (if (string-suffix? "*" (symbol->string c-elem-type))
                           '_pvoid_t c-elem-type)])
    `(let* ([,c :: int (Scm_Length ,l)]
            [,ary :: ,c-ary-type (SCM_MALLOC (* (sizeof ,ary-sizeof-type) ,c))]
            [,pair :: ScmObj ,l])
        (dotimes [,index ,c]
          (,elem-assign (aref ,ary ,index) (SCM_CAR ,pair))
          (set! ,pair (SCM_CDR ,pair)))
        (set! ,a ,ary))))

(define-cise-stmt (vector-to-ary v a c-elem-type elem-assign)
  (let ([c (gensym "img__")]
        [vec (gensym "img__")]
        [ary (gensym "img__")]
        [index (gensym "img__")]
        [c-ary-type (string-append (symbol->string c-elem-type) "*")]
        [ary-sizeof-type (if (string-suffix? "*" (symbol->string c-elem-type))
                           '_pvoid_t c-elem-type)])
    `(let* ([,c :: int (SCM_VECTOR_SIZE ,v)]
            [,ary :: ,c-ary-type (SCM_MALLOC (* (sizeof ,ary-sizeof-type) ,c))])
       (dotimes [,index ,c]
         (,elem-assign (aref ,ary ,index) (SCM_VECTOR_ELEMENT ,v ,index)))
       (set! ,a ,ary))))


(define-cise-stmt (int-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<int>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (set! ,var (,(string->symbol (~ type 'unboxer)) ,obj))
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

(define-cise-stmt (float-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<float>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (set! ,var (,(string->symbol (~ type 'unboxer)) ,obj))
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

(define-cise-stmt (list.float-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<list>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (list-to-ary ,obj ,var _float_t float-elem-assign)
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

(define-cise-stmt (vector.float-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<vector>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (vector-to-ary ,obj ,var _float_t float-elem-assign)
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

(define-cise-stmt (uvector.int-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<s32vector>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (set! ,var (SCM_S32VECTOR_ELEMENTS (,(string->symbol (~ type 'unboxer)) ,obj)))
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

(define-cise-stmt (uvector.float-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<f32vector>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (set! ,var (SCM_F32VECTOR_ELEMENTS (,(string->symbol (~ type 'unboxer)) ,obj)))
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))


(define-cise-expr (null? obj)
  `(SCM_NULLP ,obj))

(define-cise-expr (zero? num)
  `(== ,num 0))


(define-cise-expr (to-c-type sym-type)
  (let ([type (cgen-type-from-name sym-type)])
    (string->symbol (~ type 'c-type))))

(define-cise-expr (boxing val sym-type)
  (let ([type (cgen-type-from-name sym-type)])
    `(,(string->symbol (~ type 'boxer)) ,val)))

(define-cise-expr (unboxing val sym-type)
  (let ([type (cgen-type-from-name sym-type)])
    `(,(string->symbol (~ type 'unboxer)) ,val)))

(define-cise-expr (is-type? obj sym-type)
  (let ([type (cgen-type-from-name sym-type)])
    `(,(string->symbol (~ type 'c-predicate)) ,obj)))

(define-cise-stmt (assign-obj var obj sym-type)
  (let* ([type (cgen-type-from-name sym-type)])
    `(if (,(string->symbol (~ type'c-predicate)) ,obj)
       (set! ,var (,(string->symbol (~ type'unboxer)) ,obj))
       (Scm_Error ,#`",(~ type'description) required, but got %S" ,obj))))

(define-cise-stmt (nil-or-obj to from sym-type obj)
  (let* ([type (cgen-type-from-name sym-type)])
    `(cond
       [(SCM_NULLP ,to) (set! ,from ,obj)]
       [(,(string->symbol (~ type'c-predicate)) ,to) (set! ,from (,(string->symbol (~ type'unboxer)),to))]
       [else (Scm_Error ,#`",(~ type'description) or () required, but got %S" ,to)])))

(define-cise-stmt (nil-or-cvarr to from)
  `(cond
     [(SCM_NULLP ,to) (set! ,from NULL)]
     [(SCM_CVARR_P ,to) (set! ,from (SCM_CVARR_DATA ,to))]
     [else (Scm_Error "CvArr or () required, but got %S" ,to)]))


;;*************Background statistics accumulation*********
(define-cproc cv-acc (image::<cv-arr> sum::<cv-arr>
                                      :optional (mask-obj ())) ::<void>
              (let* ([mask::CvArr*])
                (nil-or-cvarr mask-obj mask)
                (cvAcc image sum mask)))

(define-cproc cv-square-acc (image::<cv-arr> sqsum::<cv-arr>
                                             :optional (mask-obj ())) ::<void>
              (let* ([mask::CvArr*])
                (nil-or-cvarr mask-obj mask)
                (cvSquareAcc image sqsum mask)))

(define-cproc cv-multiply-acc (image1::<cv-arr> image2::<cv-arr> acc::<cv-arr>
                                                :optional (mask-obj ())) ::<void> 
              (let* ([mask::CvArr*])
                (nil-or-cvarr mask-obj mask)
                (cvMultiplyAcc image1 image2 acc mask)))

(define-cproc cv-running-ave (image::<cv-arr> acc::<cv-arr> alpha::<real>
                                              :optional (mask-obj ())) ::<void>
              (let* ([mask::CvArr*])
                (nil-or-cvarr mask-obj mask)
                (cvRunningAvg image acc alpha mask)))


;;******************
;;Image Processing
;;******************

(define-cproc cv-copy-make-border (src::<cv-arr> dst::<cv-arr> offset::<cv-point> bordertype::<int>
                                                 :optional (value-obj ())) ::<void>
              (let* ([value::CvScalar])
                (nil-or-obj value-obj value <cv-scalar> (cvScalarAll 0))
                (cvCopyMakeBorder src dst offset bordertype value)))


;;-------------
;;Constants
(define-enum CV_BLUR_NO_SCALE)
(define-enum CV_BLUR)
(define-enum CV_GAUSSIAN)
(define-enum CV_MEDIAN)
(define-enum CV_BILATERAL)
(define-cproc cv-smooth (src::<cv-arr> dst::<cv-arr>
                                       :optional (smoothtype::<int> 2) ;;smoothtype 2 is CV_GAUSSIAN
                                       (size1::<int> 3) (size2::<int> 0)
                                       (sigma1::<real> 0) (sigma2::<real> 0)) ::<void>
              (cvSmooth src dst smoothtype size1 size2 sigma1 sigma2))

(define-cproc cv-filter-2d (src::<cv-arr> dst::<cv-arr> kernel::<cv-mat>
                                          :optional (anchor-obj ())) ::<void>
              (let* ([anchor::CvPoint])
                (nil-or-obj anchor-obj anchor <cv-point> (cvPoint -1 -1))
                (cvFilter2D src dst kernel anchor)))

(define-cproc cv-integral (image::<cv-arr> sum::<cv-arr>
                                           :optional (sqsum-obj ()) (tilted-sum-obj ())) ::<void>
              (let* ([sqsum::CvArr*]
                     [tilted-sum::CvArr*])
                (nil-or-cvarr sqsum-obj sqsum)
                (nil-or-cvarr tilted-sum-obj tilted-sum)
                (cvIntegral image sum sqsum tilted-sum)))


(define-cproc cv-pyr-down (src::<cv-arr> dst::<cv-arr>
                                         :optional (filter::<int> 7)) ::<void> ;;filter 7 is CV_GAUSSIAN_5x5
              (cvPyrDown src dst filter))

(define-cproc cv-pyr-up (src::<cv-arr> dst::<cv-arr>
                                       :optional (filter::<int> 7)) ::<void> ;;filter 7 is CV_GAUSSIAN_5x5
              (cvPyrUp src dst filter))


;;not support
;;cvCreatePyramid
;;cvReleaseaPyramid

(define-cproc cv-pyr-segmentation (src::<iplimage> dst::<iplimage> storage::<cv-mem-storage>
                                                   level::<int> threshold1::<real> threshold2::<real>) ::<cv-seq>
              (let* ([comp::CvSeq*])
                (cvPyrSegmentation src dst storage (& comp) level threshold1 threshold2)
                (result comp)))

(define-cproc cv-pyr-mean-shift-filtering (src::<cv-arr> dst::<cv-arr>
                                                         sp::<real> sr::<real>
                                                         :optional (max-level::<int> 1) (termcrit-obj ())) ::<void>
              (let* ([termcrit::CvTermCriteria])
                (nil-or-obj termcrit-obj termcrit <cv-term-criteria> (cvTermCriteria 3 5 1)) ;;3 is CV_TERMCRIT_ITER + CV_TERMCRIT_EPS
                (cvPyrMeanShiftFiltering src dst sp sr max-level termcrit)))

(define-cproc cv-watershed (image::<cv-arr> markers::<cv-arr>) ::<void>
              (cvWatershed image markers))

(define-cproc cv-inpaint (src::<cv-arr> inpaint_mask::<cv-arr> dst::<cv-arr>
                                        inpaint-range::<real> flags::<int>) ::<void>
              (cvInpaint src inpaint_mask dst inpaint-range flags))

(define-cproc cv-sobel (src::<cv-arr> dst::<cv-arr> xorder::<int> yorder::<int>
                                      :optional (aperture-size::<fixnum> 3)) ::<void>
              (cvSobel src dst xorder yorder aperture-size))

(define-cproc cv-laplace (src::<cv-arr> dst::<cv-arr>
                                        :optional (aperture-size::<fixnum> 3)) ::<void>
              (cvLaplace src dst aperture-size))

;;-------------
;;Constants
(define-enum CV_BGR2BGRA)
(define-enum CV_RGB2RGBA)
(define-enum CV_BGRA2BGR)
(define-enum CV_RGBA2RGB)
(define-enum CV_BGR2RGBA)
(define-enum CV_RGB2BGRA)
(define-enum CV_RGBA2BGR)
(define-enum CV_BGRA2RGB)
(define-enum CV_BGR2RGB)
(define-enum CV_RGB2BGR)
(define-enum CV_BGRA2RGBA)
(define-enum CV_RGBA2BGRA)
(define-enum CV_BGR2GRAY)
(define-enum CV_RGB2GRAY)
(define-enum CV_GRAY2BGR)
(define-enum CV_GRAY2RGB)
(define-enum CV_GRAY2BGRA)
(define-enum CV_GRAY2RGBA)
(define-enum CV_BGRA2GRAY)
(define-enum CV_RGBA2GRAY)
(define-enum CV_BGR2BGR565)
(define-enum CV_RGB2BGR565)
(define-enum CV_BGR5652BGR)
(define-enum CV_BGR5652RGB)
(define-enum CV_BGRA2BGR565)
(define-enum CV_RGBA2BGR565)
(define-enum CV_BGR5652BGRA)
(define-enum CV_BGR5652RGBA)
(define-enum CV_GRAY2BGR565)
(define-enum CV_BGR5652GRAY)
(define-enum CV_BGR2BGR555)
(define-enum CV_RGB2BGR555)
(define-enum CV_BGR5552BGR)
(define-enum CV_BGR5552RGB)
(define-enum CV_BGRA2BGR555)
(define-enum CV_RGBA2BGR555)
(define-enum CV_BGR5552BGRA)
(define-enum CV_BGR5552RGBA)
(define-enum CV_GRAY2BGR555)
(define-enum CV_BGR5552GRAY)
(define-enum CV_BGR2XYZ)
(define-enum CV_RGB2XYZ)
(define-enum CV_XYZ2BGR)
(define-enum CV_XYZ2RGB)
(define-enum CV_BGR2YCrCb)
(define-enum CV_RGB2YCrCb)
(define-enum CV_YCrCb2BGR)
(define-enum CV_YCrCb2RGB)
(define-enum CV_BGR2HSV)
(define-enum CV_RGB2HSV)
(define-enum CV_BGR2Lab)
(define-enum CV_RGB2Lab)
(define-enum CV_BayerBG2BGR)
(define-enum CV_BayerGB2BGR)
(define-enum CV_BayerRG2BGR)
(define-enum CV_BayerGR2BGR)
(define-enum CV_BayerBG2RGB)
(define-enum CV_BayerGB2RGB)
(define-enum CV_BayerRG2RGB)
(define-enum CV_BayerGR2RGB)
(define-enum CV_BGR2Luv)
(define-enum CV_RGB2Luv)
(define-enum CV_BGR2HLS)
(define-enum CV_RGB2HLS)
(define-enum CV_HSV2BGR)
(define-enum CV_HSV2RGB)
(define-enum CV_Lab2BGR)
(define-enum CV_Lab2RGB)
(define-enum CV_Luv2BGR)
(define-enum CV_Luv2RGB)
(define-enum CV_HLS2BGR)
(define-enum CV_HLS2RGB)
(define-enum CV_BayerBG2BGR_VNG)
(define-enum CV_BayerGB2BGR_VNG)
(define-enum CV_BayerRG2BGR_VNG)
(define-enum CV_BayerGR2BGR_VNG)
(define-enum CV_BayerBG2RGB_VNG)
(define-enum CV_BayerGB2RGB_VNG)
(define-enum CV_BayerRG2RGB_VNG)
(define-enum CV_BayerGR2RGB_VNG)
(define-enum CV_BGR2HSV_FULL)
(define-enum CV_RGB2HSV_FULL)
(define-enum CV_BGR2HLS_FULL)
(define-enum CV_RGB2HLS_FULL)
(define-enum CV_HSV2BGR_FULL)
(define-enum CV_HSV2RGB_FULL)
(define-enum CV_HLS2BGR_FULL)
(define-enum CV_HLS2RGB_FULL)
(define-enum CV_LBGR2Lab)
(define-enum CV_LRGB2Lab)
(define-enum CV_LBGR2Luv)
(define-enum CV_LRGB2Luv)
(define-enum CV_Lab2LBGR)
(define-enum CV_Lab2LRGB)
(define-enum CV_Luv2LBGR)
(define-enum CV_Luv2LRGB)
(define-enum CV_BGR2YUV)
(define-enum CV_RGB2YUV)
(define-enum CV_YUV2BGR)
(define-enum CV_YUV2RGB)
(define-cproc cv-cvt-color (src::<cv-arr> dst::<cv-arr> code::<int>) ::<void>
              (cvCvtColor src dst code))

;;-------------
;;Constants
(define-enum CV_INTER_NN)
(define-enum CV_INTER_LINEAR)
(define-enum CV_INTER_CUBIC)
(define-enum CV_INTER_AREA)
(define-enum CV_INTER_LANCZOS4)
(define-cproc cv-resize (src::<cv-arr> dst::<cv-arr>
                                       :optional (interpolation::<int> 1)) ::<void> ;;interpolation 1 is CV_INTER_LINEAR
              (cvResize src dst interpolation))

;;-------------
;;Constants
(define-enum CV_WARP_FILL_OUTLIERS)
(define-enum CV_WARP_INVERSE_MAP)
(define-cproc cv-warp-affine (src::<cv-arr> dst::<cv-arr> map-matrix::<cv-mat>
                                            :optional (flags::<int> 9) ;; 9 is CV_INTER_LINEAR + CV_WARP_FILL_OUTLIERS
                                            (fillval-obj ())) ::<void>
              (let* ([fillval::CvScalar])
                (nil-or-obj fillval-obj fillval <cv-scalar> (cvScalarAll 0))
                (cvWarpAffine src dst map-matrix flags fillval)))

(define-cproc cv-get-affine-transform (src-list::<list> dst-list::<list>
                                                        map-matrix::<cv-mat>) ::<void>
              (if (!= (Scm_Length src-list) 3)
                (Scm_Error "src requires length 3, but got %d" (Scm_Length src-list)))
              (if (!= (Scm_Length dst-list) 3)
                (Scm_Error "dst requires length 3, but got %d" (Scm_Length dst-list)))
              (let* ([src::(.array CvPoint2D32f (3))]
                     [dst::(.array CvPoint2D32f (3))]
                     [pair::ScmObj])
                (dotimes [i 3]
                  (begin
                    (assign-obj (aref src i) (SCM_CAR src-list) <cv-point-2d32f>)
                    (assign-obj (aref dst i) (SCM_CAR dst-list) <cv-point-2d32f>)
                    (set! src-list (SCM_CDR src-list))
                    (set! dst-list (SCM_CDR dst-list))))
                (cvGetAffineTransform src dst map-matrix)))

(define-cproc cv-2d-rotation-matrix (center::<cv-point-2d32f> angle::<real> scale::<real> map-matrix::<cv-mat>) ::<void>
              (cv2DRotationMatrix center angle scale map-matrix))

(define-cproc cv-warp-perspective (src::<cv-arr> dst::<cv-arr> map-matrix::<cv-mat>
                                                 :optional (flags::<int> 9) ;;flags 9 is CV_INTER_LINEAR + CV_WARP_FILL_OUTLIERS
                                                 (fillval-obj ())) ::<void>
              (let* ([fillval::CvScalar])
                (nil-or-obj fillval-obj fillval <cv-scalar> (cvScalarAll 0))
                (cvWarpPerspective src dst map-matrix flags fillval)))

(define-cproc cv-get-perspective-transform (src-list::<list> dst-list::<list>
                                                             map-matrix::<cv-mat>) ::<void>
              (if (!= (Scm_Length src-list) 3)
                (Scm_Error "src requires length 3, but got %d" (Scm_Length src-list)))
              (if (!= (Scm_Length dst-list) 3)
                (Scm_Error "dst requires length 3, but got %d" (Scm_Length dst-list)))
              (let* ([src::(.array CvPoint2D32f (3))]
                     [dst::(.array CvPoint2D32f (3))]
                     [pair::ScmObj])
                (dotimes [i 3]
                  (begin
                    (assign-obj (aref src i) (SCM_CAR src-list) <cv-point-2d32f>)
                    (assign-obj (aref dst i) (SCM_CAR dst-list) <cv-point-2d32f>)
                    (set! src-list (SCM_CDR src-list))
                    (set! dst-list (SCM_CDR dst-list))))
                (cvGetPerspectiveTransform src dst map-matrix)))

(define-cproc cv-remap (src::<cv-arr> dst::<cv-arr> mapx::<cv-arr> mapy::<cv-arr>
                                      :optional (flags::<int> 9) ;;flags 9 is CV_INTER_LINEAR + CV_WARP_FILL_OUTLIERS
                                      (fillval-obj ())) ::<void>
              (let* ([fillval::CvScalar])
                (nil-or-obj fillval-obj fillval <cv-scalar> (cvScalarAll 0))
                (cvRemap src dst mapx mapy flags fillval)))

(define-cproc cv-convert-maps (mapx::<cv-arr> mapy::<cv-arr>
                                              mapxy::<cv-arr> mapalpha::<cv-arr>) ::<void>
              (cvConvertMaps mapx mapy mapxy mapalpha))

(define-cproc cv-linear-polar (src::<cv-arr> dst::<cv-arr>
                                             center::<cv-point-2d32f> m::<real>
                                             :optional (flags::<int> 9)) ::<void> ;;flags 9 is CV_INTER_LINEAR + CV_WARP_FILL_OUTLIERS
              (cvLinearPolar src dst center m flags))

(define-cproc cv-undistort2 (src::<cv-arr> dst::<cv-arr>
                                           camera-matrix::<cv-mat> distortion-coeffs::<cv-mat>
                                           :optional (new-camera-matrix-obj ())) ::<void>
              (let* ([new-camera-matrix::CvMat*])
                (nil-or-obj new-camera-matrix-obj new-camera-matrix <cv-mat> NULL)
                (cvUndistort2 src dst camera-matrix distortion-coeffs new-camera-matrix)))

(define-cproc cv-init-undistort-map (camera-matrix::<cv-mat> distortion-coeffs::<cv-mat>
                                                             mapx::<cv-arr> mapy::<cv-arr>) ::<void>
              (cvInitUndistortMap camera-matrix distortion-coeffs mapx mapy))

(define-cproc cv-init-undistort-rectify-map (camera-matrix::<cv-mat> dist-coeffs::<cv-mat>
                                                                     r::<cv-mat> new-camera-matrix::<cv-mat>
                                                                     mapx::<cv-arr> mapy::<cv-arr>) ::<void>
              (cvInitUndistortRectifyMap camera-matrix dist-coeffs r new-camera-matrix mapx mapy))

(define-cproc cv-undistort-points (src::<cv-mat> dst::<cv-mat>
                                                 camera-matrix::<cv-mat> dist-coeffs::<cv-mat>
                                                 :optional (r-obj ()) (p-obj ())) ::<void>
              (let* ([r::CvMat*]
                     [p::CvMat*])
                (nil-or-obj r-obj r <cv-mat> NULL)
                (nil-or-obj p-obj p <cv-mat> NULL)
                (cvUndistortPoints src dst camera-matrix dist-coeffs r p)))

;;-------------
;;Constants
(define-enum CV_SHAPE_RECT)
(define-enum CV_SHAPE_CROSS)
(define-enum CV_SHAPE_ELLIPSE)
(define-enum CV_SHAPE_CUSTOM)
;;TODO Error message
(define-cproc cv-create-structuring-element-ex (cols::<fixnum> rows::<fixnum> anchor-x::<fixnum> anchor-y::<fixnum> shape::<fixnum>
                                                               :optional (values-obj ())) ::<iplconv-kernel>
              (let* ([values::int*])
                (cond
                  [(SCM_NULLP values-obj) (set! values NULL)]
                  [(SCM_LISTP values-obj) (begin
                                            (if (!= shape CV_SHAPE_CUSTOM)
                                              (Scm_Error "shape != CV_SHAPE_CUSTOM"))
                                            (let* ([len::int (Scm_Length values-obj)])
                                              (if (!= len (* cols rows))
                                                (Scm_Error "values list length != cols * rows"))
                                              (set! values (SCM_MALLOC (* (sizeof _int_t) len)))
                                              (dotimes [i len]
                                                (if (SCM_INTP (SCM_CAR values-obj))
                                                  (set! (aref values i) (SCM_INT_VALUE (SCM_CAR values-obj)))
                                                  (Scm_Error "list value requires int, but got %S" (SCM_CAR values-obj)))
                                                (set! values-obj (SCM_CDR values-obj)))))]
                  [else (Scm_Error "list or nil required, bug got %S" values-obj)])
                (result (cvCreateStructuringElementEx cols rows anchor-x anchor-y shape values))))

(define-cproc cv-release-structuring-element (element::<iplconv-kernel>) ::<void>
              (if element
                (begin
                  (cvReleaseStructuringElement (& element))
                  (set! (-> (SCM_FOREIGN_POINTER element_scm) ptr) NULL))))

(define-cise-stmt (get-element element-obj element)
  (let* ([type (cgen-type-from-name '<iplconv-kernel>)])
    `(cond
       [(SCM_NULLP ,element-obj) (set! ,element NULL)]
       [(,(string->symbol (~ type'c-predicate)) ,element-obj) 
        (begin
          (set! ,element (,(string->symbol (~ type'unboxer)) ,element-obj))
          (ENSURE_NOT_NULL ,element))]
       [else (Scm_Error ,#`",(~ type'description) or () required, but got %S" ,element-obj)])))

(define-cproc cv-erode (src::<cv-arr> dst::<cv-arr>
                                      :optional (element-obj ()) (iterations::<fixnum> 1)) ::<void>
              (let* ([element::IplConvKernel*])
                (get-element element-obj element)
                (cvErode src dst element iterations)))

(define-cproc cv-dilate (src::<cv-arr> dst::<cv-arr>
                                       :optional (element-obj ()) (iterations::<fixnum> 1)) ::<void>
              (let* ([element::IplConvKernel*])
                (get-element element-obj element)
                (cvDilate src dst element iterations)))

(define-cproc cv-morphology-ex (src::<cv-arr> dst::<cv-arr> tmp::<cv-arr>
                                              element::<iplconv-kernel> operation::<fixnum>
                                              :optional (iterations::<fixnum> 1)) ::<void>
              (cvMorphologyEx src dst tmp element operation iterations))


;;-----------------
;;CvMoments
;;
(define-cclass <cv-moments>
               :built-in :struct
               "ScmCvMoments" "Scm_CvMomentsClass"
               ()
               (;;slot
                )
               )

(define-cproc cv-moments (arr::<cv-arr> 
                           :optional (binary?::<boolean> #f)) ::<cv-moments>
              (let* ([moments::CvMoments])
                (cvMoments arr (& moments) binary?)
                (result moments)))

(define-cproc cv-get-spatial-moment (moments::<cv-moments> x-order::<fixnum> y-order::<fixnum>) ::<real>
              (result (cvGetSpatialMoment (& moments) x-order y-order)))

(define-cproc cv-get-central-moment (moments::<cv-moments> x-order::<fixnum> y-order::<fixnum>) ::<real>
              (result (cvGetCentralMoment (& moments) x-order y-order)))

(define-cproc cv-get-normalized-central-moment (moments::<cv-moments> x-order::<fixnum> y-order::<fixnum>) ::<real>
              (result (cvGetNormalizedCentralMoment (& moments) x-order y-order)))

;;-----------------
;;CvHuMoments
;;
(define-cclass <cv-hu-moments>
               :built-in :struct
               "ScmCvHuMoments" "Scm_CvHuMomentsClass"
               ()
               (;;slot
                (hu1 :type <real>
                     :setter #f)
                (hu2 :type <real>
                     :setter #f)
                (hu3 :type <real>
                     :setter #f)
                (hu4 :type <real>
                     :setter #f)
                (hu5 :type <real>
                     :setter #f)
                (hu6 :type <real>
                     :setter #f)
                (hu7 :type <real>
                     :setter #f)
                )
               )

(define-cproc cv-get-hu-moments (moments::<cv-moments>) ::<cv-hu-moments>
              (let* ([hu-moments::CvHuMoments])
                (cvGetHuMoments (& moments) (& hu-moments))
                (result hu-moments)))


;;*************data sampling*********

"
static int max(int x, int y)
{
return (x < y) ? y : x;
}
"

(define-cproc cv-sample-line (image::<cv-arr> pt1::<cv-point> pt2::<cv-point>
                                              :optional (connectivity::<fixnum> 8)) ::<list>
              (let* ([size::int]
                     [buffer::CvPoint*])
                (cond
                  ;;calc buffer size
                  [(== 4 connectivity)
                   (set! size (+ (abs (- (ref pt2 x) (ref pt1 x))) (abs (- (ref pt2 y) (ref pt1 y))) 1))]
                  [(== 8 connectivity)
                   (set! size (max (+ (abs (- (ref pt2 x) (ref pt1 x))) 1) (+ (abs (- (ref pt2 y) (ref pt1 y))) 1)))]
                  [else (Scm_Error "connectivity requires 4 or 8, but got %d" connectivity)])
                (set! buffer  (SCM_MALLOC (* (sizeof CvPoint) size)))
                ;;call cvSampleLine
                (cvSampleLine image pt1 pt2 buffer connectivity)
                ;;array to list
                (let* ([list::ScmObj (Scm_MakeList size SCM_NIL)]
                       [pair::ScmObj list])
                  (dotimes [i size]
                    (SCM_SET_CAR pair (Scm_MakeCvPoint (aref buffer i)))
                    (set! pair (SCM_CDR pair)))
                  (result list))))

(define-cproc cv-get-rect-sub-pix (src::<cv-arr> dst::<cv-arr> center::<cv-point-2d32f>) ::<void>
              (cvGetRectSubPix src dst center))

(define-cproc cv-get-quadrangle-sub-pix (src::<cv-arr> dst::<cv-arr> map-matrix::<cv-mat>) ::<void>
              (cvGetQuadrangleSubPix src dst map-matrix))


;;-------------
;;Constants
(define-enum CV_TM_SQDIFF)
(define-enum CV_TM_SQDIFF_NORMED)
(define-enum CV_TM_CCORR)
(define-enum CV_TM_CCORR_NORMED)
(define-enum CV_TM_CCOEFF)
(define-enum CV_TM_CCOEFF_NORMED)
(define-cproc cv-match-template (image::<cv-arr> templ::<cv-arr>
                                                 result::<cv-arr> method::<fixnum>) ::<void>
              (cvMatchTemplate image templ result method))


;;not support
;;cvCalcEMMD2



;;******************
;;Contours retrieving
;;******************


;;-------------
;;Constants
(define-enum CV_RETR_EXTERNAL)
(define-enum CV_RETR_LIST)
(define-enum CV_RETR_CCOMP)
(define-enum CV_RETR_TREE)

(define-enum CV_CHAIN_CODE)
(define-enum CV_CHAIN_APPROX_NONE)
(define-enum CV_CHAIN_APPROX_SIMPLE)
(define-enum CV_CHAIN_APPROX_TC89_L1)
(define-enum CV_CHAIN_APPROX_TC89_KCOS)
(define-enum CV_LINK_RUNS)

(define-cproc cv-find-contours (image::<cv-arr> storage::<cv-mem-storage> 
                                                :optional (mode::<fixnum> 1) ;;mode 1 is CV_RETR_LIST
                                                (method::<fixnum> 2) ;;method 2 is CV_CHAIN_APPROX_SIMPLE
                                                (offset-obj ())) ::<cv-seq>
              (let* ([offset::CvPoint]
                     [header-size::int (?: (== method CV_CHAIN_CODE)
                                           (sizeof CvChain) (sizeof CvContour))]
                     [seq::CvSeq*])
                (nil-or-obj offset-obj offset <cv-point> (cvPoint 0 0))
                (cvFindContours image storage (& seq) header-size mode method offset)
                (result seq)))

(define-cproc cv-start-find-contours (image::<cv-arr> storage::<cv-mem-storage>
                                                      :optional (mode::<fixnum> 1) ;;mode 1 is CV_RETR_LIST
                                                      (method::<fixnum> 2) ;;method 2 is CV_CHAIN_APPROX_SIMPLE
                                                      (offset-obj ())) ::<cv-contour-scanner>
              (let* ([offset::CvPoint]
                     [header-size::int (?: (== method CV_CHAIN_CODE)
                                           (sizeof CvChain) (sizeof CvContour))])
                (nil-or-obj offset-obj offset <cv-point> (cvPoint 0 0))
                (result (cvStartFindContours image storage header-size mode method offset))))

(define-cproc cv-find-next-contour (scanner::<cv-contour-scanner>) ::<cv-seq>
              (result (cvFindNextContour scanner)))

(define-cproc cv-substitute-contour (scanner::<cv-contour-scanner> new-contour::<cv-seq>) ::<void>
              (cvSubstituteContour scanner new-contour))

(define-cproc cv-end-find-contours (scanner::<cv-contour-scanner>) ::<cv-seq>
              (result (cvEndFindContours (& scanner))))

(define-cproc cv-approx-chains (src-seq::<cv-seq> storage::<cv-mem-storage>
                                                  :optional (method::<fixnum> 2) ;;method 2 is CV_CHAIN_APPROX_SIMPLE
                                                  (parameter::<real> 0)
                                                  (minimal-permeter::<fixnum> 0)
                                                  (recursive::<boolean> #f)) ::<cv-seq>
              (result (cvApproxChains src-seq storage method parameter minimal-permeter recursive)))

(define-cproc cv-start-read-chain-points (chain::<cv-chain>) ::<cv-chain-pt-reader>
              (let* ([reader::CvChainPtReader* (SCM_MALLOC (sizeof CvChainPtReader))])
                (cvStartReadChainPoints chain reader)
                (result reader)))

(define-cproc cv-read-chain-point (reader::<cv-chain-pt-reader>) ::<cv-point>
              (result (cvReadChainPoint reader)))



;;******************
;;Planar subdivisions
;;******************


(define-cclass <cv-subdiv-2d>
               :built-in
               "ScmSubdiv2D*" "Scm_CvSubdiv2DClass"
               ("Scm_CvGraphClass" "Scm_CvSetClass" "Scm_CvSeqClass" "Scm_CvTreeNodeClass")
               (;;slot
                (quad-edges :type <int>
                            :setter #f
                            :c-name "quad_edges")
                (geometry-valid? :type <boolean>
                                 :setter #f
                                 :c-name "is_geometry_valid")
                (recent-edge :type <int>
                             :setter #f
                             :c-name "recent_edge")
                (top-left :type <cv-point-2d32f>
                          :setter #f
                          :c-name "topleft")
                (bottom-right :type <cv-point-2d32f>
                              :setter #f
                              :c-name "bottomright")
                ))

(define-cclass <cv-subdiv-2d-point>
               :built-in
               "ScmSubdiv2DPoint*" "Scm_CvSubdiv2DPointClass"
               ()
               (;;slot
                (flags :type <fixnum>
                       :setter #f)
                (first :type <int>
                       :setter #f)
                (pt :type <cv-point-2d32f>
                    :setter #f)
                (id :type <int>
                    :setter #f)
                ))


(define-cproc cv-init-subdiv-delaunay2d (rect::<cv-rect>) ::<cv-subdiv-2d>
              (let* ([subdiv::CvSubdiv2D* (SCM_MALLOC (sizeof CvSubdiv2D))])
                (cvInitSubdivDelaunay2D subdiv rect)
                (result subdiv)))

;;cvCreateSubdiv2D not support

(define-cproc cv-create-subdiv-delaunay2d (rect::<cv-rect> storage::<cv-mem-storage>) ::<cv-subdiv-2d>
              (result (cvCreateSubdivDelaunay2D rect storage)))

(define-cproc cv-subdiv-delaunay-2d-insert (subdiv::<cv-subdiv-2d> pt::<cv-point-2d32f>) ::<cv-subdiv-2d-point>
              (result (cvSubdivDelaunay2DInsert subdiv pt)))


;;-------------
;;Constants
;;enum CvSubdiv2DPointLocation
(define-enum CV_PTLOC_ERROR)
(define-enum CV_PTLOC_OUTSIDE_RECT)
(define-enum CV_PTLOC_INSIDE)
(define-enum CV_PTLOC_VERTEX)
(define-enum CV_PTLOC_ON_EDGE)
(define-cproc cv-subdiv-2d-locate (subdiv::<cv-subdiv-2d> pt::<cv-point-2d32f>) ::(<fixnum> <int>)
              (let* ([e::CvSubdiv2DEdge]
                     [ret::CvSubdiv2DPointLocation (cvSubdiv2DLocate subdiv pt (& e) 0)])
                (result ret e)))

(define-cproc cv-calc-subdiv-voronoi-2d (subdiv::<cv-subdiv-2d>) ::<void>
              (cvCalcSubdivVoronoi2D subdiv))

(define-cproc cv-clear-subdiv-voronoi-2d (subdiv::<cv-subdiv-2d>) ::<void>
              (cvClearSubdivVoronoi2D subdiv))

(define-cproc cv-find-nearest-point-2d (subdiv::<cv-subdiv-2d> pt::<cv-point-2d32f>) ::<cv-subdiv-2d-point>
              (result (cvFindNearestPoint2D subdiv pt)))

(define-cproc cv-subdiv-2d-next-edge (edge::<int>) ::<int>
              (result (cvSubdiv2DNextEdge edge)))

(define-cproc cv-subdiv-2d-rotate-edge (edge::<int> rotate::<int>) ::<int>
              (result (cvSubdiv2DRotateEdge edge rotate)))

(define-cproc cv-subdiv-2d-sym-edge (edge::<int>) ::<int>
              (result (cvSubdiv2DSymEdge edge)))


;;-------------
;;Constants
;;enum CvNextEdgeType
(define-enum CV_NEXT_AROUND_ORG)
(define-enum CV_NEXT_AROUND_DST)
(define-enum CV_PREV_AROUND_ORG)
(define-enum CV_PREV_AROUND_DST)
(define-enum CV_NEXT_AROUND_LEFT)
(define-enum CV_NEXT_AROUND_RIGHT)
(define-enum CV_PREV_AROUND_LEFT)
(define-enum CV_PREV_AROUND_RIGHT)
(define-cproc cv-subdiv-2d-get-edge (edge::<int> type::<fixnum>) ::<int>
              (result (cvSubdiv2DGetEdge edge type)))

(define-cproc cv-subdiv-2d-edge-org (edge::<int>) ::<cv-subdiv-2d-point>
              (result (cvSubdiv2DEdgeOrg edge)))

(define-cproc cv-subdiv-2d-edge-dst (edge::<int>) ::<cv-subdiv-2d-point>
              (result (cvSubdiv2DEdgeDst edge)))

(define-cproc cv-triangle-area (a::<cv-point-2d32f> b::<cv-point-2d32f> c::<cv-point-2d32f>) ::<real>
              (result (cvTriangleArea a b c)))




;;******************
;;Contour Processing and Shape Analysis
;;******************

(define-cproc cv-approx-poly (src-seq::<cv-seq> storage::<cv-mem-storage> method::<fixnum> parameter::<real>
                              :optional (parameter2::<int> 0))::<cv-seq>
    (result (cvApproxPoly src-seq 
                          (?: (== method CV_CHAIN_CODE)
                              (sizeof CvChain) (sizeof CvContour))
                          storage method parameter parameter2)))

(define-cproc cv-arc-length (curve::<cv-seq>
                             :optional (slice-obj '()) (is-closed::<fixnum> -1))::<real>
  (let* ([slice::CvSlice])
    (nil-or-obj slice-obj slice <cv-slice> CV_WHOLE_SEQ)
    (result (cvArcLength curve slice is-closed))))

(define-cproc cv-contour-perimeter (contour::<cv-seq>) ::<real>
  (result (cvContourPerimeter contour)))

(define-cproc cv-bounding-rect (points::<cv-arr>
                                :optional (update::<fixnum> 0)) ::<cv-rect>
  (result (cvBoundingRect points update)))

(define-cproc cv-contour-area (contour::<cv-arr>
                               :optional (slice-obj '()) (oriented::<int> 0))::<real>
  (let* ([slice::CvSlice])
    (nil-or-obj slice-obj slice <cv-slice> CV_WHOLE_SEQ)
    (result (cvContourArea contour slice oriented))))

(define-cproc cv-min-area-rect2 (points::<cv-arr>
                                 :optional (storage-obj '())) ::<cv-box-2d>
  (let* ([storage::CvMemStorage*])
    (nil-or-obj storage-obj storage <cv-mem-storage> 0)
    (result (cvMinAreaRect2 points storage))))

(define-cproc cv-min-enclosing-circle (points::<cv-arr>) ::(<top> <top>)
  (let* ([center::CvPoint2D32f]
         [radius::float])
    (if (cvMinEnclosingCircle points (& center) (& radius))
      (result (boxing center <cv-point-2d32f>) (boxing radius <float>))
      (result (boxing 0 <boolean>) (boxing 0 <boolean>)))))

;;-------------
;;Constants
(define-enum CV_CONTOURS_MATCH_I1)
(define-enum CV_CONTOURS_MATCH_I2)
(define-enum CV_CONTOURS_MATCH_I3)
(define-cproc cv-match-shapes (obj1 obj2 method::<fixnum>
                               :optional (parameter::<real> 0)) ::<real>
  (let* ([object1::void* (?: (is-type? obj1 <cv-arr>)
                           (unboxing obj1 <cv-arr>) (unboxing obj1 <cv-seq>))]
         [object2::void* (?: (is-type? obj2 <cv-arr>)
                           (unboxing obj2 <cv-arr>) (unboxing obj2 <cv-seq>))])
    (result (cvMatchShapes object1 object2 method parameter))))


(define-cise-stmt (vec-to-mat vec elem-c-type assign var mat-type)
  (let ([ary (gensym "img__")]
        [mat (gensym "img__")])
    `(let* ([,ary :: void*]
            [,mat :: CvMat*])
       (vector-to-ary ,vec ,ary ,elem-c-type ,assign)
       (set! ,mat (cvCreateMatHeader (SCM_VECTOR_SIZE ,vec) 1 ,mat-type))
       (set! (ref (-> ,mat data) ptr) ,ary)
       (set! ,var ,mat))))

;(define-cis-stmt

(define-cise-stmt (cv-point-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<cv-point>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (set! ,var (,(string->symbol (~ type 'unboxer)) ,obj))
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

(define-cise-stmt (cv-point-2d32f-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<cv-point-2d32f>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (set! ,var (,(string->symbol (~ type 'unboxer)) ,obj))
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

"
static int getElementChannels(CvArr* arr)
{
  switch(cvGetElemType(arr))
  {
    case CV_8UC1:
    case CV_8SC1:
    case CV_16UC1:
    case CV_16SC1:
    case CV_32FC1:
    case CV_32SC1:
    case CV_64FC1:
      return 1;

    case CV_8UC2:
    case CV_8SC2:
    case CV_16UC2:
    case CV_16SC2:
    case CV_32FC2:
    case CV_32SC2:
    case CV_64FC2:
      return 2;

    case CV_8UC3:
    case CV_8SC3:
    case CV_16UC3:
    case CV_16SC3:
    case CV_32FC3:
    case CV_32SC3:
    case CV_64FC3:
      return 3;

    case CV_8UC4:
    case CV_8SC4:
    case CV_16UC4:
    case CV_16SC4:
    case CV_32FC4:
    case CV_32SC4:
    case CV_64FC4:
      return 4;
  }

  Scm_Error(\"internal error\");
}
"

(define-cfn obj-to-cvarr (obj::ScmObj arr::void** length::int* 
                                      create-mat?::int* input-type::int*) ::void
  (cond
    [(is-type? obj <vector>) 
     (let* ([vec::ScmVector* (unboxing obj <vector>)])
       (set! (* create-mat?) 1)
       (if (not length)
         (set! (* length) (SCM_VECTOR_SIZE vec)))
       (cond
         [(is-type? (SCM_VECTOR_ELEMENT vec 0) <cv-point>) 
          (if (not input-type)
            (set! (* input-type) 0))
          (vec-to-mat vec CvPoint cv-point-elem-assign (* arr) CV_32SC2)]
         [(is-type? (SCM_VECTOR_ELEMENT vec 0) <cv-point-2d32f>) 
          (if (not input-type)
            (set! (* input-type) 1))
          (vec-to-mat vec CvPoint2D32f cv-point-2d32f-elem-assign (* arr) CV_32FC2)]
         [else (Scm_Error "type of input vector elements must be <cv-point> or <cv-point-2d32f>")]))]

    [(is-type? obj <cv-arr>)
     (if (is-type? obj <cv-seq>)
       (let* ([seq :: CvSeq* (unboxing obj <cv-seq>)])
         (set! (* arr) seq)
         (if (not length)
           (set! (* length) (-> seq total))))
       (let* ([ary :: CvArr* (unboxing obj <cv-arr>)]
              [size :: CvSize (cvGetSize ary)])
         (set! (* arr) ary)
         (if (not length)
           (set! (* length) (/ (* (ref size height)
                                  (ref size width)
                                  (getElementChannels ary))
                                2)))))]
    [else (Scm_Error "<cv-arr> or <vector> or <list> required, but got %S" obj)]))


;;-------------
;;Constants
(define-enum CV_CLOCKWISE)
(define-enum CV_COUNTER_CLOCKWISE)

(define-constant CV_INPUT_INTEGER 0)
(define-constant CV_INPUT_REAL 1)
;;TODO support sequence input
(define-cproc cv-convex-hull2 (input-obj ;<cv-point> or <cv-point-2d32f> of vecotr or sequence
                                ;;input-type is original parameter
                                ;;allow CV_INPUT_INTEGER or CV_INPUT_REAL
                               :optional (input-type::<fixnum> -1)
                               (orientation::<fixnum> 1) ;orientation 1 is CV_CLOCKWISE
                               ) ::<vector>
  (let* ([input :: void*]
         [input-length :: int]
         [create-mat? :: int 0])
    ;;setting input
    (obj-to-cvarr input-obj (& input) (& input-length)
                  (& create-mat?) (& input-type))
    (if (or (== input-type 0) (== input-type 1))
      (Scm_Error "Unkown Input type"))

    (let* ([output-mat :: CvMat* (cvCreateMat input-length 1 (?: (== input-type 0)
                                                                 CV_32SC2 CV_32FC2))])
      ;;call cvConvexHull2
      (cvConvexHull2 input output-mat orientation 1)

      ;;constract output
      (let* ([out-vec::ScmVector* (cast ScmVector* (Scm_MakeVector (- (+ (-> output-mat rows)
                                                                         (-> output-mat cols))
                                                                      1)
                                                                   SCM_UNDEFINED))])
        (if (== input-type 0)
          (let* ([data::CvPoint* (cast CvPoint* (ref (-> output-mat data) ptr))])
            (dotimes [i (SCM_VECTOR_SIZE out-vec)]
              (set! (SCM_VECTOR_ELEMENT out-vec i) (boxing (aref data i) <cv-point>))))
          (let* ([data::CvPoint2D32f* (cast CvPoint2D32f* (ref (-> output-mat data) ptr))])
            (dotimes [i (SCM_VECTOR_SIZE out-vec)]
              (set! (SCM_VECTOR_ELEMENT out-vec i) (boxing (aref data i) <cv-point-2d32f>)))))
        (result out-vec))

      (cvReleaseMat (& output-mat)))

    (if create-mat?
      (cvReleaseMat (& input)))
    ))


(define-cproc cv-check-contour-convexity (contour) ::<boolean>
  (let* ([input :: void*]
         [create-mat? :: int 0])
    (obj-to-cvarr contour (& input) 0 (& create-mat?) 0)
    (result (cvCheckContourConvexity input))
    (if create-mat?
      (cvReleaseMat (& input)))))


;;not support cvConvexityDefects

(define-cproc cv-fit-ellipse2 (points::<cv-seq>) ::<cv-box-2d>
  (result (cvFitEllipse2 points)))

(define-cproc cv-max-rect (rect1::<cv-rect> rect2::<cv-rect>)::<cv-rect>
  (result (cvMaxRect (& rect1) (& rect2))))

(define-cproc cv-box-points (box::<cv-box-2d>) ::<vector>
  (let* ([vec::ScmVector* (cast ScmVector* (Scm_MakeVector 4 SCM_UNDEFINED))]
         [pt::(.array CvPoint2D32f (4))])
    (cvBoxPoints box pt)
    (set! (SCM_VECTOR_ELEMENT vec 0) (boxing (aref pt 0) <cv-point-2d32f>))
    (set! (SCM_VECTOR_ELEMENT vec 1) (boxing (aref pt 1) <cv-point-2d32f>))
    (set! (SCM_VECTOR_ELEMENT vec 2) (boxing (aref pt 2) <cv-point-2d32f>))
    (set! (SCM_VECTOR_ELEMENT vec 3) (boxing (aref pt 3) <cv-point-2d32f>))
    (result vec)))

(define-cproc cv-point-polygon-test (contour-obj pt::<cv-point-2d32f> measure-dist::<boolean>) ::<real>
  (let* ([contour::void*])
    (cond
      [(is-type? contour-obj <cv-seq>)
       (set! contour (unboxing contour-obj <cv-seq>))]
      [(is-type? contour-obj <cv-chain>)
       (set! contour (unboxing contour-obj <cv-chain>))]
      [else (Scm_Error "<cv-seq> or <cv-chain> required, but got %S" contour-obj)])
    (result (cvPointPolygonTest contour pt measure-dist))))



;;******************
;;Histogram functions
;;******************

(define-cproc cv-create-hist (sizes-obj type::<fixnum>
                            :optional (ranges-obj '())
                            (uniform::<boolean> #t)) :: <cv-histogram>
  (let* ([sizes :: int*]
         [dims :: int]
         [ranges :: float**])
    (cond
      [(is-type? sizes-obj <list>)
       (set! dims (Scm_Length sizes-obj))
       (list-to-ary sizes-obj sizes _int_t int-elem-assign)]
      [(is-type? sizes-obj <vector>)
       (set! dims (SCM_VECTOR_SIZE sizes-obj))
       (vector-to-ary sizes-obj sizes _int_t int-elem-assign)]
      [(is-type? sizes-obj <s32vector>)
       (set! dims (SCM_S32VECTOR_SIZE sizes-obj))
       (uvector.int-elem-assign sizes sizes-obj)]
      [else (Scm_Error "<list> or <vector> or <s32vector> required, but got %S" sizes-obj)]
      )
    (cond
      [(SCM_NULLP ranges-obj)
       (set! ranges 0)]
      [(is-type? ranges-obj <list>)
       (list-to-ary ranges-obj ranges _float_t* list.float-elem-assign)]
      [(is-type? ranges-obj <vector>)
       (if (is-type? (SCM_VECTOR_ELEMENT ranges-obj 0) <f32vector>)
         (vector-to-ary ranges-obj ranges _float_t* uvector.float-elem-assign)
         (vector-to-ary ranges-obj ranges _float_t* vector.float-elem-assign))]
      [else (Scm_Error "<list> or <vector> required, but got %S" ranges-obj)]
      )
    (result (cvCreateHist dims sizes type ranges uniform))))

(define-cproc cv-set-hist-bin-ranges (hist::<cv-histogram> ranges-obj
                                      :optional (uniform::<boolean> #t)) ::<void>
  (ENSURE_NOT_NULL hist)
  (let* ([ranges :: float**])
    (cond
      [(SCM_NULLP ranges-obj)
       (set! ranges 0)]
      [(is-type? ranges-obj <list>)
       (list-to-ary ranges-obj ranges _float_t* list.float-elem-assign)]
      [(is-type? ranges-obj <vector>)
       (if (is-type? (SCM_VECTOR_ELEMENT ranges-obj 0) <f32vector>)
         (vector-to-ary ranges-obj ranges _float_t* uvector.float-elem-assign)
         (vector-to-ary ranges-obj ranges _float_t* vector.float-elem-assign))]
      [else (Scm_Error "<list> or <vector> required, but got %S" ranges-obj)]
      )
    (cvSetHistBinRanges hist ranges uniform)))

;;not support cvMakeHistHeaderForArray

(define-cproc cv-release-hist (hist::<cv-histogram>) ::<void>
  (if hist
    (begin
      (cvReleaseHist (& hist))
      (set! (-> (SCM_FOREIGN_POINTER hist_scm) ptr) NULL))))

(define-cproc cv-clear-hist (hist::<cv-histogram>) ::<void>
  (cvClearHist hist))

(define-cproc cv-get-minmax-hist-value (hist::<cv-histogram>) ::(<int> <int>)
  (let* ([min :: float]
         [max :: float])
    (cvGetMinMaxHistValue hist (& min) (& max) 0 0)
    (result min max)))

(define-cproc cv-normalize-hist (hist::<cv-histogram> factor::<real>) ::<void>
  (cvNormalizeHist hist factor))

(define-cproc cv-thresh-hist (hist::<cv-histogram> threshold::<real>) ::<void>
  (cvThreshHist hist threshold))

;;-------------
;;Constants
(define-enum CV_COMP_CORREL)
(define-enum CV_COMP_CHISQR)
(define-enum CV_COMP_INTERSECT)
(define-enum CV_COMP_BHATTACHARYYA)
(define-cproc cv-compare-hist (hist1::<cv-histogram> hist2::<cv-histogram>
                               method::<fixnum>) ::<real>
  (result (cvCompareHist hist1 hist2 method)))

(define-cproc cv-copy-hist (hist::<cv-histogram>
                            :optional (out-obj ())) ::<cv-histogram>
  (let* ([out :: CvHistogram*])
    (nil-or-obj out-obj out <cv-histogram> 0)
    (cvCopyHist hist (& out))
    (result out)))

;;not support cvCalcBayesianProb


(define-cise-stmt (cvarr-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<cv-arr>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (set! ,var (,(string->symbol (~ type 'unboxer)) ,obj))
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

(define-cproc cv-calc-arr-hist (arr hist::<cv-histogram>
                                :optional (accumulate::<int> 0)
                                (mask-obj ())) ::<void>
  (let* ([array :: CvArr**]
          [mask :: CvArr*])
    (cond
      [(is-type? arr <list>)
       (list-to-ary arr array CvArr* cvarr-elem-assign)]
      [(is-type? arr <vector>)
       (vector-to-ary arr array CvArr* cvarr-elem-assign)]
      [else (Scm_Error "<list> or <vector> required, but got %S" arr)])
    (nil-or-cvarr mask-obj mask)
    (cvCalcArrHist array hist accumulate mask)))

(define-cproc cv-calc-hist (image hist::<cv-histogram>
                            :optional (accumulate::<int> 0)
                            (mask-obj ())) ::<void>
  (let* ([array :: CvArr**]
          [mask :: CvArr*])
    (cond
      [(is-type? image <list>)
       (list-to-ary image array CvArr* cvarr-elem-assign)]
      [(is-type? image <vector>)
       (vector-to-ary image array CvArr* cvarr-elem-assign)]
      [else (Scm_Error "<list> or <vector> required, but got %S" image)])
    (nil-or-cvarr mask-obj mask)
    (cvCalcArrHist array hist accumulate mask)))


(define-cproc cv-equalize-hist (src::<cv-arr> dst::<cv-arr>)
  (cvEqualizeHist src dst))


;;-------------
;;Constants
(define-enum CV_DIST_USER)
(define-enum CV_DIST_L1)
(define-enum CV_DIST_L2)
(define-enum CV_DIST_C)
(define-enum CV_DIST_L12)
(define-enum CV_DIST_FAIR)
(define-enum CV_DIST_WELSCH)
(define-enum CV_DIST_HUBER)
(define-cproc cv-dist-transform (src::<cv-arr> dst::<cv-arr>
                                 :optional (distance-type::<fixnum> 2) ;;distance-type 2 is CV_DIST_L2
                                 (mask-size::<fixnum> 3)
                                 (mask-obj ()) (labels-obj ())) ::<void>
  (let* ([mask::float*]
         [labels::CvArr*])
    (cond
      [(SCM_NULLP mask-obj)
       (set! mask 0)]
      [(is-type? mask-obj <list>)
       (list-to-ary mask-obj mask _float_t float-elem-assign)]
      [(is-type? mask-obj <f32vector>)
       (set! mask (SCM_F32VECTOR_ELEMENTS (unboxing mask-obj <f32vector>)))]
      [(is-type? mask-obj <vector>)
       (vector-to-ary mask-obj mask _float_t float-elem-assign)]
      )
    (nil-or-cvarr labels-obj labels)
    (cvDistTransform src dst distance-type mask-size mask labels)))


;;-------------
;;Constants
(define-enum CV_THRESH_BINARY)
(define-enum CV_THRESH_BINARY_INV)
(define-enum CV_THRESH_TRUNC)
(define-enum CV_THRESH_TOZERO)
(define-enum CV_THRESH_TOZERO_INV)
(define-enum CV_THRESH_MASK)
(define-enum CV_THRESH_OTSU)
(define-cproc cv-threshold (src::<cv-arr> dst::<cv-arr>
                            threshold::<real> max-value::<real> 
                            threshold-type::<fixnum>) ::<real>
  (result (cvThreshold src dst threshold max-value threshold-type)))

;;-------------
;;Constants
(define-enum CV_ADAPTIVE_THRESH_MEAN_C)
(define-enum CV_ADAPTIVE_THRESH_GAUSSIAN_C)
(define-cproc cv-adaptive-threshold (src::<cv-arr> dst::<cv-arr> max-value::<real>
                                     :optional (adaptive-method::<fixnum> 0) ;adaptive-method 0 is CV_ADAPTIVE_THRESH_MEAN_C
                                     (threshold-type::<fixnum> 0) ;threshold-type 0 is CV_THRESH_BINARY
                                     (block-size::<fixnum> 3)
                                     (param1::<real> 5)) ::<void>
  (cvAdaptiveThreshold src dst max-value adaptive-method threshold-type block-size param1))


(define-cclass <cv-connected-comp>
               :built-in :struct
               "ScmCvConnectedComp" "Scm_CvConnectedCompClass"
               ()
               (;;slot
                (area :type <double>
                      :setter #f)
                (value :type <cv-scalar>
                       :setter #f)
                (rect :type <cv-rect>
                      :setter #f)
                (contour :type <cv-seq>
                         :setter #f)
                )
               (print #t)
               )

;;-------------
;;Constants
(define-enum CV_FLOODFILL_FIXED_RANGE)
(define-enum CV_FLOODFILL_MASK_ONLY)
(define-cproc cv-flood-fill (image::<cv-arr> seed-point::<cv-point> new-val::<cv-scalar>
                             :optional (lo-diff-obj ()) (up-diff-obj ()) 
                             (flags::<fixnum> 4) (mask-obj ())) ::<cv-connected-comp>
  (let* ([lo-diff :: CvScalar]
         [up-diff :: CvScalar]
         [mask :: CvArr*]
         [comp :: CvConnectedComp])
    (nil-or-obj lo-diff-obj lo-diff <cv-scalar> (cvScalarAll 0))
    (nil-or-obj up-diff-obj up-diff <cv-scalar> (cvScalarAll 0))
    (nil-or-cvarr mask-obj mask)
    (cvFloodFill image seed-point new-val lo-diff up-diff (& comp) flags mask)
    (result comp)))


;;******************
;;Feature detection
;;******************

(define-cproc cv-canny (image::<cv-arr> edges::<cv-arr> 
                        threshold1::<real> threshold2::<real>
                        :optional (aperture-size::<fixnum> 3)) ::<void>
  (cvCanny image edges threshold1 threshold2 aperture-size))

(define-cproc cv-pre-corner-detect (image::<cv-arr> corners::<cv-arr>
                                    :optional (aperture-size::<fixnum> 3)) ::<void>
  (cvPreCornerDetect image corners aperture-size))

(define-cproc cv-corner-eigen-vals-and-vecs (image::<cv-arr> eigenvv::<cv-arr> block-size::<fixnum>
                                             :optional (aperture-size::<fixnum> 3)) ::<void>
  (cvCornerEigenValsAndVecs image eigenvv block-size aperture-size))

(define-cproc cv-corner-min-eigen-val (image::<cv-arr> eigenval::<cv-arr> block-size::<fixnum>
                                       :optional (aperture-size::<fixnum> 3)) ::<void>
  (cvCornerMinEigenVal image eigenval block-size aperture-size))

(define-cproc cv-corner-harris (image::<cv-arr> harris-response::<cv-arr> block-size::<fixnum>
                                :optional (aperture-size::<fixnum> 3)
                                (k::<real> 0.04)) ::<void>
  (cvCornerHarris image harris-response block-size aperture-size k))

(define-cproc cv-find-corner-sub-pix (image::<cv-arr> corners-obj::<top>
                                      count::<int> win::<cv-size> zero-zone::<cv-size>
                                      criteria::<cv-term-criteria>) ::<void>
  (let* ([corners :: CvPoint2D32f*])
    (cond
      [(is-type? corners-obj <list>)
       (list-to-ary corners-obj corners CvPoint2D32f cv-point-2d32f-elem-assign)]
      [(is-type? corners-obj <vector>)
       (vector-to-ary corners-obj corners CvPoint2D32f cv-point-2d32f-elem-assign)]
      [else (Scm_Error "<list> or <vector> required, but got %S" corners-obj)]
      )
    (cvFindCornerSubPix image corners count win zero-zone criteria)))

"
#define MAX_CORNER_COUNT 100
"
(define-cproc cv-good-features-to-track (image::<cv-arr> quality-level::<real> min-distance::<real>
                                         :optional (mask-obj ())
                                         (block-size::<fixnum> 3) (use-harris::<boolean> #f)
                                         (k::<real> 0.04)) ::<vector>
  (let* ([corners :: (.array CvPoint2D32f (MAX_CORNER_COUNT))]
         [count :: int MAX_CORNER_COUNT]
         [mask :: CvArr*]
         [vec :: ScmVector*])
    (nil-or-cvarr mask-obj mask)
    (cvGoodFeaturesToTrack image 0 0 corners (& count) quality-level min-distance 
                           mask block-size use-harris k)
    (set! vec (cast ScmVector* (Scm_MakeVector count SCM_UNDEFINED)))
    (dotimes [i count]
      (set! (SCM_VECTOR_ELEMENT vec i) (boxing (aref corners i) <cv-point-2d32f>)))
    (result vec)))


;;-------------
;;Constants
(define-enum CV_HOUGH_STANDARD)
(define-enum CV_HOUGH_PROBABILISTIC)
(define-enum CV_HOUGH_MULTI_SCALE)
(define-enum CV_HOUGH_GRADIENT)
(define-cproc cv-hough-lines2 (image::<cv-arr> line-storage-obj::<top> method::<fixnum>
                               rho::<real> theta::<real> threshold::<fixnum>
                               :optional (param1::<real> 0) (param2::<real> 0)) ::<cv-seq>
  (let* ([line-storage :: void*])
    (cond
      [(is-type? line-storage-obj <cv-mem-storage>)
        (set! line-storage (unboxing line-storage-obj <cv-mem-storage>))]
      [(is-type? line-storage-obj <cv-mat>)
       (set! line-storage (unboxing line-storage-obj <cv-mat>))]
      [else (Scm_Error "<cv-mem-storage> or <cv-mat> required, but got %S" line-storage-obj)])
    (result (cvHoughLines2 image line-storage method rho theta threshold param1 param2))))

(define-cproc cv-hough-circles (image::<cv-arr> circle-storage-obj::<top> method::<fixnum>
                                dp::<real> min-dist::<real>
                                :optional (param1::<real> 100) (param2::<real> 100)
                                (min-radius::<fixnum> 0) (max-radius::<fixnum> 0)) ::<cv-seq>
  (let* ([circle-storage :: void*])
    (cond
      [(is-type? circle-storage-obj <cv-mem-storage>)
        (set! circle-storage (unboxing circle-storage-obj <cv-mem-storage>))]
      [(is-type? circle-storage-obj <cv-mat>)
       (set! circle-storage (unboxing circle-storage-obj <cv-mat>))]
      [else (Scm_Error "<cv-mem-storage> or <cv-mat> required, but got %S" circle-storage-obj)])
    (result (cvHoughCircles image circle-storage method dp min-dist
                            param1 param2 min-radius max-radius))))


(define-cise-stmt (cv-point-3d32f-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<cv-point-3d32f>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (set! ,var (,(string->symbol (~ type 'unboxer)) ,obj))
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

;;-------------
;;Constants
(define-enum CV_DIST_USER)
(define-enum CV_DIST_L1)
(define-enum CV_DIST_L2)
(define-enum CV_DIST_C)
(define-enum CV_DIST_L12)
(define-enum CV_DIST_FAIR)
(define-enum CV_DIST_WELSCH)
(define-enum CV_DIST_HUBER)
(define-cproc cv-fit-line (points-obj::<top> dist-type::<fixnum> param::<real>
                           reps::<real> aeps::<real>
                           ;;dims is original parameter
                           ;;specify points dimension(2 or 3)
                           dims::<fixnum>)::<vector>
  (if (or (== dims 2) (== dims 3))
    (Scm_Error "dims: 2 or 3 required."))
  (let* ([points :: void*]
         [line :: (.array float* (6))])
    (cond
      [(is-type? points-obj <cv-seq>)
       (set! points (unboxing points-obj <cv-seq>))]
      [(is-type? points-obj <cv-mat>)
       (set! points (unboxing points-obj <cv-mat>))]
      [(is-type? points-obj <list>)
       (if (null? points-obj)
         (Scm_Error "poins parameter is null"))
       (cond
         [(is-type? (SCM_CAR points-obj) <cv-point-2d32f>)
          (list-to-ary points-obj points CvPoint2D32f cv-point-2d32f-elem-assign)]
         [(is-type? (SCM_CAR points-obj) <cv-point-3d32f>)
          (list-to-ary points-obj points CvPoint3D32f cv-point-3d32f-elem-assign)]
         [else (Scm_Error "each element of list is <cv-point-2d32f> or <cv-point-3d32f> required.")])]
      [(is-type? points-obj <vector>)
       (if (zero? (SCM_VECTOR_SIZE points-obj))
         (Scm_Error "poins parameter is 0 size"))
       (cond
         [(is-type? (SCM_VECTOR_ELEMENT points-obj 0) <cv-point-2d32f>)
          (vector-to-ary points-obj points CvPoint2D32f cv-point-2d32f-elem-assign)]
         [(is-type? (SCM_VECTOR_ELEMENT points-obj 0) <cv-point-3d32f>)
          (vector-to-ary points-obj points CvPoint3D32f cv-point-3d32f-elem-assign)]
         [else (Scm_Error "each element of vector is <cv-point-2d32f> or <cv-point-3d32f> required.")])]
      [else (Scm_Error "<cv-arr> or <cv-mat> or <list> or <vector> required, but got %S" points-obj)]
      )

    (cvFitLine points dist-type param reps aeps line)

    (let* ([vec :: ScmVector* (cast ScmVector* (Scm_MakeVector (* dims 2) SCM_UNDEFINED))])
      (dotimes [i (* dims 2)]
        (set! (SCM_VECTOR_ELEMENT vec i) (aref line i)))
      (result vec))))


(define-cproc cv-create-kd-tree (desc::<cv-mat>) ::<cv-feature-tree>
  (result (cvCreateKDTree desc)))

(define-cproc cv-create-spill-tree (raw-data::<cv-mat>
                                    :optional (naive::<int> 60)
                                    (rho::<real> 0.7) (tau::<real> 0.1)) ::<cv-feature-tree>
  (result (cvCreateSpillTree raw-data naive rho tau)))

(define-cproc cv-release-feature-tree (tree::<cv-feature-tree>) ::<void>
  (if tree
    (begin
      (cvReleaseFeatureTree tree)
      (set! (-> (SCM_FOREIGN_POINTER tree_scm) ptr) NULL))))

(define-cproc cv-find-features (tree::<cv-feature-tree> query-points::<cv-mat>
                                indices::<cv-mat> dist::<cv-mat>
                                :optional (k::<int> 2) (emax::<int> 20)) ::<void>
  (ENSURE_NOT_NULL tree)
  (cvFindFeatures tree query-points indices dist k emax))

(define-cproc cv-find-features-boxed (tree::<cv-feature-tree> bounds-min::<cv-mat> bounds-max::<cv-mat>
                                      out-indices::<cv-mat>) ::<int>
  (ENSURE_NOT_NULL tree)
  (result (cvFindFeaturesBoxed tree bounds-min bounds-max out-indices)))

(define-cproc cv-create-memory-lsh (d::<int> n::<int>
                                    :optional (L::<int> 10) (k::<int> 10)
                                    (type::<fixnum> 6) ;type 6 is CV_64FC1
                                    (r::<real> 4) (seed::<long> -1)) ::<cv-lsh>
  (result (cvCreateMemoryLSH d n L k type r seed)))

(define-cproc cv-release-lsh (lsh::<cv-lsh>)::<void>
  (if lsh
    (begin
      (cvReleaseLSH (& lsh))
      (set! (-> (SCM_FOREIGN_POINTER lsh_scm) ptr) NULL))))

(define-cproc lsh-size (lsh::<cv-lsh>) ::<uint32>
  (ENSURE_NOT_NULL lsh)
  (result (LSHSize lsh)))

(define-cproc cv-lsh-add (lsh::<cv-lsh> data::<cv-mat>
                          :optional (indices-obj ())) ::<void>
  (ENSURE_NOT_NULL lsh)
  (let* ([indices :: CvMat*])
    (nil-or-obj indices-obj indices <cv-mat> 0)
    (cvLSHAdd lsh data indices)))

(define-cproc cv-lsh-remove (lsh::<cv-lsh> indices::<cv-mat>) ::<void>
  (ENSURE_NOT_NULL lsh)
  (cvLSHRemove lsh indices))

(define-cproc cv-lsh-query (lsh::<cv-lsh> query-points::<cv-mat>
                            indices::<cv-mat> dist::<cv-mat> k::<int> emax::<int>) ::<void>
  (ENSURE_NOT_NULL lsh)
  (cvLSHQuery lsh query-points indices dist k emax))


