;;;
;;; gauche_cvlib.stub
;;;
;;; MIT License
;;; Copyright 2011-2012 aharisu
;;; All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy
;;; of this software and associated documentation files (the "Software"), to deal
;;; in the Software without restriction, including without limitation the rights
;;; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;;; copies of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all
;;; copies or substantial portions of the Software.
;;;
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;;; SOFTWARE.
;;;
;;;
;;; aharisu
;;; foo.yobina@gmail.com
;;;

"
#include \"gauche_cv_core.h\"
#include <opencv2/core/core_c.h>
#include <string.h> //for memmove

#include \"core_type.gen.h\"

typedef void* _pvoid_t;
typedef unsigned char _char_t;
typedef signed char _schar_t;
typedef signed short _short_t;
typedef unsigned short _ushort_t;
typedef int _int_t;
typedef unsigned int _uint_t;
typedef float _float_t;
typedef double _double_t;

"
(define-type
	<cv-object>
	"CvObject"
	"CvObject"
	"SCM_CVOBJECT_P"
	"SCM_CVOBJECT_DATA"
	"SCM_MAKE_CVOBJECT")

(define-type
	<cv-struct>
	"CvStruct"
	"CvStruct"
	"SCM_CVSTRUCT_P"
	"SCM_CVSTRUCT_DATA"
	"SCM_MAKE_CVSTRUCT")

;;---------------
;; CvObject
;;
(define-cclass <cv-object>
  :built-in :struct
  "ScmCvObject" "Scm_CvObjectClass"
  ()
  (;;slot
   )
  )

;;---------------
;; CvStruct
;;
(define-cclass <cv-struct>
  :built-in :struct
  "ScmCvStruct" "Scm_CvStructClass"
  ()
  (;;slot
   )
  )

(include "cv_type.stub.header")
(include "core_type.gen.stub.header")
(include "macro.stub.header")

(define-constant c:null (c "SCM_UNDEFINED"))


(define-cise-stmt raise-cv-error 
  [(_ func-name msg)
    `(Scm_RaiseCondition
      (SCM_OBJ SCM_CLASS_OPENCV_ERROR)
       SCM_RAISE_CONDITION_MESSAGE
        "%s: %s"
         ,(symbol->string func-name) ,msg)]
  )

(define-cproc cv-round (value::<real>) :: <int>
  (result (cvRound value)))

(define-cproc cv-floor (value::<real>) :: <int>
  (result (cvFloor value)))

(define-cproc cv-ceil (value::<real>)::<int>
  (result (cvCeil value)))

(define-cproc cv-is-nan? (value::<real>)::<boolean>
  (result (cvIsNaN value)))

(define-cproc cv-is-inf? (value::<real>)::<boolean>
  (result (cvIsInf value)))


;;--------------------------------------
;; Constants
;;


;; IPL Image Depth
(define-enum IPL_DEPTH_1U)
(define-enum IPL_DEPTH_8U)
(define-enum IPL_DEPTH_16U)
(define-enum IPL_DEPTH_8S)
(define-enum IPL_DEPTH_16S)
(define-enum IPL_DEPTH_32S)
(define-enum IPL_DEPTH_32F)
;;;;;
;; for storing double-precision
;; floating point data in IplImage's */
(define-enum IPL_DEPTH_64F)

;;Matrix type(CvMat)
(define-enum CV_8U)
(define-enum CV_8S)
(define-enum CV_16U)
(define-enum CV_16S)
(define-enum CV_32S)
(define-enum CV_32F)
(define-enum CV_64F)
;(define-enum CV_USERTYPE1)


(define-enum CV_8UC1)
(define-enum CV_8UC2)
(define-enum CV_8UC3)
(define-enum CV_8UC4)
;(define-enum CV_8UC(n))
(define-enum CV_8SC1)
(define-enum CV_8SC2)
(define-enum CV_8SC3)
(define-enum CV_8SC4)
;(define-enum CV_8SC(n))
(define-enum CV_16UC1)
(define-enum CV_16UC2)
(define-enum CV_16UC3)
(define-enum CV_16UC4)
;(define-enum CV_16UC(n))
(define-enum CV_16SC1)
(define-enum CV_16SC2)
(define-enum CV_16SC3)
(define-enum CV_16SC4)
;(define-enum CV_16SC(n))
(define-enum CV_32SC1)
(define-enum CV_32SC2)
(define-enum CV_32SC3)
(define-enum CV_32SC4)
;(define-enum CV_32SC(n))
(define-enum CV_32FC1)
(define-enum CV_32FC2)
(define-enum CV_32FC3)
(define-enum CV_32FC4)
;(define-enum CV_32FC(n))
(define-enum CV_64FC1)
(define-enum CV_64FC2)
(define-enum CV_64FC3)
(define-enum CV_64FC4)
;(define-enum CV_64FC(n))

(define-enum CV_AUTO_STEP)
(define-constant CV_WHOLE_ARR (c "SCM_MAKE_CVSLICE(CV_WHOLE_ARR)"))

(define-enum IPL_BORDER_CONSTANT)
(define-enum IPL_BORDER_REPLICATE)
(define-enum IPL_BORDER_REFLECT)
(define-enum IPL_BORDER_WRAP)

;;---------------
;; CvRNG
;;
(define-cclass <cv-rng>
  :built-in
  "ScmCvRNG" "Scm_CvRNGClass"
  ("Scm_CvObjectClass")
  (;;slot
   )
  )

(define-cproc make-cv-rng (:optional (seed::<integer> -1)) ::<cv-rng>
  (let* ([p-rng::CvRNG* (cast CvRNG* (SCM_MALLOC (sizeof CvRNG)))])
    (set! (* p-rng) (cvRNG (Scm_GetInteger64Clamp seed SCM_CLAMP_BOTH NULL)))
    (result p-rng)))

;;;;;
;;@return random 32-bit unsigned integer
(define-cproc cv-rand-int (rng::<cv-rng>) :: <uint32>
  (result (cvRandInt rng)))

;;;;;
;;@return random floating-point number between 0 and 1
(define-cproc cv-rand-real (rng::<cv-rng>) :: <real>
  (result (cvRandReal rng)))

;;--------------
;; CvRect
;;
(define-cclass <cv-rect>
  :built-in :struct
  "ScmCvRect" "Scm_CvRectClass"
  ("Scm_CvObjectClass")
  (;;slot
   (x :type <fixnum>)
   (y :type <fixnum>)
   (width :type <fixnum>)
   (height :type <fixnum>)
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvRect")
  )

(define-cproc make-cv-rect (x::<int> y::<int> width::<int> height::<int>)::<cv-rect>
  (call "cvRect"))

;;--------------
;; IplImage
;;
;;;;;
;;@slot n-channels {@ 1 2 3 4}
;; Most of OpenCV functions support 1,2,3 or 4 channels.
;;@slot depth {@ IPL_DEPTH_8U IPL_DEPTH_8S IPL_DEPTH_16S IPL_DEPTH_32S IPL_DEPTH_32F IPL_DEPTH_64F}
;; Pixel depth is bits.
;;@slot width Image width in pixels.
;;@slot height Image height in pixels.
;;@slot roi Image ROI. 
;;@slot image-size Image data size in bytes.
;; (==height*width-step in case of interleaved data)
;;@slot width-step Size of aligned image row in bytes.
(define-cclass <iplimage>
  :built-in
  "ScmIplImage*" "Scm_IplImageClass"
  ("Scm_CvObjectClass") ;cpa
  (;;slot
   (n-channels :type <fixnum>
               :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(obj->nChannels);"
               :setter #f
               :c-name "nChannels")
   (depth :type <int>
          :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(obj->depth);"
          :setter #f)
   (width :type <fixnum>
          :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(obj->width);"
          :setter #f)
   (height :type <fixnum>
           :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(obj->height);"
           :setter #f)
   (image-size :type <int>
               :c-name "imageSize"
               :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(obj->imageSize);"
               :setter #f)
   (width-step :type <fixnum>
               :c-name "widthStep"
               :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(obj->widthStep);"
               :setter #f)
   (roi :type <cv-rect>
        :getter "ENSURE_NOT_NULL(obj)
        return SCM_MAKE_CVRECT((obj->roi == NULL) ? 
                                                  cvRect(0, 0, obj->width, obj->height) : 
                                                  cvRect(obj->roi->xOffset, obj->roi->yOffset, obj->roi->width, obj->roi->height));"
        :setter "ENSURE_NOT_NULL(obj) cvSetImageROI(obj, SCM_CVRECT_DATA(value));")
   (coi :type <int>
        :getter "ENSURE_NOT_NULL(obj);
        return Scm_MakeInteger(cvGetImageCOI(obj));"
        :setter "ENSURE_NOT_NULL(obj);
        cvSetImageCOI(obj, Scm_GetInteger(value));")
   (image-data :type <top>
              :setter #f
              :getter "
              ScmObj vec;

              ENSURE_NOT_NULL(obj);
              switch(obj->depth)
              {
              case IPL_DEPTH_8U:
                vec = Scm_MakeU8VectorFromArrayShared(obj->imageSize, (unsigned char*)obj->imageData);
                break;
              case IPL_DEPTH_8S:
                vec = Scm_MakeS8VectorFromArrayShared(obj->imageSize, (signed char*)obj->imageData);
              break;
              case IPL_DEPTH_16S:
                vec = Scm_MakeS16VectorFromArrayShared(obj->imageSize, (signed short*)obj->imageData);
              break;
              case IPL_DEPTH_32S:
                vec = Scm_MakeS32VectorFromArrayShared(obj->imageSize, (signed int*)obj->imageData);
              break;
              case IPL_DEPTH_32F:
                vec = Scm_MakeF32VectorFromArrayShared(obj->imageSize, (float*)obj->imageData);
              break;
              case IPL_DEPTH_64F:
                vec = Scm_MakeF64VectorFromArrayShared(obj->imageSize, (double*)obj->imageData);
              break;
              }
              return vec;
              ")
  ))

;;;;;
;; Creates IPL image (header and data)
;;@param depth {@
;; IPL_DEPTH_8U IPL_DEPTH_8S IPL_DEPTH_16U 
;; IPL_DEPTH_16S IPL_DEPTH_32S IPL_DEPTH_32F IPL_DEPTH_64F
;; }
;;@param nchannels {@ 1 2 3 4}
(define-cproc make-image (width::<fixnum> height::<fixnum> depth::<int> nchannels::<fixnum>) ::<iplimage>
  (expr "cvCreateImage(cvSize(width, height), depth, nchannels)"))

;;;;;
;; Creates IPL image (header only. shared vector buffer)
;;@param depth {@
;; IPL_DEPTH_8U IPL_DEPTH_8S IPL_DEPTH_16U 
;; IPL_DEPTH_16S IPL_DEPTH_32S IPL_DEPTH_32F IPL_DEPTH_64F
;; }
;;@param nchannels {@ 1 2 3 4}
(define-cproc make-image-shared (width::<fixnum> height::<fixnum> depth::<int> nchannels::<fixnum> vec::<uvector>) ::<iplimage>
  (let* ([image :: IplImage* (cvCreateImageHeader (cvSize width height) depth nchannels)])
    (when (< (Scm_UVectorSizeInBytes vec) (@ image->imageSize))
      (cvReleaseImage (& image))
      (Scm_Error "vec is to small"))
    (set! (@ image->imageData) (SCM_UVECTOR_ELEMENTS vec))))

;;;;;
;; Releases IPL image header and data
(define-cproc cv-release-image (obj::<iplimage>) ::<void>
  (body  <void> 
         "if(obj) {
         cvReleaseImage(&obj);
         SCM_IPLIMAGE(obj_scm)->data = NULL;
         }"))

;;;;;
;; Creates a copy of IPL image (widthStep may differ)
(define-cproc cv-clone-image (image::<iplimage>) ::<iplimage>
  (ENSURE_NOT_NULL image)
  (result (cvCloneImage image)))

;;;;;
;; Sets a Channel Of Interest (only a few functions support COI) -
;; use cv-copy to extract the selected channel and/or put it back
;; @param coi {@ 1 2 3 4}
(define-cproc cv-set-image-coi (image::<iplimage> coi::<int>) :: <void>
  (ENSURE_NOT_NULL image)
  (cvSetImageCOI image coi))

;;;;;
;; Retrieves image Channel Of Interest
(define-cproc cv-get-image-coi (image::<iplimage>) :: <int>
  (ENSURE_NOT_NULL image)
  (result (cvGetImageCOI image)))

;;;;;
;; Sets image ROI (region of interest) (COI is not changed)
(define-cproc cv-set-image-roi (image::<iplimage> rect::<cv-rect>) ::<void>
  (ENSURE_NOT_NULL image)
  (cvSetImageROI image rect))

;;;;;
;; Retrieves image ROI
(define-cproc cv-get-image-roi (image::<iplimage>) ::<cv-rect>
  (ENSURE_NOT_NULL image)
  (result (cvGetImageROI image)))

;;;;;
;; Resets image ROI and COI
(define-cproc cv-reset-image-roi (image::<iplimage>) ::<void>
  (ENSURE_NOT_NULL image)
  (cvResetImageROI image))


(define-cproc cv-copy-buffer-to-image (buf::<uvector> image::<iplimage>) :: <void>
  (ENSURE_NOT_NULL image)
  (let* ([size :: int (Scm_UVectorSizeInBytes buf)])
    (when (< (@ image->imageSize)  size)
      (Scm_Error "buf is too large"))
    (memmove (@ image->imageData) (SCM_UVECTOR_ELEMENTS buf) size)))



;;-------------
;; CvMat
;;

(define-cclass <cv-mat>
  :built-in
  "ScmCvMat*" "Scm_CvMatClass"
  ("Scm_CvObjectClass") ;cpa
  (;;slot
   (type :type <int>
         :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(CV_MAT_TYPE(obj->type));"
         :setter #f)
   (step :type <fixnum>
         :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(obj->step);"
         :setter #f)
   (rows :type <fixnum>
         :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(obj->rows);"
         :setter #f)
   (cols :type <fixnum>
         :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(obj->cols);"
         :setter #f)
   ))

;;;;;
;; Allocates and initializes <cv-mat> header and allocates data
;; @param type {@ 
;; CV_8UC1 CV_8UC2 CV_8UC3 CV_8UC4 
;; CV_8SC1 CV_8SC2 CV_8SC3 CV_8SC4 
;; CV_16UC1 CV_16UC2 CV_16UC3 CV_16UC4 
;; CV_16SC1 CV_16SC2 CV_16SC3 CV_16SC4 
;; CV_32UC1 CV_32UC2 CV_32UC3 CV_32UC4 
;; CV_32FC1 CV_32FC2 CV_32FC3 CV_32FC4 
;; CV_64FC1 CV_64FC2 CV_64FC3 CV_64FC4 
;;}
(define-cproc make-cv-mat (rows::<fixnum> cols::<fixnum> type::<int>) ::<cv-mat>
  (call "cvCreateMat"))

;;;;;
;; Allocates and initializes <cv-mat> header and allocates data
;;@param  v {@ <s8vector> <u8vector> <s16vector> <u16vector> <s32vector> <f32vector> <f64vector>}
(define-cproc make-cv-mat-from-uvector (rows::<fixnum> cols::<fixnum> channel::<fixnum> v::<uvector>) :: <cv-mat>
  (let* ([type :: int]
         [mat :: CvMat*])
    (cond
      [(is-type? v <s8vector>)(set! type CV_8S)]
      [(is-type? v <u8vector>)(set! type CV_8U)]
      [(is-type? v <s16vector>)(set! type CV_16S)]
      [(is-type? v <u16vector>)(set! type CV_16U)]
      [(is-type? v <s32vector>)(set! type CV_32S)]
      [(is-type? v <f32vector>)(set! type CV_32F)]
      [(is-type? v <f64vector>)(set! type CV_64F)]
      [else (Scm_Error "Unkown UVector type.")])
    (set! mat (cvCreateMat rows cols (CV_MAKETYPE type channel)))
    (memcpy (ref (-> mat data) ptr) (SCM_UVECTOR_ELEMENTS v) (Scm_UVectorSizeInBytes v))
    (result mat)))

;;;;;
;; Releases <cv-mat> header and deallocates matrix data
;; (reference counting is used for data)
(define-cproc cv-release-mat (mat::<cv-mat>) ::<void>
  (body <void>
        "if(mat) {
        cvReleaseMat(&mat);
        SCM_CVMAT(mat_scm)->data = NULL;
        }"))

;;;;;
;; Creates an exact copy of the input matrix (except, may be, step value)
(define-cproc cv-clone-mat (mat::<cv-mat>) ::<cv-mat>
  (ENSURE_NOT_NULL mat)
  (result (cvCloneMat mat)))

(define-cproc cv-m-get (mat::<cv-mat> row::<fixnum> col::<fixnum>) :: <real>
  (ENSURE_NOT_NULL mat)
  (result (cvmGet mat row col)))

(define-cproc cv-m-set (mat::<cv-mat> row::<fixnum> col::<fixnum> value::<real>) :: <void>
  (ENSURE_NOT_NULL mat)
  (cvmSet mat row col value))

;;;;;
;; Makes a new matrix from <cv-rect> subrectangle of input array.
;; No data is copied
(define-cproc cv-get-sub-rect (arr::<cv-arr> rect::<cv-rect>) :: <top>
  (ENSURE_NOT_NULL arr)
  (let* ([submat :: CvMat* (SCM_NEW CvMat)]
         [ret :: CvMat* (cvGetSubRect arr submat rect)]
         [ret-obj :: ScmObj])
    (create-obj ret-obj ret ScmCvMat SCM_CLASS_CVMAT)
    (result ret-obj)))

;;;;;
;; Selects row span of the input array: arr(start-row:delta-row:end-row,:)
;;  (end-row is not included into the span).
(define-cproc cv-get-rows (arr::<cv-arr> start-row::<fixnum> end-row::<fixnum>
                                         :optional (delta-row::<fixnum> 1)) :: <top>
  (ENSURE_NOT_NULL arr)
  (let* ([submat :: CvMat* (SCM_NEW CvMat)]
         [ret :: CvMat* (cvGetRows arr submat start-row end-row delta-row)]
         [ret-obj :: ScmObj])
    (create-obj ret-obj ret ScmCvMat SCM_CLASS_CVMAT)
    (result ret-obj)))

;;;;;
;; Selects row span of the input array: arr(row:1:row+1)
(define-cproc cv-get-row (arr::<cv-arr> row::<fixnum>) :: <top>
  (ENSURE_NOT_NULL arr)
  (let* ([submat :: CvMat* (SCM_NEW CvMat)]
         [ret :: CvMat* (cvGetRow arr submat row)]
         [ret-obj :: ScmObj])
    (create-obj ret-obj ret ScmCvMat SCM_CLASS_CVMAT)
    (result ret-obj)))

;;;;;
;; Selects column span of the input array: arr(:,start_col:end_col)
;; (end_col is not included into the span)
(define-cproc cv-get-cols (arr::<cv-arr> start-col::<fixnum> end-col::<fixnum>) :: <top>
  (ENSURE_NOT_NULL arr)
  (let* ([submat :: CvMat* (SCM_NEW CvMat)]
         [ret :: CvMat* (cvGetCols arr submat start-col end-col)]
         [ret-obj :: ScmObj])
    (create-obj ret-obj ret ScmCvMat SCM_CLASS_CVMAT)
    (result ret-obj)))

;;;;;
;; Selects col span of the input array: arr(col:1:col+1)
(define-cproc cv-get-col (arr::<cv-arr> col::<fixnum>) :: <top>
  (ENSURE_NOT_NULL arr)
  (let* ([submat :: CvMat* (SCM_NEW CvMat)]
         [ret :: CvMat* (cvGetCol arr submat col)]
         [ret-obj :: ScmObj])
    (create-obj ret-obj ret ScmCvMat SCM_CLASS_CVMAT)
    (result ret-obj)))

;;;;;
;; Select a diagonal of the input array.
;; The diagonal will be represented as a column (nx1 matrix).
;; @param (diag 0) 
;; (diag = 0 means the main diagonal, >0 means a diagonal above the main one, <0 - below the main one).
(define-cproc cv-get-diag (arr::<cv-arr> start-col::<fixnum> 
                                         :optional (diag::<fixnum> 0)) :: <top>
  (ENSURE_NOT_NULL arr)
  (let* ([submat :: CvMat* (SCM_NEW CvMat)]
         [ret :: CvMat* (cvGetDiag arr submat diag)]
         [ret-obj :: ScmObj])
    (create-obj ret-obj ret ScmCvMat SCM_CLASS_CVMAT)
    (result ret-obj)))

(define-cproc cv-are-types-eq? (mat1::<top> mat2::<top>) :: <boolean>
  (let* ([mat1-obj :: CvMat*]
         [mat2-obj :: CvMat*])
    (if (or (is-type? mat1 <cv-mat>) (is-type? mat1 <cv-matnd>) (is-type? mat1 <cv-sparse-mat>))
      (set! mat1-obj (unboxing mat1 <cv-mat>))
      (Scm_Error "<cv-mat> or <cv-matnd> or <cv-sparse-mat> required, but got %S." mat2))
    (if (or (is-type? mat2 <cv-mat>) (is-type? mat2 <cv-matnd>) (is-type? mat2 <cv-sparse-mat>))
      (set! mat2-obj (unboxing mat2 <cv-mat>))
      (Scm_Error "<cv-mat> or <cv-matnd> or <cv-sparse-mat> required, but got %S." mat2))
    (ENSURE_NOT_NULL mat1-obj)
    (ENSURE_NOT_NULL mat2-obj)
    (result (CV_ARE_TYPES_EQ mat1-obj mat2-obj))))

(define-cproc cv-are-cns-eq? (mat1::<cv-mat> mat2::<cv-mat>) :: <boolean>
  (ENSURE_NOT_NULL mat1)
  (ENSURE_NOT_NULL mat2)
  (result (CV_ARE_CNS_EQ mat1 mat2)))

(define-cproc cv-are-depths-eq? (mat1::<cv-mat> mat2::<cv-mat>) :: <boolean>
  (ENSURE_NOT_NULL mat1)
  (ENSURE_NOT_NULL mat2)
  (result (CV_ARE_DEPTHS_EQ mat1 mat2)))

(define-cproc cv-are-sizes-eq? (mat1::<cv-mat> mat2::<cv-mat>) :: <boolean>
  (ENSURE_NOT_NULL mat1)
  (ENSURE_NOT_NULL mat2)
  (result (CV_ARE_SIZES_EQ mat1 mat2)))


;;-------------
;; CvMatND
;;
(define-cclass <cv-matnd>
  :built-in
  "ScmCvMatND*" "Scm_CvMatNDClass"
  ("Scm_CvObjectClass") ;cpa
  (;;slot
   (type :type <int>
         :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(CV_MAT_TYPE(obj->type));"
         :setter #f)
   (dims :type <fixnum>
         :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(obj->dims);"
         :setter #f)
   ))

(define-cproc cv-get-matnd-dim (matnd::<cv-matnd> index::<fixnum>) ::(<int> <int>)
  (body (<int> <int>)
        "ENSURE_NOT_NULL(matnd)" 
        "int size = matnd->dim[index].size;"
        "int step = matnd->dim[index].step;"
        (result size step)))

;;;;;
;; Allocates and initializes <cv-matnd> header and allocates data
(define-cproc make-cv-matnd (dims::<fixnum> sizes::<s32vector> type::<int>) ::<cv-matnd>
  (expr "cvCreateMatND(dims, SCM_S32VECTOR_ELEMENTS(sizes), type)"))

;;;;;
;; Releases <cv-matnd>
(define-cproc cv-release-matnd (mat::<cv-matnd>) ::<void>
  (body <void>
        "if(mat) {
        cvReleaseMatND(&mat);
        SCM_CVMATND(mat_scm)->data = NULL;
        }"))

;;;;;
;; Creates a copy of <cv-matnd> (except, may be, steps)
(define-cproc cv-clone-matnd (mat::<cv-matnd>) ::<cv-matnd>
  (call "cvCloneMatND"))

;;-------------
;; CvSparseMat
;;
(define-cclass <cv-sparse-mat>
  :built-in
  "ScmCvSparseMat*" "Scm_CvSparseMatClass"
  ("Scm_CvObjectClass") ;cpa
  (;;slot
   (type :type <int>
         :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(CV_MAT_TYPE(obj->type));"
         :setter #f)
   (dims :type <fixnum>
         :getter "ENSURE_NOT_NULL(obj) return Scm_MakeInteger(obj->dims);"
         :setter #f)
   ))

;;;;;
;; Allocates and initializes <cv-sparse-mat> header and allocates data
(define-cproc make-cv-sparse-mat (dims::<fixnum> sizes::<s32vector> type::<int>) ::<cv-sparse-mat>
  (expr "cvCreateSparseMat(dims, SCM_S32VECTOR_ELEMENTS(sizes), type)"))

;;;;;
;; Releases <cv-sparse-mat>
(define-cproc cv-release-sparse (mat::<cv-sparse-mat>) ::<void>
  (body <void>
        "if(mat) {
        cvReleaseSparseMat(&mat);
        SCM_CVSPARSEMAT(mat_scm)->data = NULL;
        }"))

;;;;;
;; Creates a copy of <cv-sparse-mat> (except, may be, zero items)
(define-cproc cv-clone-sparse-mat (mat::<cv-sparse-mat>) ::<cv-sparse-mat>
  (ENSURE_NOT_NULL mat)
  (result (cvCloneSparseMat mat)))

;(define-cclass <cv-sparse-node>
; :built-in
; "ScmCvSparseNode*" "Scm_CvSparseNodeClass"
; ()
; (;;slot
;	))

;(define-cclass <cv-sparse-mat-iterator>
;:built-in
;"ScmCvSparseMatIterator*" "Scm_CvSparseMatIteratorClass"
;()
;(;;slot
;))

;;;;;
;; Initializes sparse array iterator
;; (returns the first node or NULL if the array is empty)
(define-cproc cv-init-sparse-mat-iterator (mat::<cv-sparse-mat> it::<cv-sparse-mat-iterator>) ::<top>
  (ENSURE_NOT_NULL mat)
  (let* ([ret :: CvSparseNode* (cvInitSparseMatIterator mat it)])
    (if ret
      (result (boxing ret <cv-sparse-node>))
      (result (boxing 0 <boolean>)))))

;;;;;
;; returns next sparse array node (or NULL if there is no more nodes)
(define-cproc cv-get-next-sparse-node (it::<cv-sparse-mat-iterator>) ::<top>
  (let* ([ret :: CvSparseNode* (cvGetNextSparseNode it)])
    (if ret
      (result (boxing ret <cv-sparse-node>))
      (result (boxing 0 <boolean>)))))

;;
;;General clone function
(define-cproc cv-clone (arr::<top>) :: <top>
  (cond
    [(is-type? arr <iplimage>)
     (ENSURE_NOT_NULL (unboxing arr <iplimage>))
     (result (boxing (cvCloneImage (unboxing arr <iplimage>)) <iplimage>))]
    [(is-type? arr <cv-mat>)
     (ENSURE_NOT_NULL (unboxing arr <cv-mat>))
     (result (boxing (cvCloneMat (unboxing arr <cv-mat>)) <cv-mat>))]
    [(is-type? arr <cv-matnd>)
     (ENSURE_NOT_NULL (unboxing arr <cv-matnd>))
     (result (boxing (cvCloneMatND (unboxing arr <cv-matnd>)) <cv-matnd>))]
    [(is-type? arr <cv-sparse-mat>)
     (ENSURE_NOT_NULL (unboxing arr <cv-sparse-mat>))
     (result (boxing (cvCloneSparseMat (unboxing arr <cv-sparse-mat>)) <cv-sparse-mat>))]
    [else (Scm_Error "Unkown type.")]))


;;---------------
;; CvHistogram
;;

(define-enum CV_HIST_ARRAY)
(define-enum CV_HIST_SPARSE)
(define-enum CV_HIST_TREE)
;(define-enum CV_HIST_UNIFORM)

(define-cclass <cv-histogram>
  :built-in
  "ScmCvHistogram*" "Scm_CvHistogramClass"
  ("Scm_CvObjectClass") ;cpa
  (;;slot
   (bins :type <cv-arr>
         :getter "ENSURE_NOT_NULL(obj) 
         if(CV_IS_SPARSE_HIST(obj)) {
          ScmCvSparseMat* ret = SCM_NEW(ScmCvSparseMat);
          SCM_SET_CLASS(ret, SCM_CLASS_CVSPARSEMAT);
          ret->data = obj->bins;
          return (CvArr*)ret;
         } else {
          ScmCvMatND* ret = SCM_NEW(ScmCvMatND);
          SCM_SET_CLASS(ret, SCM_CLASS_CVMATND);
          ret->data = obj->bins;
          return (CvArr*)ret;
         }"
         :setter #f)
   ))


;;---------------
;; CvTermCriteria
;;

;;---------------
;; Constants
(define-enum CV_TERMCRIT_ITER)
(define-enum CV_TERMCRIT_NUMBER)
(define-enum CV_TERMCRIT_EPS)

;;;;;
;;@slot type {@ CV_TERMCRIT_EPS CV_TERMCRIT_ITER}
;; may be combination of CV_TERMCRIT_EPS CV_TERMCRIT_ITER
(define-cclass <cv-term-criteria>
  :built-in :struct
  "ScmCvTermCriteria" "Scm_CvTermCriteriaClass"
  ("Scm_CvStructClass")
  (;;slot
   (type	:type <int>)
   (max-iter :type <int>
             :c-name "max_iter")
   (epsilon	:type <double>)
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvTermCriteria")
  )

(define-cproc make-cv-term-criteria (type::<int> max-iter::<int> epsilon::<double>) ::<cv-term-criteria>
  (call "cvTermCriteria"))


;;---------------
;; CvPoint
;;
(define-cclass <cv-point>
  :built-in :struct
  "ScmCvPoint" "Scm_CvPointClass"
  ("Scm_CvStructClass")
  (;;slot
   (x :type <int>)
   (y :type <int>)
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvPoint")
  )
(define-cproc make-cv-point (x::<int> y::<int>) ::<cv-point>
  (call "cvPoint"))

;;---------------
;; CvPoint2D32f
;;
(define-cclass <cv-point-2d32f>
  :built-in :struct
  "ScmCvPoint2D32f" "Scm_CvPoint2D32fClass"
  ("Scm_CvStructClass")
  (;;slot
   (x :type <float>)
   (y :type <float>)
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvPoint2D32f")
  )
(define-cproc make-cv-point-2d32f (x::<float> y::<float>) ::<cv-point-2d32f>
  (call "cvPoint2D32f"))

;;---------------
;; CvPoint3D32f
;;
(define-cclass <cv-point-3d32f>
  :built-in :struct
  "ScmCvPoint3D32f" "Scm_CvPoint3D32fClass"
  ("Scm_CvStructClass")
  (;;slot
   (x :type <float>)
   (y :type <float>)
   (z :type <float>)
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvPoint3D32f")
  )
(define-cproc make-cv-point-3d32f (x::<float> y::<float> z::<float>) ::<cv-point-3d32f>
  (call "cvPoint3D32f"))

;;---------------
;; CvPoint2D64f
;;
(define-cclass <cv-point-2d64f>
  :built-in :struct
  "ScmCvPoint2D64f" "Scm_CvPoint2D64fClass"
  ("Scm_CvStructClass")
  (;;slot
   (x :type <double>)
   (y :type <double>)
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvPoint2D64f")
  )
(define-cproc make-cv-point-2d64f (x::<double> y::<double>) ::<cv-point-2d64f>
  (call "cvPoint2D64f"))

;;---------------
;; CvPoint3D64f
;;
(define-cclass <cv-point-3d64f>
  :built-in :struct
  "ScmCvPoint3D64f" "Scm_CvPoint3D64fClass"
  ("Scm_CvStructClass")
  (;;slot
   (x :type <double>)
   (y :type <double>)
   (z :type <double>)
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvPoint3D64f")
  )
(define-cproc make-cv-point-3d64f (x::<double> y::<double> z::<double>) ::<cv-point-3d64f>
  (call "cvPoint3D64f"))

;;---------------
;; CvSize
;;
(define-cclass <cv-size>
  :built-in :struct
  "ScmCvSize" "Scm_CvSizeClass"
  ("Scm_CvStructClass")
  (;;slot
   (width :type <int>)
   (height :type <int>)
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvSize")
  )
(define-cproc make-cv-size (width::<int> height::<int>) ::<cv-size>
  (call "cvSize"))

;;---------------
;; CvSize2D32f
;;
(define-cclass <cv-size-2d32f>
  :built-in :struct
  "ScmCvSize2D32f" "Scm_CvSize2D32fClass"
  ("Scm_CvStructClass")
  (;;slot
   (width :type <float>)
   (height :type <float>)
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvSize2D32f")
  )
(define-cproc make-cv-size-2d32f (width::<float> height::<float>) ::<cv-size-2d32f>
  (call "cvSize2D32f"))

;;---------------
;; CvBox2D
;;
;;;;;
;;@slot center Center of the box.
;;@slot size Box width and length.
;;@slot angle Angle between the horizontal axis
;; and the first side (i.e. length) in degrees
(define-cclass <cv-box-2d>
  :built-in :struct
  "ScmCvBox2D" "Scm_CvBox2DClass"
  ("Scm_CvStructClass")
  (;;slot
   (center :type <cv-point-2d32f>)
   (size :type <cv-size-2d32f>)
   (angle :type <float>)
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvBox2D")
  )
(define-cproc make-cv-box-2d (center::<cv-point-2d32f> size::<cv-size-2d32f> angle::<float>) ::<cv-box-2d>
  (body <cv-box-2d>
        "SCM_RESULT.center = center;"
        "SCM_RESULT.size = size;"
        "SCM_RESULT.angle = angle;"))

;;---------------
;; CvScalar
;;
(define-cclass <cv-slice>
  :built-in :struct
  "ScmCvSlice" "Scm_CvSliceClass"
  ("Scm_CvStructClass")
  (;;slot
   (start :type <fixnum>
          :c-name "start_index")
   (end :type <fixnum>
        :c-name "end_index")
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvSlice")
  )
(define-cproc make-cv-slice (start::<fixnum> end::<fixnum>) ::<cv-slice>
  (call "cvSlice"))

(define-constant CV_WHOLE_SEQ (c "SCM_MAKE_CVSLICE(CV_WHOLE_SEQ)"))

;;---------------
;; CvScalar
;;
(define-cclass <cv-scalar>
  :built-in :struct
  "ScmCvScalar" "Scm_CvScalarClass"
  ("Scm_CvStructClass")
  (;;slot
   (val0 :type <double>
         :c-name "val[0]")
   (val1 :type <double>
         :c-name "val[1]")
   (val2 :type <double>
         :c-name "val[2]")
   (val3 :type <double>
         :c-name "val[3]")
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvScalar")
  )

(define-cproc make-cv-scalar (val0::<double> :optional
                                             (val1::<double> 0.0)
                                             (val2::<double> 0.0)
                                             (val3::<double> 0.0)) ::<cv-scalar>
  (call "cvScalar"))
(define-cproc make-cv-real-scalar (val0::<double>)::<cv-scalar>
  (call "cvRealScalar"))
(define-cproc make-cv-scalar-all (val0123::<double>)::<cv-scalar>
  (call "cvScalarAll"))


;;-----------------
;;CvLineSegmentPolar (Original type)
;;
(define-cclass <cv-line-segment-polar>
  :built-in :struct
  "ScmCvLineSegmentPolar" "Scm_CvLineSegmentPolarClass"
  ("Scm_CvStructClass")
  (
   (rho :type <real>)
   (theta :type <real>)
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvLineSegmentPolar")
  )

(define-cproc make-cv-line-segment-polar (rho::<real> theta::<real>) :: <cv-line-segment-polar>
  (let* ([v :: CvLineSegmentPolar])
    (set! (ref v rho) rho)
    (set! (ref v theta) theta)
    (result v)))

;;-----------------
;;CvLineSegmentPoint (Original type)
;;
(define-cclass <cv-line-segment-point>
  :built-in :struct
  "ScmCvLineSegmentPoint" "Scm_CvLineSegmentPointClass"
  ("Scm_CvStructClass")
  (
   (p1 :type <cv-point>)
   (p2 :type <cv-point>)
   )
  (printer #t)
  (compare #t)
  (c-core-type "CvLineSegmentPoint")
  )

(define-cproc make-cv-line-segment-point (p1::<cv-point> p2::<cv-point>) :: <cv-line-segment-point>
  (let* ([v :: CvLineSegmentPoint])
    (set! (ref v p1) p1)
    (set! (ref v p2) p2)
    (result v)))

;;-------------------------
;;   Memory storage
;;

;;;;;
;; Creates new memory storage.
;; @param (block-size 0) 0 means that default,
;; somewhat optimal size, is used (currently, it is 64K)
(define-cproc make-cv-mem-storage (:optional (block-size::<fixnum> 0)) ::<cv-mem-storage>
  (call "cvCreateMemStorage"))

;;;;;
;; Creates a memory storage that will borrow memory blocks from parent storage
(define-cproc make-cv-child-mem-storage (parent::<cv-mem-storage>) ::<cv-mem-storage>
  (ENSURE_NOT_NULL parent)
  (result (cvCreateChildMemStorage parent )))

;;;;;
;; Releases memory storage. All the children of a parent must be released before
;; the parent. A child storage returns all the blocks to parent when it is released
(define-cproc cv-release-mem-storage (storage::<cv-mem-storage>) ::<void>
  (body <void>
        "if(storage) {
        cvReleaseMemStorage(&storage);
        SCM_FOREIGN_POINTER(storage_scm)->ptr = NULL;
        }"))

;;;;;
;; Clears memory storage. This is the only way(!!!) (besides cv-restore-mem-storage-pos)
;; to reuse memory allocated for the storage - cv-clear-seq,cv-clear-set...
;; do not free any memory.
;; A child storage returns all the blocks to the parent when it is cleared
(define-cproc cv-clear-mem-storage (storage::<cv-mem-storage>) ::<void>
  (ENSURE_NOT_NULL storage)
  (cvClearMemStorage storage))

;;;;;
;; Remember a storage "free memory" position
(define-cproc cv-save-mem-storage-pos (storage::<cv-mem-storage>) ::<cv-mem-storage-pos>
  (ENSURE_NOT_NULL storage)
  (let* ([ret::CvMemStoragePos* (SCM_NEW CvMemStoragePos)])
    (cvSaveMemStoragePos storage ret)
    (result ret)))

;;;;;
;; Restore a storage "free memory" position
(define-cproc cv-restore-mem-storage-pos (storage::<cv-mem-storage> pos::<cv-mem-storage-pos>) ::<void>
  (ENSURE_NOT_NULL storage)
  (cvRestoreMemStoragePos storage pos))


;;-------------------------
;;   Sequence
;;
;;;;;
;;@slot prev Previous sequence block.
;;@slot next NExt sequence block.
;;@slot start-index Index of the first element in the block + sequence->first->start->index.
;;@slot count Number of elements in the block.
(define-cclass <cv-seq-block>
  :built-in
  "ScmCvSeqBlock*" "Scm_CvSeqBlockClass"
  ("Scm_CvObjectClass")
  (;;slot
   (prev :type <cv-seq-block>
         :setter #f)
   (next :type <cv-seq-block>
         :setter #f)
   (start-index :type <fixnum>
                :setter #f
                :c-name "start_index")
   (count :type <fixnum>
          :setter #f)
   ))

(define-cclass <cv-tree-node>
  :built-in
  "ScmCvTreeNode*" "Scm_CvTreeNodeClass"
  ("Scm_CvObjectClass")
  (;;slot
   ))

;;;;;
;;@slot h-prev Previous sequence.
;;@slot h-next Next sequence.
;;@slot v-prev 2nd previous sequence.
;;@slot v-next 2nd next sequnece.
;;@slot total Total number of elements.
(define-cclass <cv-seq>
  :built-in
  "ScmCvSeq*" "Scm_CvSeqClass"
  ("Scm_CvTreeNodeClass" "Scm_CvObjectClass")
  (;;slot
   (h-prev :type <cv-seq>
           :setter #f
           :getter "
           if(obj->h_prev == NULL)
            return SCM_MAKE_BOOL(0);
           else
            return SCM_MAKE_CVSEQ(obj->h_prev);
           "
           :c-name "h_prev")
   (h-next :type <cv-seq>
           :setter #f
           :getter "
           if(obj->h_next == NULL)
            return SCM_MAKE_BOOL(0);
           else
            return SCM_MAKE_CVSEQ(obj->h_next);
           "
           :c-name "h_next")
   (v-prev :type <cv-seq>
           :setter #f
           :getter "
           if(obj->v_prev == NULL)
            return SCM_MAKE_BOOL(0);
           else
            return SCM_MAKE_CVSEQ(obj->v_prev);
           "
           :c-name "v_prev")
   (v-next :type <cv-seq>
           :setter #f
           :getter "
           if(obj->v_next == NULL)
            return SCM_MAKE_BOOL(0);
           else
            return SCM_MAKE_CVSEQ(obj->v_next);
           "
           :c-name "v_next")
   (total	:type <fixnum>
                :setter #f)
   (elem-size :type <fixnum>
              :setter #f)
   (delta-elems :type <fixnum>
                :setter #f)
   ))

;;---------------
;; Constants
(define-enum CV_SEQ_ELTYPE_POINT)
(define-enum CV_SEQ_ELTYPE_CODE)
(define-enum CV_SEQ_ELTYPE_PPOINT)
(define-enum CV_SEQ_ELTYPE_INDEX)
(define-enum CV_SEQ_ELTYPE_GRAPH_VERTEX)
(define-enum CV_SEQ_ELTYPE_GRAPH_EDGE)
(define-enum CV_SEQ_ELTYPE_TRIAN_ATR)
(define-enum CV_SEQ_ELTYPE_CONNECTED_COMP)
(define-enum CV_SEQ_ELTYPE_POINT3D)
;;---------------
;; Kind
;; types of sequences
(define-enum CV_SEQ_KIND_GENERIC)
(define-enum CV_SEQ_KIND_CURVE)
(define-enum CV_SEQ_KIND_BIN_TREE)
;; types of sparse sequences (sets)
(define-enum CV_SEQ_KIND_GRAPH)
(define-enum CV_SEQ_KIND_SUBDIV2D)

;;flags for curves
(define-enum CV_SEQ_FLAG_CLOSED)
(define-enum CV_SEQ_FLAG_SIMPLE)
(define-enum CV_SEQ_FLAG_CONVEX)
(define-enum CV_SEQ_FLAG_HOLE)

;;flags for graphs
(define-enum CV_GRAPH_FLAG_ORIENTED)
(define-enum CV_GRAPH)
(define-enum CV_ORIENTED_GRAPH)

;;points sets
(define-enum CV_SEQ_POINT_SET)
(define-enum CV_SEQ_POINT3D_SET)
(define-enum CV_SEQ_POLYLINE)
(define-enum CV_SEQ_POLYGON)
(define-enum CV_SEQ_CONTOUR)
(define-enum CV_SEQ_SIMPLE_POLYGON)
(define-enum CV_SEQ_ELTYPE_PTR)

;;chain-coded curves
(define-enum CV_SEQ_CHAIN)
(define-enum CV_SEQ_CHAIN_CONTOUR)

;;binary tree for the contour
(define-enum CV_SEQ_POLYGON_TREE)

;;sequence of the connected components
(define-enum CV_SEQ_CONNECTED_COMP)

;;sequence of the integer numbers
(define-enum CV_SEQ_INDEX)

;;;;;
;; Creates new empty sequence that will reside in the specified storage
;; @param ((flag 7) >> (flag CV_SEQ_ELTYPE_PTR))
(define-cproc make-cv-seq (storage::<cv-mem-storage>
                            :optional (flag::<fixnum> 7)) ;flag 7 is CV_SEQ_ELTYPE_PTR
  ::<cv-seq>
  (ENSURE_NOT_NULL storage)
  (let* ([size::int])
    (if (== flag CV_SEQ_ELTYPE_PTR)
      (set! size (sizeof ScmObj))
      (begin
        (set! size (CV_MAT_CN (logand flag CV_SEQ_ELTYPE_MASK)))
        (case (CV_MAT_DEPTH (logand flag CV_SEQ_ELTYPE_MASK))
          ([CV_SEQ_ELTYPE_PTR] (set! size (sizeof ScmObj)))
          ([CV_8U CV_8S])
          ([CV_16U CV_16S] (set! size (* size 2)))
          ([CV_32S CV_32F] (set! size (* size 4)))
          ([CV_64F] (set! size (* size 8)))
          (else (Scm_Error "unknown element type %d." (logand flag CV_SEQ_ELTYPE_MASK))))))
    (result (cvCreateSeq flag (sizeof CvSeq) size storage))))

;;;;;
;; Changes default size (granularity) of sequence blocks.
;; The default size is ~1Kbyte
(define-cproc cv-set-seq-blocksize (seq::<cv-seq> delta_elems::<fixnum>) ::<void>
  (cvSetSeqBlockSize seq delta_elems))

(define-cise-stmt (case-seq-type-set seq obj point seg-polar seg-point code index point3d user)
  `(case (CV_SEQ_ELTYPE ,seq)
     ([CV_SEQ_ELTYPE_POINT] (if (SCM_CVPOINT_P ,obj)
                              ,point
                              (Scm_Error "CvPoint required, but got %S" ,obj)))
     ([CV_32FC2] (if (is-type? ,obj <cv-line-segment-polar>)
                   ,seg-polar
                   (Scm_Error "CvLineSegmentPolar required, but got %S" ,obj)))
     ([CV_32SC4] (if (is-type? ,obj <cv-line-segment-point>)
                   ,seg-point
                   (Scm_Error "CvLineSegmentPoint required, but got %S" ,obj)))
     ([CV_SEQ_ELTYPE_CODE] (if (SCM_UINTP ,obj)
                             ,code
                             (Scm_Error "<uint8> required, but got %S" ,obj)))
     ([CV_SEQ_ELTYPE_INDEX] (if (SCM_EXACTP ,obj)
                              ,index
                              (Scm_Error "<int> required, but got %S" ,obj)))
     ([CV_SEQ_ELTYPE_POINT3D] (if (SCM_CVPOINT3D32F_P ,obj)
                                ,point3d
                                (Scm_Error "CvPoint32Df required, but got %S" ,obj)))
     ([CV_SEQ_ELTYPE_PTR] ,user)
     (else (Scm_Error "unknown element type %d." (CV_SEQ_ELTYPE ,seq)))))

(define-cise-stmt (case-seq-type seq point seg-polar seg-point code index point3d user)
  `(case (CV_SEQ_ELTYPE ,seq)
     ([CV_SEQ_ELTYPE_POINT] ,point)
     ([CV_32FC2] ,seg-polar)
     ([CV_32SC4] ,seg-point)
     ([CV_SEQ_ELTYPE_CODE] ,code)
     ([CV_SEQ_ELTYPE_INDEX] ,index)
     ([CV_SEQ_ELTYPE_POINT3D] ,point3d)
     ([CV_SEQ_ELTYPE_PTR] ,user)
     (else (Scm_Error "unknown element type %d." (CV_SEQ_ELTYPE ,seq)))))

;;;;;
;; Adds new element to the end of sequence. 
(define-cproc cv-seq-push (seq::<cv-seq> obj) ::<void>
  (case-seq-type-set seq obj
                     (cvSeqPush seq (& (SCM_CVPOINT_DATA obj)))
                     (cvSeqPush seq (& (unboxing obj <cv-line-segment-polar>)))
                     (cvSeqPush seq (& (unboxing obj <cv-line-segment-point>)))
                     (let* ([code::u_int (Scm_GetIntegerU obj)])
                       (cvSeqPush seq (& code)))
                     (let* ([index::int (Scm_GetInteger obj)])
                       (cvSeqPush seq (& index)))
                     (cvSeqPush seq (& (SCM_CVPOINT3D32F_DATA obj)))
                     (cvSeqPush seq (& obj))))

;;;;;
;; Adds new element to the beginning of sequence. 
(define-cproc cv-seq-push-front (seq::<cv-seq> obj) ::<void>
  (case-seq-type-set seq obj
                     (cvSeqPushFront seq (& (SCM_CVPOINT_DATA obj)))
                     (cvSeqPushFront seq (& (unboxing obj <cv-line-segment-polar>)))
                     (cvSeqPush seq (& (unboxing obj <cv-line-segment-point>)))
                     (let* ([code::u_int (Scm_GetIntegerU obj)])
                       (cvSeqPushFront seq (& code)))
                     (let* ([index::int (Scm_GetInteger obj)])
                       (cvSeqPushFront seq (& index)))
                     (cvSeqPushFront seq (& (SCM_CVPOINT3D32F_DATA obj)))
                     (cvSeqPushFront seq (& obj))))

;;;;;
;; Removes the last element from sequence and optionally saves it
(define-cproc cv-seq-pop (seq::<cv-seq>) ::<top>
  (case-seq-type seq
                 (let* ([pt::CvPoint])
                   (cvSeqPop seq (& pt))
                   (result (SCM_OBJ (SCM_MAKE_CVPOINT pt))))
                 (let* ([polar::CvLineSegmentPolar])
                   (cvSeqPop seq (& polar))
                   (result (SCM_OBJ (boxing polar <cv-line-segment-polar>))))
                 (let* ([pt::CvLineSegmentPoint])
                   (cvSeqPop seq (& pt))
                   (result (SCM_OBJ (boxing pt <cv-line-segment-point>))))
                 (let* ([code::char])
                   (cvSeqPop seq (& code))
                   (result (SCM_OBJ (Scm_MakeIntegerFromUI code))))
                 (let* ([index::int])
                   (cvSeqPop seq (& index))
                   (result (SCM_OBJ (Scm_MakeInteger index))))
                 (let* ([pt::CvPoint3D32f])
                   (cvSeqPop seq (& pt))
                   (result (SCM_OBJ (SCM_MAKE_CVPOINT3D32F pt))))
                 (let* ([obj::ScmObj])
                   (cvSeqPop seq (& obj))
                   (result obj))))

;;;;;
;; Removes the first element from sequence and optioanally saves it
(define-cproc cv-seq-pop-front (seq::<cv-seq>) ::<top>
  (case-seq-type seq
                 (let* ([pt::CvPoint])
                   (cvSeqPopFront seq (& pt))
                   (result (SCM_OBJ (SCM_MAKE_CVPOINT pt))))
                 (let* ([polar::CvLineSegmentPolar])
                   (cvSeqPopFront seq (& polar))
                   (result (SCM_OBJ (boxing polar <cv-line-segment-polar>))))
                 (let* ([pt::CvLineSegmentPoint])
                   (cvSeqPopFront seq (& pt))
                   (result (SCM_OBJ (boxing pt <cv-line-segment-point>))))
                 (let* ([code::char])
                   (cvSeqPopFront seq (& code))
                   (result (SCM_OBJ (Scm_MakeIntegerFromUI code))))
                 (let* ([index::int])
                   (cvSeqPopFront seq (& index))
                   (result (SCM_OBJ (Scm_MakeInteger index))))
                 (let* ([pt::CvPoint3D32f])
                   (cvSeqPopFront seq (& pt))
                   (result (SCM_OBJ (SCM_MAKE_CVPOINT3D32F pt))))
                 (let* ([obj::ScmObj])
                   (cvSeqPopFront seq (& obj))
                   (result obj))))

;;----------------
;; Constants
;;
(define-enum CV_FRONT)
(define-enum CV_BACK)

(define-cise-stmt (seq-multi-push ary-type unboxer tmp-ary tmp-count)
  (let ([p-type (string-append (symbol->string ary-type) "*")])
    `(let* ([count::int (/ (* (sizeof _pvoid_t) ,tmp-count) (sizeof ,ary-type))]
            [ary::,p-type (?: (< count vec-size)
                              (SCM_MALLOC (* (sizeof ,ary-type) vec-size))
                              (cast ,p-type ,tmp-ary))])
       (dotimes [i vec-size] (set! (aref ary i)
                               (,unboxer (SCM_VECTOR_ELEMENT elements i))))
       (set! p-elem ary))))

"
#define TMP_ARY_SIZE 10
"
(eval-in-current-module
  (gen-elem-assign <cv-point>)
  (gen-elem-assign <cv-point-3d32f>)
  (gen-elem-assign <cv-line-segment-polar>)
  (gen-elem-assign <cv-line-segment-point>)
  (gen-elem-assign <uint8>)
  (gen-elem-assign <int>)
  )
;;;;;
;; Adds several new elements to the end of sequence
(define-cproc cv-seq-push-multi (seq::<cv-seq> elements
                                               :optional (in-front::<boolean> #f)) ::<void>
  (let* ([size::int]
         [p-elem::void*]
         [tmp-ary :: (.array void* (TMP_ARY_SIZE))])
    (cond
      [(is-type? elements <vector>)
       (set! size (SCM_VECTOR_SIZE elements))
       (case-seq-type seq
                      (vector-to-ary elements p-elem tmp-ary TMP_ARY_SIZE CvPoint <cv-point>-elem-assign)
                      (vector-to-ary elements p-elem tmp-ary TMP_ARY_SIZE CvLineSegmentPolar <cv-line-segment-polar>-elem-assign)
                      (vector-to-ary elements p-elem tmp-ary TMP_ARY_SIZE CvLineSegmentPoint <cv-line-segment-point>-elem-assign)
                      (vector-to-ary elements p-elem tmp-ary TMP_ARY_SIZE _char_t <uint8>-elem-assign)
                      (vector-to-ary elements p-elem tmp-ary TMP_ARY_SIZE _int_t <int>-elem-assign)
                      (vector-to-ary elements p-elem tmp-ary TMP_ARY_SIZE CvPoint3D32f <cv-point-3d32f>-elem-assign)
                      (vector-to-ary elements p-elem tmp-ary TMP_ARY_SIZE ScmObj <top>-elem-assign))]
      [(is-type? elements <list>)
       (case-seq-type seq
                      (list-to-ary elements p-elem tmp-ary TMP_ARY_SIZE size CvPoint <cv-point>-elem-assign)
                      (list-to-ary elements p-elem tmp-ary TMP_ARY_SIZE size CvLineSegmentPolar <cv-line-segment-polar>-elem-assign)
                      (list-to-ary elements p-elem tmp-ary TMP_ARY_SIZE size CvLineSegmentPoint <cv-line-segment-point>-elem-assign)
                      (list-to-ary elements p-elem tmp-ary TMP_ARY_SIZE size _char_t <uint8>-elem-assign)
                      (list-to-ary elements p-elem tmp-ary TMP_ARY_SIZE size _int_t <int>-elem-assign)
                      (list-to-ary elements p-elem tmp-ary TMP_ARY_SIZE size CvPoint3D32f <cv-point-3d32f>-elem-assign)
                      (list-to-ary elements p-elem tmp-ary TMP_ARY_SIZE size ScmObj <top>-elem-assign))]
      [else (Scm_Error "<list> or <vector> required, but got %S" elements)])
    (cvSeqPushMulti seq p-elem size in-front)))

(define-cise-stmt (seq-multi-pop ary-type boxer)
  (let ([p-type (string-append (symbol->string ary-type) "*")])
    `(let* ([t-ary::,p-type (cast ,p-type ary)])
       (dotimes [i count] (set! (SCM_VECTOR_ELEMENT vec i)
                            (,boxer (aref t-ary i)))))))

;;;;;
;; Removes several elements from the end of sequence and optionally saves them
(define-cproc cv-seq-pop-multi (seq::<cv-seq> count::<fixnum>
                                              :optional (in-front::<boolean> #f)) ::<vector>
  (let* ([vec::ScmVector* (cast ScmVector* (Scm_MakeVector count SCM_UNDEFINED))]
         [ary::void*])
    (case-seq-type seq
                   (set! ary (SCM_MALLOC (* (sizeof CvPoint) count)))
                   (set! ary (SCM_MALLOC (* (sizeof CvLineSegmentPolar) count)))
                   (set! ary (SCM_MALLOC (* (sizeof CvLineSegmentPoint) count)))
                   (set! ary (SCM_MALLOC (* (sizeof _char_t) count)))
                   (set! ary (SCM_MALLOC (* (sizeof _int_t) count)))
                   (set! ary (SCM_MALLOC (* (sizeof CvPoint3D32f) count)))
                   (set! ary (SCM_MALLOC (* (sizeof ScmObj) count))))
    (cvSeqPopMulti seq ary count in-front)
    (case-seq-type seq
                   (seq-multi-pop CvPoint SCM_MAKE_CVPOINT)
                   (seq-multi-pop CvLineSegmentPolar SCM_MAKE_CVLINESEGMENTPOLAR)
                   (seq-multi-pop CvLineSegmentPoint SCM_MAKE_CVLINESEGMENTPOINT)
                   (seq-multi-pop _char_t Scm_MakeIntegerFromUI)
                   (seq-multi-pop _int_t Scm_MakeInteger)
                   (seq-multi-pop CvPoint3D32f SCM_MAKE_CVPOINT3D32F)
                   (seq-multi-pop ScmObj SCM_OBJ))
    (result vec)))

;;;;;
;; Inserts a new element in the middle of sequence.
;; (cv-seq-insert seq 0 elem) == (cv-seq-push-front seq elem)
(define-cproc cv-seq-insert (seq::<cv-seq> before-index::<fixnum> obj) ::<void>
  (case-seq-type-set seq obj
                     (cvSeqInsert seq before-index (& (SCM_CVPOINT_DATA obj)))
                     (cvSeqInsert seq before-index (& (unboxing obj <cv-line-segment-polar>)))
                     (cvSeqInsert seq before-index (& (unboxing obj <cv-line-segment-point>)))
                     (let* ([code::u_int (Scm_GetIntegerU obj)])
                       (cvSeqInsert seq before-index (& code)))
                     (let* ([index::int (Scm_GetInteger obj)])
                       (cvSeqInsert seq before-index (& index)))
                     (cvSeqInsert seq before-index (& (SCM_CVPOINT3D32F_DATA obj)))
                     (cvSeqInsert seq before-index (& obj))))

;;;;;
;; Removes specified sequence element
(define-cproc cv-seq-remove (seq::<cv-seq> index::<fixnum>) ::<void>
  (cvSeqRemove seq index))

;;;;;
;; Removes all the elements from the sequence. The freed memory
;; can be reused later only by the same sequence unless cv-clear-mem-storage
;; or cv-restore-mem-sotrage-pos is called
(define-cproc cv-clear-seq (seq::<cv-seq>) ::<void>
  (cvClearSeq seq))

;;;;;
;; Retrieves pointer to specified sequence element.
;; @param index
;; Negative indices are supported and mean counting from the end
;; (e.g -1 means the last sequence element)
(define-cproc cv-get-seq-elem (seq::<cv-seq> index::<fixnum>) ::<top>
  (case-seq-type seq
                 (let* ([pt::CvPoint* (CV_GET_SEQ_ELEM CvPoint seq index)])
                   (result (SCM_OBJ (SCM_MAKE_CVPOINT (* pt)))))
                 (let* ([polar::CvLineSegmentPolar* (CV_GET_SEQ_ELEM CvLineSegmentPolar seq index)])
                   (result (SCM_OBJ (boxing (* polar) <cv-line-segment-polar>))))
                 (let* ([pt::CvLineSegmentPoint* (CV_GET_SEQ_ELEM CvLineSegmentPoint seq index)])
                   (result (SCM_OBJ (boxing (* pt) <cv-line-segment-point>))))
                 (let* ([code::char (* (CV_GET_SEQ_ELEM _char_t seq index))])
                   (result (SCM_OBJ (Scm_MakeIntegerFromUI code))))
                 (let* ([ind::int (* (CV_GET_SEQ_ELEM _int_t seq index))])
                   (result (SCM_OBJ (Scm_MakeInteger ind))))
                 (let* ([pt::CvPoint3D32f* (CV_GET_SEQ_ELEM CvPoint3D32f seq index)])
                   (result (SCM_OBJ (SCM_MAKE_CVPOINT3D32F (* pt)))))
                 (result (SCM_OBJ (CV_GET_SEQ_ELEM _pvoid_t seq index)))))

"
#define def_byte_struct(num) \
  typedef struct { char v[num]; }struct_##num##Byte; \
  typedef struct { SCM_HEADER; struct_##num##Byte v; }obj_##num##Byte;
def_byte_struct(4)
def_byte_struct(8)
def_byte_struct(12)
def_byte_struct(16)
def_byte_struct(20)
def_byte_struct(24)
def_byte_struct(28)
def_byte_struct(32)
def_byte_struct(36)
def_byte_struct(40)
def_byte_struct(44)
def_byte_struct(48)
def_byte_struct(52)
def_byte_struct(56)
def_byte_struct(60)
"
(define-cise-stmt (elem-size-cast byte src-setter)
  `(begin
     (,src-setter src ,(string->symbol (string-append "struct_" byte)))
     (set! obj (SCM_OBJ (SCM_NEW ,(string->symbol (string-append "obj_" byte)))))
     (set! dst (& (-> (cast ,(string->symbol (string-append "obj_" byte "*")) obj) v)))))

(define-cise-stmt (object-cast to-class elem-size src-setter)
  `(if (Scm_SubtypeP ,to-class SCM_CLASS_CVOBJECT)
     (let* ([obj::ScmCvObject* (SCM_NEW ScmCvObject)])
       (case ,elem-size
         [(4) (,src-setter (@ obj->data) struct_4Byte)]
         [(8) (,src-setter (@ obj->data) struct_8Byte)]
         [(12) (,src-setter (@ obj->data) struct_12Byte)]
         [(16) (,src-setter (@ obj->data) struct_16Byte)]
         [(20) (,src-setter (@ obj->data) struct_20Byte)]
         [(24) (,src-setter (@ obj->data) struct_24Byte)]
         [(28) (,src-setter (@ obj->data) struct_28Byte)]
         [(32) (,src-setter (@ obj->data) struct_32Byte)]
         [(36) (,src-setter (@ obj->data) struct_36Byte)]
         [(40) (,src-setter (@ obj->data) struct_40Byte)]
         [(44) (,src-setter (@ obj->data) struct_44Byte)]
         [(48) (,src-setter (@ obj->data) struct_48Byte)]
         [(52) (,src-setter (@ obj->data) struct_52Byte)]
         [(58) (,src-setter (@ obj->data) struct_56Byte)]
         [(60) (,src-setter (@ obj->data) struct_60Byte)]
         [else (Scm_Error "Can't be cast object")])
       (SCM_SET_CLASS obj ,to-class)
       (return (SCM_OBJ obj)))
     (let* ([obj::ScmObj]
            [src::_pvoid_t]
            [dst::_pvoid_t])
       (case ,elem-size
         [(4) (elem-size-cast "4Byte" ,src-setter)]
         [(8) (elem-size-cast "8Byte" ,src-setter)]
         [(12) (elem-size-cast "12Byte" ,src-setter)]
         [(16) (elem-size-cast "16Byte" ,src-setter)]
         [(20) (elem-size-cast "20Byte" ,src-setter)]
         [(24) (elem-size-cast "24Byte" ,src-setter)]
         [(28) (elem-size-cast "28Byte" ,src-setter)]
         [(32) (elem-size-cast "32Byte" ,src-setter)]
         [(36) (elem-size-cast "36Byte" ,src-setter)]
         [(40) (elem-size-cast "40Byte" ,src-setter)]
         [(44) (elem-size-cast "44Byte" ,src-setter)]
         [(48) (elem-size-cast "48Byte" ,src-setter)]
         [(52) (elem-size-cast "52Byte" ,src-setter)]
         [(56) (elem-size-cast "56Byte" ,src-setter)]
         [(60) (elem-size-cast "60Byte" ,src-setter)]
         [else (Scm_Error "Can't be cast object")])
       (memcpy dst src ,elem-size)
       (SCM_SET_CLASS obj ,to-class)
       (return obj))))

(define-cise-stmt (cv-get-seq-elem-setter src type)
  `(set! ,src (CV_GET_SEQ_ELEM ,type seq index)))

(define-cproc cv-get-seq-elem-cast (to-class::<class> seq::<cv-seq> index::<fixnum>)::<top>
  (object-cast to-class (@ seq->elem_size) cv-get-seq-elem-setter))

;;;;;
;; Calculates index of the specified sequence element.
;; Returns -1 if element does not belong to the sequence
(define-cproc cv-seq-elem-idx (seq::<cv-seq> obj) ::(<fixnum> <cv-seq-block>)
  (let* ([block::CvSeqBlock* (SCM_MALLOC (sizeof block))])
    (case-seq-type-set seq obj
                       (result (cvSeqElemIdx seq (& (SCM_CVPOINT_DATA obj)) (& block))
                               block)
                       (result (cvSeqElemIdx seq (& (unboxing obj <cv-line-segment-polar>)) (& block))
                               block)
                       (result (cvSeqElemIdx seq (& (unboxing obj <cv-line-segment-point>)) (& block))
                               block)
                       (let* ([code::u_int (Scm_GetIntegerU obj)])
                         (result (cvSeqElemIdx seq (& code) (& block))
                                 block))

                       (let* ([index::int (Scm_GetInteger obj)])
                         (result (cvSeqElemIdx seq (& index) (& block))
                                 block))
                       (result (cvSeqElemIdx seq (& (SCM_CVPOINT3D32F_DATA obj)) (& block))
                               block)
                       (result (cvSeqElemIdx seq (& obj) (& block))
                               block))))

;;;;;
;; Initializes sequence writer. The new elements will be added to the end of sequence
(define-cproc cv-start-append-to-seq (seq::<cv-seq>) ::<cv-seq-writer>
  (let* ([writer::CvSeqWriter* (SCM_MALLOC (sizeof writer))])
    (cvStartAppendToSeq seq writer)
    (result writer)))

;;not support cvStartWriteSeq

;;;;;
;; Closes sequence writer, updates sequence header and returns pointer to the resultant sequence
;; (which may be useful if the sequence was created using cv-start-write-seq))
(define-cproc cv-end-write-seq (writer::<cv-seq-writer>) ::<cv-seq>
  (result (cvEndWriteSeq writer)))

;;;;;
;; Updates sequence header. May be useful to get access to some of previously
;; written elements via cv-get-seq-elem or sequence reader
(define-cproc cv-flush-seq-writer (writer::<cv-seq-writer>) ::<void>
  (cvFlushSeqWriter writer))

;;;;;
;; Add element to sequence
(define-cproc cv-write-seq-elem (elem-obj writer::<cv-seq-writer>) ::<void>
  (case-seq-type-set (-> writer seq) elem-obj
                     (CV_WRITE_SEQ_ELEM (SCM_CVPOINT_DATA elem-obj) (* writer))
                     (CV_WRITE_SEQ_ELEM (unboxing elem-obj <cv-line-segment-polar>) (* writer))
                     (CV_WRITE_SEQ_ELEM (unboxing elem-obj <cv-line-segment-point>) (* writer))
                     (let* ([code::u_int (Scm_GetIntegerU elem-obj)])
                       (CV_WRITE_SEQ_ELEM code (* writer)))
                     (let* ([index::int (Scm_GetInteger elem-obj)])
                       (CV_WRITE_SEQ_ELEM index (* writer)))
                     (CV_WRITE_SEQ_ELEM (SCM_CVPOINT3D32F_DATA elem-obj) (* writer))
                     (CV_WRITE_SEQ_ELEM elem-obj (* writer))))

;;;;;
;; Initializes sequence reader.
;; The sequence can be read in forward or backward direction
(define-cproc cv-start-read-seq (seq::<cv-seq>
                                  :optional (reverse::<boolean> #f)) ::<cv-seq-reader>
  (let* ([reader::CvSeqReader* (SCM_NEW CvSeqReader)])
    (cvStartReadSeq seq reader reverse)
    (result reader)))

;;;;;
;; Returns current sequence reader position (currently observed sequence element)
(define-cproc cv-get-seq-reader-pos (reader::<cv-seq-reader>) ::<fixnum>
  (result (cvGetSeqReaderPos reader)))

;;;;;
;; Changes sequence reader position. It may seek to an absolute or
;; to relative to the current position
(define-cproc cv-set-seq-reader-pos (reader::<cv-seq-reader> index::<fixnum>
                                                             :optional (relative?::<boolean> #f)) ::<void>
  (cvSetSeqReaderPos reader index relative?))

;;;;;
;; Move reader position forward
(define-cproc cv-next-seq-elem (reader::<cv-seq-reader>) ::<void>
  (CV_NEXT_SEQ_ELEM (-> (-> reader seq) elem_size) (* reader)))

;;;;;
;; Move reader position backward
(define-cproc cv-prev-seq-elem (reader::<cv-seq-reader>) ::<void>
  (CV_PREV_SEQ_ELEM (-> (-> reader seq) elem_size) (* reader)))

;;TODO !!!!! cast

;;;;;
;; Read element and move read position forward
(define-cproc cv-read-seq-elem (reader::<cv-seq-reader>) ::<top>
  (case-seq-type (-> reader seq)
                 (let* ([pt::CvPoint])
                   (CV_READ_SEQ_ELEM pt (* reader))
                   (result (SCM_MAKE_CVPOINT pt)))
                 (let* ([v::CvLineSegmentPolar])
                   (CV_READ_SEQ_ELEM v (* reader))
                   (result (boxing v <cv-line-segment-polar>)))
                 (let* ([v::CvLineSegmentPoint])
                   (CV_READ_SEQ_ELEM v (* reader))
                   (result (boxing v <cv-line-segment-point>)))
                 (let* ([code::u_int])
                   (CV_READ_SEQ_ELEM code (* reader))
                   (result (Scm_MakeIntegerFromUI code)))
                 (let* ([index::int])
                   (CV_READ_SEQ_ELEM index (* reader))
                   (result (Scm_MakeInteger index)))
                 (let* ([pt::CvPoint3D32f])
                   (CV_READ_SEQ_ELEM pt (* reader))
                   (result (SCM_MAKE_CVPOINT3D32F pt)))
                 (let* ([obj::ScmObj])
                   (CV_READ_SEQ_ELEM obj (* reader))
                   (result obj))))

;;gauche-cv original function
(define-cproc cv-ref-seq-elem (reader::<cv-seq-reader>) ::<top>
  (case-seq-type (-> reader seq)
                 (result (SCM_MAKE_CVPOINT (* (cast CvPoint* (-> reader ptr)))))
                 (result (boxing (* (cast CvLineSegmentPolar* (-> reader ptr))) <cv-line-segment-polar>))
                 (result (boxing (* (cast CvLineSegmentPoint* (-> reader ptr))) <cv-line-segment-point>))
                 (result (Scm_MakeIntegerFromUI (* (cast u_int* (-> reader ptr)))))
                 (result (Scm_MakeInteger (* (cast int* (-> reader ptr)))))
                 (result (SCM_MAKE_CVPOINT3D32F (* (cast CvPoint3D32f* (-> reader ptr)))))
                 (result (* (cast ScmObj* (-> reader ptr))))))

;;;;;
;; Read element and move read position backward
(define-cproc cv-rev-read-seq-elem (reader::<cv-seq-reader>) ::<top>
  (case-seq-type (-> reader seq)
                 (let* ([pt::CvPoint])
                   (CV_REV_READ_SEQ_ELEM pt (* reader))
                   (result (SCM_MAKE_CVPOINT pt)))
                 (let* ([polar::CvLineSegmentPolar])
                   (CV_REV_READ_SEQ_ELEM polar (* reader))
                   (result (boxing polar <cv-line-segment-polar>)))
                 (let* ([pt::CvLineSegmentPoint])
                   (CV_REV_READ_SEQ_ELEM pt (* reader))
                   (result (boxing pt <cv-line-segment-point>)))
                 (let* ([code::u_int])
                   (CV_REV_READ_SEQ_ELEM code (* reader))
                   (result (Scm_MakeIntegerFromUI code)))
                 (let* ([index::int])
                   (CV_REV_READ_SEQ_ELEM index (* reader))
                   (result (Scm_MakeInteger index)))
                 (let* ([pt::CvPoint3D32f])
                   (CV_REV_READ_SEQ_ELEM pt (* reader))
                   (result (SCM_MAKE_CVPOINT3D32F pt)))
                 (let* ([obj::ScmObj])
                   (CV_REV_READ_SEQ_ELEM obj (* reader))
                   (result obj))))

(define-cise-stmt (to-uvector to-class reader)
  (let ([vec (gensym "vec_")])
    `(let* ([,vec :: ScmObj])
       (cond
         [(eq? ,to-class (& Scm_S8VectorClass))
          (set! ,vec (Scm_MakeS8VectorFromArrayShared 
                       (@ reader->seq->elem-size)
                       (cast (signed char*) (-> ,reader ptr))))]
         [(eq? ,to-class (& Scm_U8VectorClass))
          (set! ,vec (Scm_MakeU8VectorFromArrayShared 
                       (@ reader->seq->elem-size)
                       (cast (unsigned char*) (-> ,reader ptr))))]
         [(eq? ,to-class (& Scm_S16VectorClass))
          (set! ,vec (Scm_MakeS16VectorFromArrayShared 
                       (/ (@ reader->seq->elem-size) 2)
                       (cast (signed short*) (-> ,reader ptr))))]
         [(eq? ,to-class (& Scm_U16VectorClass))
          (set! ,vec (Scm_MakeU16VectorFromArrayShared 
                       (/ (@ reader->seq->elem-size) 2)
                       (cast (unsigned short*) (-> ,reader ptr))))]
         [(eq? ,to-class (& Scm_S32VectorClass))
          (set! ,vec (Scm_MakeS32VectorFromArrayShared 
                       (/ (@ reader->seq->elem-size) 4)
                       (cast ScmInt32* (-> ,reader ptr))))]
         [(eq? ,to-class (& Scm_U32VectorClass))
          (set! ,vec (Scm_MakeU32VectorFromArrayShared 
                       (/ (@ reader->seq->elem-size) 4)
                       (cast ScmUInt32* (-> ,reader ptr))))]
         [(eq? ,to-class (& Scm_S64VectorClass))
          (set! ,vec (Scm_MakeS64VectorFromArrayShared 
                       (/ (@ reader->seq->elem-size) 8)
                       (cast ScmInt64* (-> ,reader ptr))))]
         [(eq? ,to-class (& Scm_U64VectorClass))
          (set! ,vec (Scm_MakeU64VectorFromArrayShared 
                       (/ (@ reader->seq->elem-size) 8)
                       (cast ScmUInt64* (-> ,reader ptr))))]
         [(eq? ,to-class (& Scm_F16VectorClass))
          (set! ,vec (Scm_MakeF16VectorFromArrayShared 
                       (/ (@ reader->seq->elem-size) 2)
                       (cast ScmHalfFloat* (-> ,reader ptr))))]
         [(eq? ,to-class (& Scm_F32VectorClass))
          (set! ,vec (Scm_MakeF32VectorFromArrayShared 
                       (/ (@ reader->seq->elem-size) 4)
                       (cast float* (-> ,reader ptr))))]
         [(eq? ,to-class (& Scm_F64VectorClass))
          (set! ,vec (Scm_MakeF64VectorFromArrayShared 
                       (/ (@ reader->seq->elem-size) 4)
                       (cast double* (-> ,reader ptr))))]
         [else (Scm_Error "Can't be cast class")])
       (result (SCM_OBJ ,vec)))))

(define-cise-stmt (cv-read-seq-elem-setter src type)
  `(begin
     (set! ,src (@ reader->ptr))
     (CV_NEXT_SEQ_ELEM (sizeof ,type) (* reader))))

(define-cproc cv-read-seq-elem-cast (to-class::<class> reader::<cv-seq-reader>) ::<top>
  (if (Scm_SubtypeP to-class SCM_CLASS_UVECTOR)
    (begin
      (to-uvector to-class reader)
      (CV_NEXT_SEQ_ELEM (@ reader->seq->elem-size) (* reader)))
    (object-cast to-class (@ reader->seq->elem_size) cv-read-seq-elem-setter)))

(define-cise-stmt (cv-ref-seq-elem-setter src type)
  `(set! ,src (@ reader->ptr)))

(define-cproc cv-ref-seq-elem-cast (to-class::<class> reader::<cv-seq-reader>) ::<top>
  (if (Scm_SubtypeP to-class SCM_CLASS_UVECTOR)
    (to-uvector to-class reader) 
  (object-cast to-class (@ reader->seq->elem_size) cv-ref-seq-elem-setter)))

(define-cise-stmt (cv-rev-read-seq-elem-setter src type)
  `(begin
     (set! ,src (@ reader->ptr))
     (CV_PREV_SEQ_ELEM (sizeof ,type) (* reader))))

(define-cproc cv-rev-read-seq-elem-cast (to-class::<class> reader::<cv-seq-reader>) ::<top>
  (if (Scm_SubtypeP to-class SCM_CLASS_UVECTOR)
    (begin
      (to-uvector to-class reader) 
      (CV_PREV_SEQ_ELEM (@ reader->seq->elem-size) (* reader)))
  (object-cast to-class (@ reader->seq->elem_size) cv-rev-read-seq-elem-setter)))

;;not support
;;CV_READ_CHAIN_POINT
;;CV_CURRENT_POINT
;;CV_PREV_POINT
;;CV_READ_EDGE


;;TODO cvCvtSeqToArray
;;;;;
;;  Set.
;;  Order is not preserved. There can be gaps between sequence elements.
;;  After the element has been inserted it stays in the same place all the time.
;;  The MSB(most-significant or sign bit) of the first field (flags) is 0 iff the element exists.
(define-cclass <cv-set>
  :built-in
  "ScmCvSet*" "Scm_CvSetClass"
  ("Scm_CvSeqClass" "Scm_CvTreeNodeClass" "Scm_CvObjectClass")
  (;;slot
   (active-count :type <fixnum>
                 :setter #f
                 :c-name "active_count")
   ))

(define-cproc cv-is-set-elem? (elem::<cv-set-elem>) :: <boolean>
  (result (CV_IS_SET_ELEM elem)))
  

;;;;;
;;  We represent a graph as a set of vertices.
;;  Vertices contain their adjacency lists (more exactly, pointers to first incoming or
;;  outcoming edge (or 0 if isolated vertex)). Edges are stored in another set.
;;  There is a singly-linked list of incoming/outcoming edges for each vertex.
;;
;;  Each edge consists of
;;
;;     o   Two pointers to the starting and ending vertices
;;         (vtx[0] and vtx[1] respectively).
;;
;;	 A graph may be oriented or not. In the latter case, edges between
;;	 vertex i to vertex j are not distinguished during search operations.
;;
;;     o   Two pointers to next edges for the starting and ending vertices, where
;;         next[0] points to the next edge in the vtx[0] adjacency list and
;;         next[1] points to the next edge in the vtx[1] adjacency list.
(define-cclass <cv-graph>
  :built-in
  "ScmCvGraph*" "Scm_CvGraphClass"
  ("Scm_CvSetClass" "Scm_CvSeqClass" "Scm_CvTreeNodeClass" "Scm_CvObjectClass")
  (;;slot
   (edges :type <cv-set>
          :setter #f)
   ))

(define-cclass <cv-chain>
  :built-in
  "ScmCvChain*" "Scm_CvChainClass"
  ("Scm_CvSeqClass" "Scm_CvTreeNodeClass" "Scm_CvObjectClass")
  (;;slot
   (origin :type <cv-point>
           :setter #f)
   ))

(define-cclass <cv-contour>
  :built-in
  "ScmCvContour*" "Scm_CvContourClass"
  ("Scm_CvSeqClass" "Scm_CvTreeNodeClass" "Scm_CvObjectClass")
  (;;slot
   (rect	:type <cv-rect>
                :setter #f)
   (color :type <fixnum>
          :setter #f)
   ))


;;--------------
;; CvArr
;;

;;;;;
;; @return Returns type of array elements:
;; CV_8UC1 ... CV_64FC4 ...
(define-cproc cv-get-elemtype (arr::<cv-arr>) ::<int>
  (ENSURE_NOT_NULL arr)
  (result (cvGetElemType arr)))

;;;;;
;; Retrieves number of an array dimensions and
;; optionally sizes of the dimensions
(define-cproc cv-get-dims (arr::<cv-arr>)::<s32vector>
  (ENSURE_NOT_NULL arr)
  (let* ([sizes :: (.array int (CV_MAX_DIM))]
         [dims :: int (cvGetDims arr sizes)]
         [vec :: ScmUVector* (SCM_S32VECTOR (Scm_MakeS32Vector dims 0))])
    (dotimes [i dims]
      (set! (SCM_S32VECTOR_ELEMENT vec i) (aref sizes i)))
    (result vec)))

;;;;;
;; Retrieves size of a particular array dimension.
;; For 2d arrays cv-get-dimsize arr 0) returns number of rows (image height)
;; and (cv-get-dimsize arr 1) returns number of columns (image width) */
(define-cproc cv-get-dimsize (arr::<cv-arr> index::<fixnum>)::<int>
  (ENSURE_NOT_NULL arr)
  (result (cvGetDimSize arr index)))

;;;;;
;; value = arr(idx0)
(define-cproc cv-get-1d (arr::<cv-arr> idx0::<int>)::<cv-scalar>
  (ENSURE_NOT_NULL arr)
  (result (cvGet1D arr idx0)))

;;;;;
;; value = arr(idx0, idx1)
(define-cproc cv-get-2d (arr::<cv-arr> idx0::<fixnum> idx1::<fixnum>)::<cv-scalar>
  (ENSURE_NOT_NULL arr)
  (result (cvGet2D arr idx0 idx1)))

;;;;;
;; value = arr(idx0, idx1, idx2)
(define-cproc cv-get-3d (arr::<cv-arr> idx0::<fixnum> idx1::<fixnum> idx2::<fixnum>)::<cv-scalar>
  (ENSURE_NOT_NULL arr)
  (result (cvGet3D arr idx0 idx1 idx2)))

;;;;;
;; value = arr(idx0, ...)
(define-cproc cv-get-nd (arr::<cv-arr> idx::<s32vector>)::<cv-scalar>
  (ENSURE_NOT_NULL arr)
  (result (cvGetND arr (SCM_S32VECTOR_ELEMENTS idx))))

;;;;;
;; for 1-channel arrays
(define-cproc cv-get-real1d (arr::<cv-arr> idx0::<int>)::<double>
  (ENSURE_NOT_NULL arr)
  (result (cvGetReal1D arr idx0)))

;;;;;
;; for 1-channel arrays
(define-cproc cv-get-real2d (arr::<cv-arr> idx0::<fixnum> idx1::<fixnum>)::<double>
  (ENSURE_NOT_NULL arr)
  (result (cvGetReal2D arr idx0 idx1)))

;;;;;
;; for 1-channel arrays
(define-cproc cv-get-real3d (arr::<cv-arr> idx0::<fixnum> idx1::<fixnum> idx2::<fixnum>)::<double>
  (ENSURE_NOT_NULL arr)
  (result (cvGetReal3D arr idx0 idx1 idx2)))

;;;;;
;; for 1-channel arrays
(define-cproc cv-get-realnd (arr::<cv-arr> idx::<s32vector>)::<double>
  (ENSURE_NOT_NULL arr)
  (result (cvGetRealND arr (SCM_S32VECTOR_ELEMENTS idx))))

;;;;;
;; arr(idx0) = value
(define-cproc cv-set-1d (arr::<cv-arr> idx0::<int> value::<cv-scalar>)::<void>
  (ENSURE_NOT_NULL arr)
  (cvSet1D arr idx0 value))

;;;;;
;; arr(idx0, idx1) = value
(define-cproc cv-set-2d (arr::<cv-arr> idx0::<fixnum> idx1::<fixnum> value::<cv-scalar>)::<void>
  (ENSURE_NOT_NULL arr)
  (cvSet2D arr idx0 idx1 value))


;;;;;
;; arr(idx0, idx1, idx2) = value
(define-cproc cv-set-3d (arr::<cv-arr> idx0::<fixnum> idx1::<fixnum> idx2::<fixnum> value::<cv-scalar>)::<void>
  (ENSURE_NOT_NULL arr)
  (cvSet3D arr idx0 idx1 idx2 value))

;;;;;
;; arr(idx0 ...) = value
(define-cproc cv-set-nd (arr::<cv-arr> idx::<s32vector> value::<cv-scalar>)::<void>
  (ENSURE_NOT_NULL arr)
  (cvSetND arr (SCM_S32VECTOR_ELEMENTS idx) value))

;;;;;
;; for 1-channel arrays
(define-cproc cv-set-real1d (arr::<cv-arr> idx0::<int> value::<double>)::<void>
  (ENSURE_NOT_NULL arr)
  (cvSetReal1D arr idx0 value))

;;;;;
;; for 1-channel arrays
(define-cproc cv-set-real2d (arr::<cv-arr> idx0::<fixnum> idx1::<fixnum> value::<double>)::<void>
  (ENSURE_NOT_NULL arr)
  (cvSetReal2D arr idx0 idx1 value))

;;;;;
;; for 1-channel arrays
(define-cproc cv-set-real3d (arr::<cv-arr> idx0::<fixnum> idx1::<fixnum> idx2::<fixnum> value::<double>)::<void>
  (ENSURE_NOT_NULL arr)
  (cvSetReal3D arr idx0 idx1 idx2 value))

;;;;;
;; for 1-channel arrays
(define-cproc cv-set-realnd (arr::<cv-arr> idx::<s32vector> value::<double>)::<void>
  (ENSURE_NOT_NULL arr)
  (cvSetRealND arr (SCM_S32VECTOR_ELEMENTS idx) value))

;;;;;
;; clears element of ND dense array,
;; in case of sparse arrays it deletes the specified node
(define-cproc cv-clear-nd(arr::<cv-arr> idx::<s32vector>) ::<void>
  (ENSURE_NOT_NULL arr)
  (cvClearND arr (SCM_S32VECTOR_ELEMENTS idx)))

;;;;;
;; Converts <cv-arr> (<iplimage> or <cv-mat>,...) to <cv-mat>.
;; If the last parameter is non-zero, function can
;; convert multi(>2)-dimensional array to <cv-mat> as long as.
;; the last array's dimension is continous. The resultant
;; matrix will be have appropriate (a huge) number of rows */
(define-cproc cv-get-mat(arr::<cv-arr> :optional (allow-nd::<boolean> #f)) ::<cv-mat>
  (ENSURE_NOT_NULL arr)
  (let* ([tmp::CvMat* (?: (is-type? arr_scm <cv-mat>)
                        NULL
                        (cvCreateMatHeader 1 1 CV_8UC1))])
    (result (cvGetMat arr tmp NULL allow-nd))))

;;;;;
;; Converts <cv-arr> (<iplimage> or <cv-mat>) to <iplimage>
(define-cproc cv-get-image(arr::<cv-arr>) ::<iplimage>
  (ENSURE_NOT_NULL arr)
  (let* ([tmp::IplImage* (cvCreateImageHeader (cvSize 1 1) IPL_DEPTH_8U 1)])
    (result (cvGetImage arr tmp))))

;;;;;
;; Changes a shape of multi-dimensional array.
;; new_cn == 0 means that number of channels remains unchanged.
;; new_dims == 0 means that number and sizes of dimensions remain the same
;; (unless they need to be changed to set the new number of channels)
;; if new_dims == 1, there is no need to specify new dimension sizes
;; The resultant configuration should be achievable w/o data copying.
;; If the resultant array is sparse, <cv-sparse-mat> header should be passed
;; to the function else if the result is 1 or 2 dimensional,
;; <cv-mat> header should be passed to the function
;; else <cv-matnd> header should be passed
(define-cproc cv-reshape-mat-nd(arr::<cv-arr> new-cn::<fixnum> new-dims::<s32vector>) ::<top>
  (ENSURE_NOT_NULL arr)
  (let* ([size::int (?: (== 0 (SCM_S32VECTOR_SIZE new-dims)) 
                        0 
                        (- (SCM_S32VECTOR_SIZE new-dims) 1))]
         [ret::ScmObj])
    (cond
      [(CV_IS_IMAGE_HDR arr) 
       (let* ([tmp::IplImage* (cvCreateImageHeader (cvSize 1 1) IPL_DEPTH_8U 1)])
         (set! ret (boxing (cvReshapeMatND arr (sizeof (* tmp)) tmp 
                                           new-cn size (SCM_S32VECTOR_ELEMENTS new-dims))
                           <iplimage>)))]
      [(CV_IS_MAT_HDR arr)
       (let* ([tmp::CvMat* (cvCreateMatHeader 1 1 CV_8UC1)])
         (set! ret (boxing (cvReshapeMatND arr (sizeof (* tmp)) tmp 
                                           new-cn size (SCM_S32VECTOR_ELEMENTS new-dims))
                           <cv-mat>)))]
      [(CV_IS_MATND_HDR arr)
       (let* ([sizes::(.array int (1))]
              [tmp::CvMatND*])
         (set! (aref sizes 0) 1)
         (set! tmp (cvCreateMatNDHeader 1 sizes CV_8UC1))
         (set! ret (boxing (cvReshapeMatND arr (sizeof (* tmp)) tmp 
                                                     new-cn size (SCM_S32VECTOR_ELEMENTS new-dims))
                                     <cv-matnd>)))]
      [else (Scm_Error "<iplimage> or <cv-mat> or <cv-matnd> required, but got %S" arr)])
    (result ret)))

;;;;;
;; Changes a shape of multi-dimensional array.
;; new_cn == 0 means that number of channels remains unchanged.
;; new_dims == 0 means that number and sizes of dimensions remain the same
;; (unless they need to be changed to set the new number of channels)
;; if new_dims == 1, there is no need to specify new dimension sizes
;; The resultant configuration should be achievable w/o data copying.
;; If the resultant array is sparse, <cv-sparse-mat> header should be passed
;; to the function else if the result is 1 or 2 dimensional,
;; <cv-mat> header should be passed to the function
;; else <cv-matnd> header should be passed
(define-cproc cv-reshape (arr::<cv-arr> new-cn::<fixnum> :optional (new_rows::<fixnum> 0)) ::<cv-mat>
  (ENSURE_NOT_NULL arr)
  (let* ([tmp::CvMat* (cvCreateMatHeader 1 1 CV_8UC1)])
    (result (cvReshape arr tmp new-cn new-rows))))

;;;;;
;; Repeats source 2d array several times in both horizontal and
;; vertical direction to fill destination array
(define-cproc cv-repeat (src::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvRepeat src dst))

;;TODO use nnvector
;;;;;
;; Attaches user data to the array header. The step is reffered to
;; the pre-last dimension. That is, all the planes of the array
;; must be joint (w/o gaps)
(define-cproc cv-set-data (arr::<cv-arr> data::<uvector> step::<int>) ::<void>
  (ENSURE_NOT_NULL arr)
  (cvSetData arr (SCM_UVECTOR_ELEMENTS data) step))

;;;;;
;; Returns width and height of array in elements
(define-cproc cv-get-size (arr::<cv-arr>) ::<cv-size>
  (ENSURE_NOT_NULL arr)
  (result (cvGetSize arr)))

;;;;;
;; Copies source array to destination array
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-copy (src::<cv-arr> dst::<cv-arr> :optional (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvCopy src dst mask-arr)))

;;;;;
;; Sets all or "masked" elements of input array to the same value
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-set (src::<cv-arr> value::<cv-scalar> :optional (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvSet src value mask-arr)))

;;;;;
;; Clears all the array elements (sets them to 0)
(define-cproc cv-set-zero (src::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src)
  (cvSetZero src))

;;;;;
;; Clears all the array elements (sets them to 0)
(define-cproc cv-zero (src::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src)
  (cvZero src))

;;;;;
;; Merges a set of single-channel arrays into the single multi-channel array
;; or inserts one particular [color] plane to the array
;;@param dst0 {@ <cv-arr> c:null}
;;@param dst1 {@ <cv-arr> c:null}
;;@param dst2 {@ <cv-arr> c:null}
;;@param dst3 {@ <cv-arr> c:null}
(define-cproc cv-split (src::<cv-arr> dst0 dst1 dst2 dst3) ::<void>
  (ENSURE_NOT_NULL src)
  (let* ([dst0-arr::CvArr*]
         [dst1-arr::CvArr*]
         [dst2-arr::CvArr*]
         [dst3-arr::CvArr*])
    (undef-or-cvarr dst0 dst0-arr)
    (undef-or-cvarr dst1 dst1-arr)
    (undef-or-cvarr dst2 dst2-arr)
    (undef-or-cvarr dst3 dst3-arr)
    (cvSplit src dst0-arr dst1-arr dst2-arr dst3-arr)))

;;;;;
;; Merges a set of single-channel arrays into the single multi-channel array
;; or inserts one particular [color] plane to the array
;;@param src0 {@ <cv-arr> c:null}
;;@param src1 {@ <cv-arr> c:null}
;;@param src2 {@ <cv-arr> c:null}
;;@param src3 {@ <cv-arr> c:null}
(define-cproc cv-merge (src0 src1 src2 src3 dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL dst)
  (let* ([src0-arr::CvArr*]
         [src1-arr::CvArr*]
         [src2-arr::CvArr*]
         [src3-arr::CvArr*])
    (undef-or-cvarr src0 src0-arr)
    (undef-or-cvarr src1 src1-arr)
    (undef-or-cvarr src2 src2-arr)
    (undef-or-cvarr src3 src3-arr)
    (cvMerge src0-arr src1-arr src2-arr src3-arr dst)))

(define-cise-stmt (<cv-arr>-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<cv-arr>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (begin
         (set! ,var (,(string->symbol (~ type 'unboxer)) ,obj))
         (ENSURE_NOT_NULL ,var))
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

;;;;;
;; Copies several channels from input arrays to
;; certain channels of output arrays
;;@param src {@ <cv-arr>  <list> <vector> }
;;@param dst {@ <cv-arr>  <list> <vector> }
;;@param from-to {@ <s32vector>  <list> <vector> }
(define-cproc cv-mix-channels (src dst from-to) ::<void>
  (let* ([src-cnt::int]
         [src-arr::CvArr**]
         [src-tmp-ary::(.array void* (TMP_ARY_SIZE))]
         [dst-cnt::int]
         [dst-arr::CvArr**]
         [dst-tmp-ary::(.array void* (TMP_ARY_SIZE))]
         [from-to-cnt::int]
         [from-to-arr::int*]
         [from-to-tmp-ary::(.array void* (TMP_ARY_SIZE))])
    (cond ;src
      [(is-type? src <vector>)
       (set! src-cnt (SCM_VECTOR_SIZE src))
       (vector-to-ary src src-arr src-tmp-ary TMP_ARY_SIZE CvArr* <cv-arr>-elem-assign)]
      [(is-type? src <list>)
       (list-to-ary src src-arr src-tmp-ary TMP_ARY_SIZE src-cnt CvArr* <cv-arr>-elem-assign)]
      [(is-type? src <cv-arr>)
       (set! src-cnt 1)
       (set! (aref src-tmp-ary 0) (unboxing src <cv-arr>))
       (ENSURE_NOT_NULL (aref src-tmp-ary 0))
       (set! src-arr src-tmp-ary)]
      [else (Scm_Error "<list> or <vector> or <cv-arr> required, but got %S" src)])
    (cond ;dst
      [(is-type? dst <vector>)
       (set! dst-cnt (SCM_VECTOR_SIZE dst))
       (vector-to-ary dst dst-arr dst-tmp-ary TMP_ARY_SIZE CvArr* <cv-arr>-elem-assign)]
      [(is-type? dst <list>)
       (list-to-ary dst dst-arr dst-tmp-ary TMP_ARY_SIZE dst-cnt CvArr* <cv-arr>-elem-assign)]
      [(is-type? dst <cv-arr>)
       (set! dst-cnt 1)
       (set! (aref dst-tmp-ary 0) (unboxing dst <cv-arr>))
       (ENSURE_NOT_NULL (aref dst-tmp-ary 0))
       (set! dst-arr dst-tmp-ary)]
      [else (Scm_Error "<list> or <vector> or <cv-arr> required, but got %S" dst)])
    (cond ;from-to
      [(is-type? from-to <vector>)
       (set! from-to-cnt (SCM_VECTOR_SIZE from-to))
       (vector-to-ary from-to from-to-arr from-to-tmp-ary TMP_ARY_SIZE _int_t <int>-elem-assign)]
      [(is-type? from-to <list>)
       (list-to-ary from-to from-to-arr from-to-tmp-ary TMP_ARY_SIZE from-to-cnt _int_t <int>-elem-assign)]
      [(is-type? from-to <s32vector>)
       (set! from-to-cnt (SCM_S32VECTOR_SIZE from-to))
       (uvector.int-elem-assign from-to-arr from-to)]
      [else (Scm_Error "<list> or <vector> of <s32vector> required, but got %S" from-to)])

    (cvMixChannels (cast (const CvArr**) src-arr) src-cnt 
                   dst-arr dst-cnt 
                   (cast (const int*) from-to-arr) (/ from-to-cnt 2))))

;;;;;
;; Performs linear transformation on every source array element:
;; dst(x,y,c) = scale*src(x,y,c)+shift.
;; Arbitrary combination of input and output array depths are allowed
;; (number of channels must be the same), thus the function can be used
;; for type conversion
(define-cproc cv-convert-scale (src::<cv-arr> dst::<cv-arr>
                                              :optional (scale::<double> 1.0) (shift::<double> 0.0)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvConvertScale src dst scale shift))

;;;;;
;; Performs linear transformation on every source array element:
;; dst(x,y,c) = scale*src(x,y,c)+shift.
;; Arbitrary combination of input and output array depths are allowed
;; (number of channels must be the same), thus the function can be used
;; for type conversion
(define-cproc cv-cvt-scale (src::<cv-arr> dst::<cv-arr>
                                          :optional (scale::<double> 1.0) (shift::<double> 0.0)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvConvertScale src dst scale shift))

;;;;;
;; Performs linear transformation on every source array element:
;; dst(x,y,c) = scale*src(x,y,c)+shift.
;; Arbitrary combination of input and output array depths are allowed
;; (number of channels must be the same), thus the function can be used
;; for type conversion
(define-cproc cv-scale (src::<cv-arr> dst::<cv-arr>
                                      :optional (scale::<double> 1.0) (shift::<double> 0.0)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvConvertScale src dst scale shift))

;;;;;
;; Performs linear transformation on every source array element:
;; dst(x,y,c) = scale*src(x,y,c)+shift.
;; Arbitrary combination of input and output array depths are allowed
;; (number of channels must be the same), thus the function can be used
;; for type conversion
(define-cproc cv-convert (src::<cv-arr> dst::<cv-arr>)
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvConvertScale src dst 1 0))

;;;;;
;; Performs linear transformation on every source array element,
;; stores absolute value of the result:
;; dst(x,y,c) = abs(scale*src(x,y,c)+shift).
;; destination array must have 8u type.
;; In other cases one may use cv-convert-scale + cv-abs-dff-s
(define-cproc cv-convert-scale-abs (src::<cv-arr> dst::<cv-arr>
                                                  :optional 
                                                  (scale::<double> 1.0) (shift::<double> 0.0)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvConvertScaleAbs src dst scale shift))

;;;;;
;; Performs linear transformation on every source array element,
;; stores absolute value of the result:
;; dst(x,y,c) = abs(scale*src(x,y,c)+shift).
;; destination array must have 8u type.
;; In other cases one may use cv-convert-scale + cv-abs-dff-s
(define-cproc cv-cvt-scale-abs (src::<cv-arr> dst::<cv-arr>
                                              :optional 
                                              (scale::<double> 1.0) (shift::<double> 0.0)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvConvertScaleAbs src dst scale shift))

;;;;;
;; checks termination criteria validity and
;; sets eps to default_eps (if it is not set),
;; max_iter to default_max_iters (if it is not set)
(define-cproc cv-check-term-criteria (criteria::<cv-term-criteria>
                                       def-eps::<double> def-max-iters::<fixnum>) ::<cv-term-criteria>
  (result (cvCheckTermCriteria criteria def-eps def-max-iters)))


;;----------------------
;; Arithmetic, logic and comparison operations
;;

;;;;;
;; dst(mask) = src1(mask) + src2(mask)
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-add (src1::<cv-arr> src2::<cv-arr> dst::<cv-arr>
                                     :optional (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvAdd src1 src2 dst mask-arr)))

;;;;;
;; dst(mask) = src(mask) + value
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-add-s (src::<cv-arr> value::<cv-scalar> dst::<cv-arr>
                                      :optional (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvAddS src value dst mask-arr)))

;;;;;
;; dst(mask) = src1(mask) - src2(mask)
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-sub (src1::<cv-arr> src2::<cv-arr> dst::<cv-arr>
                                     :optional (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvSub src1 src2 dst mask-arr)))

;;;;;
;; dst(mask) = src(mask) - value = src(mask) + (-value)
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-sub-s (src::<cv-arr> value::<cv-scalar> dst::<cv-arr>
                                      :optional (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvSubS src value dst mask-arr)))

;;;;;
;; dst(mask) = value - src(mask)
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-sub-rs (src::<cv-arr> value::<cv-scalar> dst::<cv-arr>
                                       :optional (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvSubRS src value dst mask-arr)))

;;;;;
;; dst(idx) = src1(idx) * src2(idx) * scale
;; (scaled element-wise multiplication of 2 arrays)
(define-cproc cv-mul (src1::<cv-arr> src2::<cv-arr> dst::<cv-arr>
                                     :optional (scale::<double> 1.0)) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (cvMul src1 src2 dst scale))

;;;;;
;; element-wise division/inversion with scaling:
;;  dst(idx) = src1(idx) * scale / src2(idx)
;;  or dst(idx) = scale / src2(idx) if src1 == 0
(define-cproc cv-div (src1::<cv-arr> src2::<cv-arr> dst::<cv-arr>
                                     :optional (scale::<double> 1.0)) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (cvDiv src1 src2 dst scale))

;;;;;
;; dst = src1 * scale + src2
(define-cproc cv-scale-add(src1::<cv-arr> scale::<cv-scalar>
                                          src2::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (cvScaleAdd src1 scale src2 dst))

;;;;;
;; (cv-scalar-add src (cv-real-scalar value) b c)
(define-cproc cv-axpy (src1::<cv-arr> value::<double>
                                      src2::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (cvAXPY src1 value src2 dst))

;;;;;
;; dst = src1 * alpha + src2 * beta + gamma
(define-cproc cv-add-weighted (src1::<cv-arr> alpha::<double>
                                              src2::<cv-arr> beta::<double>
                                              gamma::<double> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (cvAddWeighted src1 alpha src2 beta gamma dst))

;;;;;
;; result = sum_i(src1(i) * src2(i)) (results for all channels are accumulated together) */
(define-cproc cv-dot-product (src1::<cv-arr> src2::<cv-arr>) ::<double>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (result (cvDotProduct src1 src2)))

;;;;;
;; dst(idx) = src1(idx) & src2(idx)
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-and (src1::<cv-arr> src2::<cv-arr> dst::<cv-arr>
                                     :optional (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvAnd src1 src2 dst mask-arr)))

;;;;;
;; dst(idx) = src(idx) & value
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-and-s (src::<cv-arr> value::<cv-scalar> dst::<cv-arr> 
                                       :optional (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvAndS src value dst mask-arr)))

;;;;;
;; dst(idx) = src1(idx) | src2(idx)
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-or (src1::<cv-arr> src2::<cv-arr> dst::<cv-arr>
                                    :optional (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvOr src1 src2 dst mask-arr)))

;;;;;
;; dst(idx) = src(idx) | value
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-or-s (src::<cv-arr> value::<cv-scalar> dst::<cv-arr> 
                                      :optional (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvOrS src value dst mask-arr)))

;;;;;
;; dst(idx) = src1(idx) ^ src2(idx)
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-xor (src1::<cv-arr> src2::<cv-arr> dst::<cv-arr>
                                     :optional (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvXor src1 src2 dst mask-arr)))

;;;;;
;; dst(idx) = src(idx) ^ value
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-xor-s (src::<cv-arr> value::<cv-scalar> dst::<cv-arr> 
                                       :optional (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvXorS src value dst mask-arr)))

;;;;;
;; dst(idx) = ~src(idx)
(define-cproc cv-not (src::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvNot src dst))

;;;;;
;; dst(idx) = lower(idx) <= src(idx) < upper(idx)
(define-cproc cv-in-range (src::<cv-arr> lower::<cv-arr>
                                         upper::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL lower)
  (ENSURE_NOT_NULL upper)
  (ENSURE_NOT_NULL dst)
  (cvInRange src lower upper dst))

;;;;;
;; dst(idx) = lower <= src(idx) < upper
(define-cproc cv-in-range-s (src::<cv-arr> lower::<cv-scalar>
                                           upper::<cv-scalar> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvInRangeS src lower upper dst))


;;----------------
;; Constants
;;
(define-enum CV_CMP_EQ)
(define-enum CV_CMP_GT)
(define-enum CV_CMP_GE)
(define-enum CV_CMP_LT)
(define-enum CV_CMP_LE)
(define-enum CV_CMP_NE)

;;;;;
;; The comparison operation support single-channel arrays only.
;; Destination image should be 8uC1 or 8sC1
;; dst(idx) = src1(idx) _cmp_op_ src2(idx)
;; @slot {@ CV_CMP_EQ CV_CMP_GT CV_CMP_GE CV_CMP_LT CV_CMP_LE CV_CMP NE}
(define-cproc cv-cmp (src1::<cv-arr> src2::<cv-arr> dst::<cv-arr> cmp-op::<fixnum>) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (cvCmp src1 src2 dst cmp-op))

;;;;;
;; The comparison operation support single-channel arrays only.
;; Destination image should be 8uC1 or 8sC1
;; dst(idx) = src1(idx) _cmp_op_ value
;; @slot {@ CV_CMP_EQ CV_CMP_GT CV_CMP_GE CV_CMP_LT CV_CMP_LE CV_CMP NE}
(define-cproc cv-cmp-s (src::<cv-arr> value::<double> dst::<cv-arr> cmp-op::<fixnum>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvCmpS src value dst cmp-op))

;;;;;
;; dst(idx) = min(src1(idx),src2(idx))
(define-cproc cv-min (src1::<cv-arr> src2::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (cvMin src1 src2 dst))

;;;;;
;; dst(idx) = max(src1(idx),src2(idx))
(define-cproc cv-max (src1::<cv-arr> src2::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (cvMax src1 src2 dst))

;;;;;
;; dst(idx) = min(src(idx),value)
(define-cproc cv-min-s (src::<cv-arr> value::<double> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvMinS src value dst))

;;;;;
;; dst(idx) = max(src(idx),value)
(define-cproc cv-max-s (src::<cv-arr> value::<double> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvMaxS src value dst))

;;;;;
;; dst(x,y,c) = abs(src1(x,y,c) - src2(x,y,c))
(define-cproc cv-abs-diff (src1::<cv-arr> src2::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (cvAbsDiff src1 src2 dst))

;;;;;
;; dst(x,y,c) = abs(src(x,y,c) - value(c))
(define-cproc cv-abs-diff-s (src::<cv-arr> dst::<cv-arr> value::<cv-scalar>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvAbsDiffS src dst value))

;;;;;
;; dst(x,y,c) = abs(src(x,y,c) - value(c))
(define-cproc cv-abs (src::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvAbs src dst))


;;---------------------
;; Math operations
;;

;;;;;
;; Does cartesian->polar coordinates conversion.
;; Either of output components (magnitude or angle) is optional
;; @param ((angle (c "SCM_UNDEFINED")) >> (angle c:null))
(define-cproc cv-cart-to-polar (x::<cv-arr> y::<cv-arr> magnitude::<cv-arr>
                                            :optional (angle (c "SCM_UNDEFINED")) (angle-in-degrees::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL x)
  (ENSURE_NOT_NULL y)
  (ENSURE_NOT_NULL magnitude)
  (let* ([angle-arr::CvArr*])
    (undef-or-cvarr angle angle-arr)
    (cvCartToPolar x y magnitude angle-arr angle-in-degrees)))

;;;;;
;; Does polar->cartesian coordinates conversion.
;; Either of output components (magnitude or angle) is optional.
;; If magnitude is missing it is assumed to be all 1's
(define-cproc cv-polar-to-cart (magnitude::<cv-arr> angle::<cv-arr>
                                                    x::<cv-arr> y::<cv-arr>
                                                    :optional (angle-in-degrees::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL magnitude)
  (ENSURE_NOT_NULL angle)
  (ENSURE_NOT_NULL x)
  (ENSURE_NOT_NULL y)
  (cvPolarToCart magnitude angle x y angle-in-degrees))

;;;;;
;; Does powering: dst(idx) = src(idx)^power
(define-cproc cv-pow (src::<cv-arr> dst::<cv-arr> power::<double>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvPow src dst power))

;;;;;
;; Does exponention: dst(idx) = exp(src(idx)).
;; Overflow is not handled yet. Underflow is handled.
;; Maximal relative error is ~7e-6 for single-precision input
(define-cproc cv-exp (src::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvExp src dst))

;;;;;
;; Calculates natural logarithms: dst(idx) = log(abs(src(idx))).
;; Logarithm of 0 gives large negative number(~-700)
;; Maximal relative error is ~3e-7 for single-precision output
(define-cproc cv-log (src::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvLog src dst))

;;;;;
;; Fast arctangent calculation
(define-cproc cv-fast-arctan (y::<float> x::<float>) ::<float>
  (cvFastArctan y x))

;;;;;
;; Fast cubic root calculation
(define-cproc cv-cbrt (value::<float>) ::<float>
  (cvCbrt value))


;;----------------
;; Constants
;;
(define-enum CV_CHECK_RANGE)
(define-enum CV_CHECK_QUIET)
;;;;;
;; Checks array values for NaNs, Infs or simply for too large numbers
;; (if CV_CHECK_RANGE is set). If CV_CHECK_QUIET is set,
;; no runtime errors is raised (function returns zero value in case of "bad" values).
;; Otherwise cvError is called
;;@param (flags 0) {@ 0 CV_CHECK_RANGE CV_CHECK_QUIET}
(define-cproc cv-check-arr (arr::<cv-arr>
                             :optional (flags::<fixnum> 0) 
                             (min-val::<fixnum> 0) (max-val::<fixnum> 0)) ::<int>
  (ENSURE_NOT_NULL arr)
  (result (cvCheckArr arr flags min-val max-val)))

;;;;;
;; Checks array values for NaNs, Infs or simply for too large numbers
;; (if CV_CHECK_RANGE is set). If CV_CHECK_QUIET is set,
;; no runtime errors is raised (function returns zero value in case of "bad" values).
;; Otherwise cvError is called
;;@param (flags 0) {@ 0 CV_CHECK_RANGE CV_CHECK_QUIET}
(define-cproc cv-check-array (arr::<cv-arr>
                               :optional (flags::<fixnum> 0) 
                               (min-val::<fixnum> 0) (max-val::<fixnum> 0)) ::<int>
  (ENSURE_NOT_NULL arr)
  (result (cvCheckArr arr flags min-val max-val)))


;;----------------
;; Constants
;;
(define-enum CV_RAND_UNI)
(define-enum CV_RAND_NORMAL)

;;;;;
;;@param dist-type {@ CV_RAND_UNI CV_RAND_NORMAL}
(define-cproc cv-rand-arr (rng::<cv-rng> arr::<cv-arr> dist-type::<fixnum>
                                         param1::<cv-scalar> param2::<cv-scalar>) ::<void>
  (ENSURE_NOT_NULL arr)
  (cvRandArr rng arr dist-type param1 param2))
(define-cproc cv-rand-shuffle (mat::<cv-arr> rng::<cv-rng>
                                             :optional (iter-factor::<double> 1.0)) ::<void>
  (ENSURE_NOT_NULL mat)
  (cvRandShuffle mat rng iter-factor))


;;----------------
;; Constants
;;
(define-enum CV_SORT_EVERY_ROW)
(define-enum CV_SORT_EVERY_COLUMN)
(define-enum CV_SORT_ASCENDING)
(define-enum CV_SORT_DESCENDING)

;;;;;
;;@param ((flags 0) >> (flags CV_SORT_EVERY_ROW)) 
;; {@ CV_SORT_EVERY_ROW CV_SORT_EVERY_COLUMN CV_SORT_ASCENDING CV_SORT_DESCENDING}
;; @param ((dst (c "SCM_UNDEFINED")) >> (dst c:null))
;; @param ((idxmat (c "SCM_UNDEFINED")) >> (idxmat c:null))
(define-cproc cv-sort (src::<cv-arr>
                        :optional (dst (c "SCM_UNDEFINED")) (idxmat (c "SCM_UNDEFINED"))
                        (flags::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL src)
  (let* ([dst-arr::CvArr*]
         [idxmat-arr::CvArr*])
    (undef-or-cvarr dst dst-arr)
    (undef-or-cvarr idxmat idxmat-arr)
    (cvSort src dst-arr idxmat-arr flags)))

;;;;;
;; Finds real roots of a cubic equation
(define-cproc cv-solve-cubic (coeffs::<cv-mat> roots::<cv-mat>) ::<int>
  (ENSURE_NOT_NULL coeffs)
  (ENSURE_NOT_NULL roots)
  (result (cvSolveCubic coeffs roots)))

;;;;;
;; Finds all real and complex roots of a polynomial equation
(define-cproc cv-solve-poly (coeffs::<cv-mat> roots2::<cv-mat>
                                              :optional (maxiter::<fixnum> 20) (fig::<fixnum> 100)) ::<void>
  (ENSURE_NOT_NULL coeffs)
  (ENSURE_NOT_NULL roots2)
  (cvSolvePoly coeffs roots2 maxiter fig))


;;--------------------
;; Matrix operations
;;

;;;;;
;; Calculates cross product of two 3d vectors
(define-cproc cv-cross-product(src1::<cv-arr> src2::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (cvCrossProduct src1 src2 dst))

;;----------------
;; Constants
;;
(define-enum CV_GEMM_A_T)
(define-enum CV_GEMM_B_T)
(define-enum CV_GEMM_C_T)

;;;;;
;; Extended matrix transform:
;; dst = alpha*op(A)*op(B) + beta*op(C), where op(X) is X or X^T */
;;@param (t-abc 0) {@ CV_GEMM_A_T CV_GEMM_B_T CV_GEMM_C_T}
(define-cproc cv-gemm (src1::<cv-arr> src2::<cv-arr> alpha::<double>
                                      src3::<cv-arr> beta::<double> dst::<cv-arr>
                                      :optional (t-abc::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL src3)
  (ENSURE_NOT_NULL dst)
  (cvGEMM src1 src2 alpha src3 beta dst t-abc))

;;;;;
;; Extended matrix transform:
;; dst = alpha*op(A)*op(B) + beta*op(C), where op(X) is X or X^T */
;;@param (t-abc 0) {@ CV_GEMM_A_T CV_GEMM_B_T CV_GEMM_C_T}
(define-cproc cv-mat-mul-add-ex (src1::<cv-arr> src2::<cv-arr> alpha::<double>
                                             src3::<cv-arr> beta::<double> dst::<cv-arr>
                                             :optional (t-abc::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL src3)
  (ENSURE_NOT_NULL dst)
  (cvMatMulAddEx src1 src2 alpha src3 beta dst t-abc))

;;;;;
;; Matrix transform: dst = A*B + C, C is optional
(define-cproc cv-mat-mul-add (src1::<cv-arr> src2::<cv-arr> src3::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL src3)
  (ENSURE_NOT_NULL dst)
  (cvMatMulAdd src1 src2 src3 dst))

(define-cproc cv-mat-mul (src1::<cv-arr> src2::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (cvMatMul src1 src2 dst))

;;;;;
;; Transforms each element of source array and stores
;; resultant vectors in destination array
;; @param ((shiftvec (c "SCM_UNDEFINED")) >> (shiftvec c:null))
(define-cproc cv-transform (src::<cv-arr> dst::<cv-arr> transmat::<cv-mat>
                                          :optional (shiftvec (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (ENSURE_NOT_NULL transmat)
  (let* ([shiftvec-arr::CvArr*])
    (undef-or-cvarr shiftvec shiftvec-arr)
    (cvTransform src dst transmat shiftvec-arr)))

;;;;;
;; Transforms each element of source array and stores
;; resultant vectors in destination array
;; @param ((shiftvec (c "SCM_UNDEFINED")) >> (shiftvec c:null))
(define-cproc cv-mat-mul-add-s (src::<cv-arr> dst::<cv-arr> transmat::<cv-mat>
                                              :optional (shiftvec (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (ENSURE_NOT_NULL transmat)
  (let* ([shiftvec-arr::CvArr*])
    (undef-or-cvarr shiftvec shiftvec-arr)
    (cvMatMulAddS src dst transmat shiftvec-arr)))

;;;;;
;; Does perspective transform on every element of input array
(define-cproc cv-perspective-transform (src::<cv-arr> dst::<cv-arr> mat::<cv-mat>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (ENSURE_NOT_NULL mat)
  (cvPerspectiveTransform src dst mat))

;;;;;
;; Calculates (A-delta)*(A-delta)^T (order=0) or (A-delta)^T*(A-delta) (order=1)
;; @param ((delta (c "SCM_UNDEFINED")) >> (delta c:null))
(define-cproc cv-mul-transposed(src::<cv-arr> dst::<cv-arr> order::<fixnum>
                                              :optional (delta (c "SCM_UNDEFINED")) (scale::<double> 1.0)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([delta-arr::CvArr*])
    (undef-or-cvarr delta delta-arr)
    (cvMulTransposed src dst order delta-arr scale)))

;;;;;
;; Tranposes matrix. Square matrices can be transposed in-place
(define-cproc cv-transpose (src::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvTranspose src dst))

;;;;;
;; Tranposes matrix. Square matrices can be transposed in-place
(define-cproc cv-t (src::<cv-arr> dst::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvT src dst))

;;;;;
;; Completes the symmetric matrix from the lower (LtoR=0) or from the upper (LtoR!=0) part */
(define-cproc cv-complete-symm (matrix::<cv-mat> 
                                 :optional (l-to-r::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL matrix)
  (cvCompleteSymm matrix l-to-r))

;;;;;
;; Mirror array data around horizontal (flip=0),
;; vertical (flip=1) or both(flip=-1) axises:
;; (cv-flip src) flips images vertically and sequences horizontally (inplace)
;; @param (flip-mode 0) {@ 0 1 -1}
;; horizontal (flip=0), vertical (flip=1) or both(flip=-1) axises
;; @param ((dst (c "SCM_UNDEFINED")) >> (dst c:null))
(define-cproc cv-flip (src::<cv-arr>
                        :optional (dst (c "SCM_UNDEFINED")) (flip-mode::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL src)
  (let* ([dst-arr::CvArr*])
    (undef-or-cvarr dst dst-arr)
    (cvFlip src dst-arr flip-mode)))

;;;;;
;; Mirror array data around horizontal (flip=0),
;; vertical (flip=1) or both(flip=-1) axises:
;; (cv-mirror src) flips images vertically and sequences horizontally (inplace)
;; @param (flip-mode 0) {@ 0 1 -1}
;; horizontal (flip=0), vertical (flip=1) or both(flip=-1) axises
;; @param ((dst (c "SCM_UNDEFINED")) >> (dstc c:null))
(define-cproc cv-mirror (src::<cv-arr>
                          :optional (dst (c "SCM_UNDEFINED")) (flip-mode::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL src)
  (let* ([dst-arr::CvArr*])
    (undef-or-cvarr dst dst-arr)
    (cvMirror src dst-arr flip-mode)))


;;----------------
;; Constants
;;
(define-enum CV_SVD_MODIFY_A)
(define-enum CV_SVD_U_T)
(define-enum CV_SVD_V_T)

;;;;;
;; Performs Singular Value Decomposition of a matrix
;; @param (flags 0) {@ 0 CV_SVD_MODIFY_A CV_SVD_U_T CV_SVD_V_T}
;; @param ((u (c "SCM_UNDEFINED")) >> (u c:null))
;; @param ((v (c "SCM_UNDEFINED")) >> (v c:null))
(define-cproc cv-svd (a::<cv-arr> w::<cv-arr>
                                  :optional (u (c "SCM_UNDEFINED")) (v (c "SCM_UNDEFINED")) (flags::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL a)
  (ENSURE_NOT_NULL w)
  (let* ([u-arr::CvArr*]
         [v-arr::CvArr*])
    (undef-or-cvarr u u-arr)
    (undef-or-cvarr v v-arr)
    (cvSVD a w u-arr v-arr flags)))

;;;;;
;; Performs Singular Value Back Substitution (solves A*X = B):
;; flags must be the same as in cvSVD
;;@param flags {@ 0 CV_SVD_MODIFY_A CV_SVD_U_T CV_SVD_V_T}
(define-cproc cv-svbksb (w::<cv-arr> u::<cv-arr> v::<cv-arr> 
                                     b::<cv-arr> x::<cv-arr> flags::<fixnum>) ::<void>
  (ENSURE_NOT_NULL w)
  (ENSURE_NOT_NULL u)
  (ENSURE_NOT_NULL v)
  (ENSURE_NOT_NULL b)
  (ENSURE_NOT_NULL x)
  (cvSVBkSb w u v b x flags))


;;----------------
;; Constants
;;
(define-enum CV_LU)
(define-enum CV_SVD)
(define-enum CV_SVD_SYM)
(define-enum CV_CHOLESKY)
(define-enum CV_QR)
(define-enum CV_NORMAL)

;;;;;
;; Inverts matrix
;;@param ((method 0) >> (method CV_LU))
;;{@ CV_LU CV_SVD CV_SVD_SYM CV_CHOLESKY CV_QR}
(define-cproc cv-invert (src::<cv-arr> dst::<cv-arr>
                                       :optional (method::<fixnum> 0)) ::<double>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (result (cvInvert src dst method)))

;;;;;
;; Inverts matrix
;;@param ((method 0) >> (method CV_LU))
;;{@ CV_LU CV_SVD CV_SVD_SYM CV_CHOLESKY CV_QR}
(define-cproc cv-inv (src::<cv-arr> dst::<cv-arr>
                                    :optional (method::<fixnum> 0)) ::<double>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (result (cvInv src dst method)))

;;;;;
;; Solves linear system (src1)*(dst) = (src2)
;; (returns 0 if src1 is a singular and CV_LU method is used)
;;@param ((method 0) >> (method CV_LU))
;;{@ CV_LU CV_SVD CV_SVD_SYM CV_CHOLESKY CV_QR}
(define-cproc cv-solve (src1::<cv-arr> src2::<cv-arr> dst::<cv-arr>
                                       :optional (method::<fixnum> 0)) ::<int>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (result (cvSolve src1 src2 dst method)))

;;;;;
;; Calculates determinant of input matrix
(define-cproc cv-det (mat::<cv-arr>) ::<double>
  (ENSURE_NOT_NULL mat)
  (result (cvDet mat)))

;;;;;
;; Calculates trace of the matrix (sum of elements on the main diagonal)
(define-cproc cv-trace (mat::<cv-arr>) ::<cv-scalar>
  (ENSURE_NOT_NULL mat)
  (result (cvTrace mat)))

;;;;;
;; Finds eigen values and vectors of a symmetric matrix
(define-cproc cv-eigen-vv (mat::<cv-arr> evects::<cv-arr> evals::<cv-arr>
                                         :optional (eps::<double> 0.0) 
                                         (lowindex::<fixnum> -1) (highindex::<fixnum> -1)) ::<void>
  (ENSURE_NOT_NULL mat)
  (ENSURE_NOT_NULL evects)
  (ENSURE_NOT_NULL evals)
  (cvEigenVV mat evects evals eps lowindex highindex))

;;;;;
;; Makes an identity matrix (mat_ij = i == j)
;; @param ((value (c "SCM_UNDEFINED")) >> (value c:null))
(define-cproc cv-set-identity (mat::<cv-arr>
                                :optional (value (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL mat)
  (let* ([value-o::CvScalar])
    (undef-or-obj value value-o <cv-scalar> (cvRealScalar 1))
    (cvSetIdentity mat value-o)))

;;;;;
;; Fills matrix with given range of numbers
(define-cproc cv-range (mat::<cv-arr> start::<double> end::<double>) ::<void>
  (ENSURE_NOT_NULL mat)
  (cvRange mat start end))

;;----------------
;; Constants
;;

;;;;;
;; transpose([v1-avg, v2-avg,...]) * [v1-avg,v2-avg,...]
(define-enum CV_COVAR_SCRAMBLED)
;;;;;
;; [v1-avg, v2-avg,...] * transpose([v1-avg,v2-avg,...])
(define-enum CV_COVAR_NORMAL)
;;;;;
;; do not calc average (i.e. mean vector) - use the input vector instead
;; (useful for calculating covariance matrix by parts)
(define-enum CV_COVAR_USE_AVG)
;;;;;
;; scale the covariance matrix coefficients by number of the vectors
(define-enum CV_COVAR_SCALE)
;;;;;
;; all the input vectors are stored in a single matrix, as its rows
(define-enum CV_COVAR_ROWS)
;;;;;
;; all the input vectors are stored in a single matrix, as its columns
(define-enum CV_COVAR_COLS)

"
#define CALCCOVARMATRIX_TMP_ARY_SIZE 100
"
;;;;;
;; Calculates covariation matrix for a set of vectors
;;@param flags {@ CV_COVAR_SCRAMBLED CV_COVAR_NORMAL CV_COVAR_USE_AVG CV_COVAR_SCALE CV_COVAR_ROWS CV_COVAR_COLS}
;; logor each bit flags
(define-cproc cv-calc-covar-matrix (vects-obj::<top> cov-mat::<cv-arr> 
                                                        avg::<cv-arr> flags::<fixnum>) ::<void>
  (ENSURE_NOT_NULL cov-mat)
  (ENSURE_NOT_NULL avg)
  (let* ([vect-cnt::int]
         [vects::CvArr**]
         [vects-tmp :: (.array void* (CALCCOVARMATRIX_TMP_ARY_SIZE))])
    (cond
      [(is-type? vects-obj <vector>)
       (set! vect-cnt (SCM_VECTOR_SIZE vects-obj))
       (vector-to-ary vects-obj vects vects-tmp CALCCOVARMATRIX_TMP_ARY_SIZE CvArr* <cv-arr>-elem-assign)]
      [(is-type? vects-obj <list>)
       (list-to-ary vects-obj vects vects-tmp CALCCOVARMATRIX_TMP_ARY_SIZE vect-cnt CvArr* <cv-arr>-elem-assign)]
      [(is-type? vects-obj <cv-arr>)
       (set! vect-cnt 1)
       (set! (aref vects-tmp 0) (unboxing vects-obj <cv-arr>))
       (ENSURE_NOT_NULL (aref vects-tmp 0))
       (set! vects vects-tmp)]
      [else (Scm_Error "<list> or <vector> or <cv-arr> required, but got %S" vects-obj)])
    (cvCalcCovarMatrix (cast (const CvArr**) vects) vect-cnt cov-mat avg flags)))

;;----------------
;; Constants
;;
(define-enum CV_PCA_DATA_AS_ROW)
(define-enum CV_PCA_DATA_AS_COL)
(define-enum CV_PCA_USE_AVG)

;;;;;
;;@param flags {@ CV_PCA_DATA_AS_ROW CV_PCA_DATA_AS_COL CV_PCA_USE_AVG}
(define-cproc cv-calc-pca (data::<cv-arr> mean::<cv-arr>
                                          eigenvals::<cv-arr> eigenvects::<cv-arr> flags::<fixnum>) ::<void>
  (ENSURE_NOT_NULL data)
  (ENSURE_NOT_NULL mean)
  (ENSURE_NOT_NULL eigenvals)
  (ENSURE_NOT_NULL eigenvects)
  (cvCalcPCA data mean eigenvects eigenvects flags))

(define-cproc cv-project-pca (data::<cv-arr> mean::<cv-arr>
                                             eigenvals::<cv-arr> result::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL data)
  (ENSURE_NOT_NULL mean)
  (ENSURE_NOT_NULL eigenvals)
  (ENSURE_NOT_NULL result)
  (cvProjectPCA data mean eigenvals result))

(define-cproc cv-backproject-pca (proj::<cv-arr> mean::<cv-arr>
                                                 eigenvals::<cv-arr> result::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL proj)
  (ENSURE_NOT_NULL mean)
  (ENSURE_NOT_NULL eigenvals)
  (ENSURE_NOT_NULL result)
  (cvBackProjectPCA proj mean eigenvals result))

;;;;;
;; Calculates Mahalanobis(weighted) distance
(define-cproc cv-mahalanobis (vec1::<cv-arr> vec2::<cv-arr> mat::<cv-arr>) ::<double>
  (ENSURE_NOT_NULL vec1)
  (ENSURE_NOT_NULL vec2)
  (ENSURE_NOT_NULL mat)
  (result (cvMahalanobis vec1 vec2 mat)))

;;;;;
;; Calculates Mahalanobis(weighted) distance
(define-cproc cv-mahalonobis (vec1::<cv-arr> vec2::<cv-arr> mat::<cv-arr>) ::<double>
  (ENSURE_NOT_NULL vec1)
  (ENSURE_NOT_NULL vec2)
  (ENSURE_NOT_NULL mat)
  (result (cvMahalonobis vec1 vec2 mat)))



;;-----------------
;; Array Statistics
;;

;;;;;
;; Finds sum of array elements
(define-cproc cv-sum (arr::<cv-arr>) ::<cv-scalar>
  (ENSURE_NOT_NULL arr)
  (result (cvSum arr)))

;;;;;
;; Calculates number of non-zero pixels
(define-cproc cv-count-non-zero (arr::<cv-arr>) ::<int>
  (ENSURE_NOT_NULL arr)
  (result (cvCountNonZero arr)))

;;;;;
;; Calculates mean value of array elements
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-avg (arr::<cv-arr> 
                       :optional (mask (c "SCM_UNDEFINED"))) ::<cv-scalar>
  (ENSURE_NOT_NULL arr)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (result (cvAvg arr mask-arr))))

;;;;;
;; Calculates mean and standard deviation of pixel values
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-avg-sdv (arr::<cv-arr>
                           :optional (mask (c "SCM_UNDEFINED"))) ::(<cv-scalar> <cv-scalar>)
  (ENSURE_NOT_NULL arr)
  (let* ([mask-arr::CvArr*]
         [mean::CvScalar]
         [std-dev::CvScalar])
    (undef-or-cvarr mask mask-arr)
    (cvAvgSdv arr (& mean) (& std-dev) mask-arr)
    (result mean std-dev)))

;;;;;
;; Finds global minimum, maximum and their positions
;; @return (values min-val max-val)
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-min-max (arr::<cv-arr>
                           :optional (mask (c "SCM_UNDEFINED"))) ::(<double> <double>)
  (ENSURE_NOT_NULL arr)
  (let* ([mask-arr::CvArr*]
         [min-val::double]
         [max-val::double])
    (undef-or-cvarr mask mask-arr)
    (cvMinMaxLoc arr (& min-val) (& max-val) 0 0 mask-arr)
    (result min-val max-val)))

;;;;;
;; Finds global minimum, maximum and their positions
;; @return (values min-val max-val min-loc max-loc)
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-min-max-loc (arr::<cv-arr>
                               :optional (mask (c "SCM_UNDEFINED"))) ::(<double> <double> <cv-point> <cv-point>)
  (ENSURE_NOT_NULL arr)
  (let* ([mask-arr::CvArr*]
         [min-val::double]
         [max-val::double]
         [min-loc::CvPoint]
         [max-loc::CvPoint])
    (undef-or-cvarr mask mask-arr)
    (cvMinMaxLoc arr (& min-val) (& max-val)
                 (& min-loc) (& max-loc) mask-arr)
    (result min-val max-val min-loc max-loc)))

;;----------------
;; Constants
;;
(define-enum CV_C)
(define-enum CV_L1)
(define-enum CV_L2)
(define-enum CV_RELATIVE)
(define-enum CV_DIFF)
(define-enum CV_MINMAX)

(define-enum CV_DIFF_C)
(define-enum CV_DIFF_L1)
(define-enum CV_DIFF_L2)
(define-enum CV_RELATIVE_C)
(define-enum CV_RELATIVE_L1)
(define-enum CV_RELATIVE_L2)

;;;;;
;; Finds norm, difference norm or relative difference norm for an array (or two arrays)
;;@param ((norm-type 4) >> (norm-type CV_L2))
;; {@ CV_C CV_L1 CV_L2 CV_DIFF_C CV_DIFF_L1 CV_DIFF_L2 CV_RELATIVE_C CV_RELATIVE_L1 CV_RELATIVE_L2}
;; @param ((arr2 (c "SCM_UNDEFINED")) >> (arr2 c:null))
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-norm (arr1::<cv-arr> 
                        :optional (arr2 (c "SCM_UNDEFINED"))
                        (norm-type::<fixnum> 4) ;norm-type 4 is CV_L2
                        (mask (c "SCM_UNDEFINED"))) ::<double>
  (ENSURE_NOT_NULL arr1)
  (let* ([arr2-arr::CvArr*]
         [mask-arr::CvArr*])
    (undef-or-cvarr arr2 arr2-arr)
    (undef-or-cvarr mask mask-arr)
    (result (cvNorm arr1 arr2-arr norm-type mask-arr))))

;;;;;
;;@param ((norm-type 4) >> (norm-type CV_L2))
;; {@ CV_C CV_L1 CV_L2 CV_DIFF_C CV_MINMAX}
;; @param ((mask (c "SCM_UNDEFINED")) >> (mask c:null))
(define-cproc cv-normalize (src::<cv-arr> dst::<cv-arr>
                                          :optional (a::<double> 1.0) (b::<double> 0.0)
                                          (norm-type::<fixnum> 4) ;norm-type 4 is CV_L2
                                          (mask (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([mask-arr::CvArr*])
    (undef-or-cvarr mask mask-arr)
    (cvNormalize src dst a b norm-type mask-arr)))


;;----------------
;; Constants
;;
(define-enum CV_REDUCE_SUM)
(define-enum CV_REDUCE_AVG)
(define-enum CV_REDUCE_MAX)
(define-enum CV_REDUCE_MIN)

;;;;;
;;@param ((op 0) >> (op CV_REDUCE_SUM))
;;{@ CV_REDUCE_SUM CV_REDUCE_AGB CV_REDUCE_MAX CV_REDUCE_MIN}
(define-cproc cv-reduce (src::<cv-arr> dst::<cv-arr>
                                       :optional (dim::<fixnum> -1)
                                       (op::<fixnum> 0)) ;op 0 is CV_REDUCE_SUM
  ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvReduce src dst dim op))



;;-----------------
;; Discrete Linear Transforms and Related Functions
;;


;;----------------
;; Constants
;;
(define-enum CV_DXT_FORWARD)
(define-enum CV_DXT_INVERSE)
;;;;;
;;divide result by size of array
(define-enum CV_DXT_SCALE)
(define-enum CV_DXT_INV_SCALE)
(define-enum CV_DXT_INVERSE_SCALE)
;;;;;
;transform each row individually
(define-enum CV_DXT_ROWS)
;;;;;
;;conjugate the second argument of cvMulSpectrums
(define-enum CV_DXT_MUL_CONJ)

;;;;;
;; Discrete Fourier Transform:
;;  complex->complex,
;;  real->ccs (forward),
;;  ccs->real (inverse)
;;@param flags {@ CV_DXT_FORWARD CV_DXT_INVERSE CV_DXT_SCALE CV_DXT_INV_SCALE
;; CV_DXT_INVERSE_SCALE CV_DXT_ROWS CV_DXT_MUL_CONJ}
(define-cproc cv-dft (src::<cv-arr> dst::<cv-arr> flags::<fixnum>
                                    :optional (nonzero-rows::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvDFT src dst flags nonzero-rows))

;;;;;
;; Discrete Fourier Transform:
;;  complex->complex,
;;  real->ccs (forward),
;;  ccs->real (inverse)
;;@param flags {@ CV_DXT_FORWARD CV_DXT_INVERSE CV_DXT_SCALE CV_DXT_INV_SCALE
;; CV_DXT_INVERSE_SCALE CV_DXT_ROWS CV_DXT_MUL_CONJ}
(define-cproc cv-fft (src::<cv-arr> dst::<cv-arr> flags::<fixnum>
                                    :optional (nonzero-rows::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvFFT src dst flags nonzero-rows))

;;;;;
;; Multiply results of DFTs: DFT(X)*DFT(Y) or DFT(X)*conj(DFT(Y))
(define-cproc cv-mul-spectrums (src1::<cv-arr> src2::<cv-arr>
                                               dst::<cv-arr> flags::<fixnum>) ::<void>
  (ENSURE_NOT_NULL src1)
  (ENSURE_NOT_NULL src2)
  (ENSURE_NOT_NULL dst)
  (cvMulSpectrums src1 src2 dst flags))

;;;;;
;; Finds optimal DFT vector size >= size0
(define-cproc cv-get-optimal-dft-size (size0::<fixnum>) ::<fixnum>
  (result (cvGetOptimalDFTSize size0)))

;;;;;
;; Discrete Cosine Transform
(define-cproc cv-dct (src::<cv-arr> dst::<cv-arr> flags::<fixnum>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvDCT src dst flags))

;;-----------------------
;; Drawing
;;-----------------------

(define-enum CV_AA)

(define-cproc cv-rgb (r::<fixnum> g::<fixnum> b::<fixnum>) ::<cv-scalar>
  (result (CV_RGB r g b)))

;;;;;
;; Draws 4-connected, 8-connected or antialiased line segment connecting two points
;; @param (line-type 8) {@ 4 8 16}
(define-cproc cv-line (img::<cv-arr> pt1::<cv-point> pt2::<cv-point> color::<cv-scalar>
                                     :optional (thickness::<fixnum> 1) (line-type::<fixnum> 8) (shift::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL img)
  (cvLine img pt1 pt2 color thickness line-type shift))

;;;;;
;; Draws a rectangle given two opposite corners of the rectangle (pt1 & pt2),
;; if thickness<0 (e.g. thickness == CV_FILLED), the filled box is drawn
;; @param (thickness 1) {@ -1 <integer>}
;; @param (line-type 8) {@ 4 8 16}
(define-cproc cv-rectangle (img::<cv-arr> pt1::<cv-point> pt2::<cv-point> color::<cv-scalar>
                                          :optional (thickness::<fixnum> 1) (line-type::<fixnum> 8) (shift::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL img)
  (cvRectangle img pt1 pt2 color thickness line-type shift))

;;;;;
;; Draws a rectangle specified by a CvRect structure
;; @param (thickness 1) {@ -1 <integer>}
;; @param (line-type 8) {@ 4 8 16}
(define-cproc cv-rectangle-r (img::<cv-arr> r::<cv-rect> color::<cv-scalar>
                                            :optional (thickness::<fixnum> 1) (line-type::<fixnum> 8) (shift::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL img)
  (cvRectangleR img r color thickness line-type shift))

;;;;;
;; Draws a circle with specified center and radius.
;; Thickness works in the same way as with cvRectangle 
;; @param (thickness 1) {@ -1 <integer>}
;; @param (line-type 8) {@ 4 8 16}
(define-cproc cv-circle (img::<cv-arr> center::<cv-point> radius::<fixnum> color::<cv-scalar>
                                       :optional (thickness::<fixnum> 1) (line-type::<fixnum> 8) (shift::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL img)
  (cvCircle img center radius color thickness line-type shift))

;;;;;
;; Draws ellipse outline, filled ellipse, elliptic arc or filled elliptic sector,
;; depending on <thickness>, <start_angle> and <end_angle> parameters. The resultant figure
;; is rotated by <angle>. All the angles are in degrees
;; @param center {@ <cv-point>}
;; @param axes {@ <cv-size>}
;; @param (thickness 1) {@ -1 <integer>}
;; @param (line-type 8) {@ 4 8 16}
(define-cproc cv-ellipse (img::<cv-arr> center::<cv-point> axes::<cv-size> 
                                        angle::<double> start-angle::<double> end-angle::<double> color::<cv-scalar>
                                        :optional (thickness::<fixnum> 1) (line-type::<fixnum> 8) (shift::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL img)
  (cvEllipse img center axes angle start-angle end-angle color thickness line-type shift))

(define-cproc cv-ellipse-box (img::<cv-arr> box::<cv-box-2d> color::<cv-scalar>
                                            :optional (thickness::<fixnum> 1) (line-type::<fixnum> 8) (shift::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL img)
  (cvEllipseBox img box color thickness line-type shift))

;;;;;
;; Fills convex or monotonous polygon.
;; @param pts {@ <vector>_or_<list>_of_<cv-point>}
;; @param (line-type 8) {@ 4 8 16}
(define-cproc cv-fill-convex-poly (img::<cv-arr> pts::<top> color::<cv-scalar>
                                                 :optional (line-type::<fixnum> 8) (shift::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL img)
  (let* ([pts-cnt::int]
         [pts-arr::CvPoint*]
         [pts-tmp :: (.array CvPoint (TMP_ARY_SIZE))])
    (cond
      [(is-type? pts <vector>)
       (set! pts-cnt (SCM_VECTOR_SIZE pts))
       (vector-to-ary pts pts-arr pts-tmp TMP_ARY_SIZE CvPoint <cv-point>-elem-assign)]
      [(is-type? pts <list>)
       (list-to-ary pts pts-arr pts-tmp TMP_ARY_SIZE pts-cnt CvPoint <cv-point>-elem-assign)]
      [else (Scm_Error "<list> or <vector> required, but got %S" pts)])
    (cvFillConvexPoly img pts-arr pts-cnt color line-type shift)))

;;;;;
;; Fills an area bounded by one or more arbitrary polygons
;; @param (line-type 8) {@ 4 8 16}
(define-cproc cv-fill-poly (img::<cv-arr> pts-vec::<vector> color::<cv-scalar>
                                          :optional (line-type::<fixnum> 8) (shift::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL img)
  (let* ([vec-size::int (SCM_VECTOR_SIZE pts-vec)]
         [pts::CvPoint** (cast CvPoint** (SCM_NEW_ARRAY _pvoid_t vec-size))]
         [npts::int* (SCM_NEW_ARRAY _int_t vec_size)])
    (dotimes [i vec-size]
      (if (SCM_VECTORP (SCM_VECTOR_ELEMENT pts-vec i))
        (let* ([inner-vec::ScmVector* (cast ScmVector* (SCM_VECTOR_ELEMENT pts-vec i))]
               [inner-vec-size::int (SCM_VECTOR_SIZE inner-vec)])
          (set! (aref npts i) inner-vec-size)
          (set! (aref pts i) (SCM_NEW_ARRAY CvPoint inner-vec-size))
          (dotimes [j inner-vec-size]
            (if (SCM_CVPOINT_P (SCM_VECTOR_ELEMENT inner-vec j))
              (set! (aref pts i j)
                (SCM_CVPOINT_DATA (SCM_VECTOR_ELEMENT inner-vec j)))
              (Scm_Error "CvPoint required, but got %S" (SCM_VECTOR_ELEMENT inner-vec j)))))
        (Scm_Error "vector required, but got %S" (SCM_VECTOR_ELEMENT pts-vec i))))
    (cvFillPoly img pts npts vec-size color line-type shift)))

;;;;;
;; Draws one or more polygonal curves 
;; @param pts-vec {@ <vector>_of_<vector>_of_<cv-point>}
;; @param (thickness 1) {@ -1 <integer>}
;; @param (line-type 8) {@ 4 8 16}
(define-cproc cv-poly-line (img::<cv-arr> pts-vec::<vector> 
                                          is-closed::<boolean> color::<cv-scalar>
                                          :optional (thickness::<fixnum> 1) (line-type::<fixnum> 8) (shift::<fixnum> 0)) ::<void>
  (ENSURE_NOT_NULL img)
  (let* ([vec-size::int (SCM_VECTOR_SIZE pts-vec)]
         [pts::CvPoint** (cast CvPoint** (SCM_NEW_ARRAY _pvoid_t vec-size))]
         [npts::int* (SCM_NEW_ARRAY _int_t vec_size)])
    (dotimes [i vec-size]
      (if (SCM_VECTORP (SCM_VECTOR_ELEMENT pts-vec i))
        (let* ([inner-vec::ScmVector* (cast ScmVector* (SCM_VECTOR_ELEMENT pts-vec i))]
               [inner-vec-size::int (SCM_VECTOR_SIZE inner-vec)])
          (set! (aref npts i) inner-vec-size)
          (set! (aref pts i) (SCM_NEW_ARRAY CvPoint inner-vec-size))
          (dotimes [j inner-vec-size]
            (if (SCM_CVPOINT_P (SCM_VECTOR_ELEMENT inner-vec j))
              (set! (aref pts i j)
                (SCM_CVPOINT_DATA (SCM_VECTOR_ELEMENT inner-vec j)))
              (Scm_Error "CvPoint required, but got %S" (SCM_VECTOR_ELEMENT inner-vec j)))))
        (Scm_Error "vector required, but got %S" (SCM_VECTOR_ELEMENT pts-vec i))))
    (cvPolyLine img pts npts vec-size is-closed color thickness line-type shift)))


;;not support
;;cvDrawRect
;;cvDrawLine
;;cvDrawCircle
;;cvDrawEllipse
;;cvDrawPolyLine

;;;;;
;; Clips the line segment connecting *pt1 and *pt2
;; by the rectangular window
;; (0<=x<img_size.width, 0<=y<img_size.height).
(define-cproc cv-clip-line (img-size::<cv-size> pt1::<cv-point> pt2::<cv-point>) ::<boolean>
  (let* ([pt1-tmp::CvPoint pt1]
         [pt2-tmp::CvPoint pt2])
    (result (cvClipLine img-size (& pt1-tmp) (& pt2-tmp)))))

;;;;;
;; Initializes line iterator. Initially, line_iterator->ptr will point
;; to pt1 (or pt2, see left-to-right description) location in the image.
;; @return Returns the number of pixels on the line between the ending points.
(define-cproc cv-init-line-iterator (image::<cv-arr> pt1::<cv-point> pt2::<cv-point>
                                                     :optional (connectivity::<fixnum> 8) (left-to-right::<boolean> #f))
  ::(<int> <cv-line-iterator>)
  (ENSURE_NOT_NULL image)
  (let* ([it::CvLineIterator* (SCM_NEW CvLineIterator)])
    (result (cvInitLineIterator image pt1 pt2 it connectivity left-to-right)
            it)))

;;;;;
;; Moves iterator to the next line point
(define-cproc cv-next-line-point (line-iterator::<cv-line-iterator>) ::<void>
  (CV_NEXT_LINE_POINT (* line-iterator)))

(define-cproc cv-get-byte-line-iterator (line-iterator::<cv-line-iterator>
                                          offset::<fixnum>) ::<uint8>
  (result (* (+ (-> line-iterator ptr) offset))))


;;----------------
;; Constants
;;
(define-enum CV_FONT_HERSHEY_SIMPLEX)
(define-enum CV_FONT_HERSHEY_PLAIN)
(define-enum CV_FONT_HERSHEY_DUPLEX)
(define-enum CV_FONT_HERSHEY_COMPLEX)
(define-enum CV_FONT_HERSHEY_TRIPLEX)
(define-enum CV_FONT_HERSHEY_COMPLEX_SMALL)
(define-enum CV_FONT_HERSHEY_SCRIPT_SIMPLEX)
(define-enum CV_FONT_HERSHEY_SCRIPT_COMPLEX)

(define-enum CV_FONT_ITALIC)
(define-enum CV_FONT_VECTOR0)

;;TODO modify function name
;;;;;
;; Initializes font structure used further in cv-put-text
(define-cproc make-cv-font (font-face::<fixnum> hscale::<double> vscale::<double>
                                             :optional (shear::<double> 0.0) (thickness::<fixnum> 1) (line-type::<fixnum> 8)) ::<cv-font>
  (let* ([font::CvFont* (SCM_NEW CvFont)])
    (cvInitFont font font-face hscale vscale shear thickness line-type)
    (result font)))

;;;;;
;; Initializes font structure used further in cv-put-text
(define-cproc cv-font (scale::<double>
                        :optional (thickness::<fixnum> 1)) ::<cv-font>
  (let* ([font::CvFont* (SCM_NEW CvFont)])
    (cvInitFont font CV_FONT_HERSHEY_PLAIN scale scale 0 thickness CV_AA)
    (result font)))

;;;;;
;; Renders text stroke with specified font and color at specified location.
;; @param org {@ <cv-point>}
(define-cproc cv-put-text (img::<cv-arr> text::<const-cstring> org::<cv-point>
                                         font::<cv-font> color::<cv-scalar>) ::<void>
  (ENSURE_NOT_NULL img)
  (cvPutText img text org font color))

;;;;;
;; Calculates bounding box of text stroke (useful for alignment)
;; @return {values <cv-size> baseline}
(define-cproc cv-get-text-size (text::<const-cstring> font::<cv-font>) ::(<cv-size> <fixnum>)
  (let* ([size::CvSize]
         [baseline::int])
    (cvGetTextSize text font (& size) (& baseline))
    (result size baseline)))

;;;;;
;; Unpacks color value, if arrtype is CV_8UC?, <color> is treated as
;; packed color value, otherwise the first channels (depending on arrtype)
;; of destination scalar are set to the same value = <color>
(define-cproc cv-color-to-scalar (packed-color::<double> arrtype::<int>) ::<cv-scalar>
  (result (cvColorToScalar packed-color arrtype)))

;;;;;
;; Returns the polygon points which make up the given ellipse.  
;; The ellipse is define by the box of size 'axes' rotated 'angle' around the 'center'.
;; A partial sweep of the ellipse arc can be done by spcifying arc_start and arc_end to be something other than 0 and 360, respectively.
;; @param center {@<cv-point>}
;; @param axes {@<cv-size>}
;; @return The total number of points.
(define-cproc cv-ellipse-2-poly (center::<cv-point> axes::<cv-size> angle::<fixnum>
                                                    arc-start::<fixnum> arc-end::<fixnum> delta::<fixnum>) :: <vector>
  (let* ([nb-pts::int (cvCeil (+ (/ (- arc-end arc-start) (cast float delta)) 1))]
         [pts::CvPoint* (SCM_NEW_ARRAY CvPoint nb-pts)])
    (set! nb-pts (cvEllipse2Poly center axes angle arc-start arc-end pts delta))
    (let* ([pts-vec::ScmVector* (cast ScmVector* (Scm_MakeVector nb-pts SCM_UNDEFINED))])
      (dotimes [i nb-pts]
        (set! (SCM_VECTOR_ELEMENT pts-vec i) (SCM_MAKE_CVPOINT (aref pts i))))
      (result pts-vec))))

;;;;;
;; Draws contour outlines or filled interiors on the image
;; @param ((offset (c "SCM_UNDEFINED")) >> (offset c:null))
(define-cproc cv-draw-contours (img::<cv-arr> contour::<cv-seq> external-color::<cv-scalar> 
                                              hole-color::<cv-scalar> max-level::<fixnum>
                                              :optional (thickness::<fixnum> 1) (line-type::<fixnum> 8)
                                              (offset (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL img)
  (let* ([offset-obj::CvPoint])
    (undef-or-obj offset offset-obj <cv-point> (cvPoint 0 0))
    (cvDrawContours img contour external-color hole-color
                    max-level thickness line-type offset-obj)))

;;;;;
;; Does look-up transformation. Elements of the source array
;; (that should be 8uC1 or 8sC1) are used as indexes in lutarr 256-element table
(define-cproc cv-lut (src::<cv-arr> dst::<cv-arr> lut::<top>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cond
    [(is-type? lut <cv-arr>)
     (ENSURE_NOT_NULL (unboxing lut <cv-arr>))
     (cvLUT src dst (unboxing lut <cv-arr>))]
    [(is-type? lut <uvector>)
     (unless (== 256 (SCM_UVECTOR_SIZE lut))
       (Scm_Error "lut length must be 256."))
     (let* ([type :: int]
            [mat :: CvMat])
       (cond
         [(is-type? lut <s8vector>)(set! type CV_8SC1)]
         [(is-type? lut <u8vector>)(set! type CV_8UC1)]
         [(is-type? lut <s16vector>)(set! type CV_16SC1)]
         [(is-type? lut <u16vector>)(set! type CV_16UC1)]
         [(is-type? lut <s32vector>)(set! type CV_32SC1)]
         [(is-type? lut <f32vector>)(set! type CV_32FC1)]
         [(is-type? lut <f64vector>)(set! type CV_64FC1)]
         [else (Scm_Error "unsupport uvector type.")])
       (set! mat (cvMat 256 1 type (SCM_UVECTOR_ELEMENTS lut)))
       (cvLUT src dst (& mat)))]
    [else (Scm_Error "<cv-arr> or <uvector> required, but got %S." lut)]))


;;--------------
;;Adding own types
;;--------------

;;simple API for reading/writing data

;;;;;
;; @param ((name (c "SCM_UNDEFINED")) >> (name c:null))
;; @param ((comment (c "SCM_UNDEFINED")) >> (comment c:null))
(define-cproc cv-save (filename::<const-cstring> 
                        obj::<top>
                        :optional
                        (name (c "SCM_UNDEFINED"))
                        (comment (c "SCM_UNDEFINED"))) :: <void>
  (let* ([name-obj::(const char*)]
         [comment-obj::(const char*)])
    (undef-or-obj-null-check name name-obj <const-cstring>)
    (undef-or-obj-null-check comment comment-obj <const-cstring>)
    (cond
      [(SCM_ISA obj (& Scm_CvObjectClass))
       (ENSURE_NOT_NULL (unboxing obj <cv-object>))
       (cvSave filename (unboxing obj <cv-object>)
               name-obj comment-obj (cvAttrList NULL NULL))]
      [else (Scm_Error "Invalid object %S." obj)])))

;;;;;
;; @param ((storage (c "SCM_UNDEFINED")) >> (storage c:null))
;; @param ((name (c "SCM_UNDEFINED")) >> (name c:null))
;; @param ((real-name (c "SCM_UNDEFINED")) >> (real-name c:null))
(define-cproc cv-load (filename::<const-cstring> 
                        :optional
                        (storage (c "SCM_UNDEFINED"))
                        (name (c "SCM_UNDEFINED"))
                        (real-name (c "SCM_UNDEFINED"))) :: <cv-object>
  (let* ([storage-obj::CvMemStorage*]
         [name-obj::(const char*)]
         [real-name-obj::char** NULL])
    (undef-or-obj-null-check storage storage-obj <cv-mem-storage>)
    (undef-or-obj-null-check name name-obj <const-cstring>)
    ;;TODO
    ;(undef-or-obj real-name real-name-obj <const-cstring> NULL)
    (let* ([obj::void* (cvLoad filename storage-obj name-obj 
                               (cast (const char**) real-name-obj))])
      (when (zero? obj)
        (raise-cv-error cv-load "load failure"))
      (result obj))))

(define-cproc cv-release (obj::<cv-object>)
  (when obj
    (cvRelease obj)
    (set! (SCM_CVOBJECT_DATA obj-scm) 0)))

"
typedef struct cast_proc_node {
  t_cast_proc proc;
  struct cast_proc_node* next;
}cast_proc_node;

cast_proc_node* cast_proc_list = NULL;

void register_cast_proc(t_cast_proc proc)
{
  cast_proc_node* node = SCM_NEW(cast_proc_node);
  node->proc = proc;
  node->next = cast_proc_list;

  cast_proc_list = node;
}

static ScmObj forEachCastProcList(ScmClass* to_class, ScmObj obj)
{
  cast_proc_node* node;
  for(node = cast_proc_list; node; node = node->next)
  {
    ScmObj ret = (*(node->proc))(to_class, obj);

    if(ret)
    {
      return ret;
    }
  }

  return NULL;
}
"
(define-cise-stmt (cv-cast-obj-setter src type)
  `(set! ,src (unboxing object <cv-struct>)))

;;;;;
;; type cast <cv-object> instance to 'to-class' class instance.
(define-cproc cv-cast (to-class::<class> object::<top>) :: <top>
  (let* ([ret::ScmObj (forEachCastProcList to-class object)])
    (when ret
      (return ret)))
  (cond
    [(SCM_ISA object SCM_CLASS_CVOBJECT)
     (when (Scm_SubtypeP to-class SCM_CLASS_CVOBJECT) 
        (let* ([allocator::t_allocator (allocator_getter to-class)])
          (when allocator
            (return (allocator (unboxing object <cv-object>))))))]
    [(SCM_ISA object SCM_CLASS_CVSTRUCT)
     (when (Scm_SubtypeP to-class SCM_CLASS_CVSTRUCT)
       (let* ([src-core-size::int (-> (Scm_ClassOf object) coreSize)]
              [dst-core-size::int (@ to-class->coreSize)])
         (when (<= dst-core-size src-core-size)
           (object-cast to-class dst-core-size cv-cast-obj-setter))))])
  (Scm_Error "invalid cast error.To %S" object to-class))

;; end:
