;;;
;;; cv_imgproclib.stub
;;;
;;; MIT License
;;; Copyright 2011-2012 aharisu
;;; All rights reserved.
;;;
;;; Permission is hereby granted, free of charge, to any person obtaining a copy
;;; of this software and associated documentation files (the "Software"), to deal
;;; in the Software without restriction, including without limitation the rights
;;; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;;; copies of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be included in all
;;; copies or substantial portions of the Software.
;;;
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;;; SOFTWARE.
;;;
;;;
;;; aharisu
;;; foo.yobina@gmail.com
;;;

"

#include \"gauche_cv_imgproc.h\"
#include <opencv2/imgproc/imgproc_c.h>

#include \"../core_type.gen.h\"
#include \"imgproc_type.gen.h\"

typedef void* _pvoid_t;
typedef unsigned char _char_t;
typedef signed char _schar_t;
typedef signed short _short_t;
typedef unsigned short _ushort_t;
typedef int _int_t;
typedef unsigned int _uint_t;
typedef float _float_t;
typedef double _double_t;

"

(include "imgproc_type.gen.stub.header")
(include "../cv_type.stub.header")
(include "../core_type.gen.stub.header")
(include "../macro.stub.header")

;;*************Background statistics accumulation*********
;;;;;
;; Adds image to accumulator
;; @param ((mask-obj (c "SCM_UNDEFINED")) >> (mask c:null))
;; {@ c:null <cv-arr>}
(define-cproc cv-acc (image::<cv-arr> sum::<cv-arr>
                                      :optional (mask-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL image)
  (ENSURE_NOT_NULL sum)
  (let* ([mask::CvArr*])
    (undef-or-cvarr mask-obj mask)
    (cvAcc image sum mask)))

;;;;;
;; Adds squared image to accumulator
;; @param ((mask-obj (c "SCM_UNDEFINED")) >> (mask c:null))
;; {@ c:null <cv-arr>}
(define-cproc cv-square-acc (image::<cv-arr> sqsum::<cv-arr>
                                             :optional (mask-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL image)
  (ENSURE_NOT_NULL sqsum)
  (let* ([mask::CvArr*])
    (undef-or-cvarr mask-obj mask)
    (cvSquareAcc image sqsum mask)))

;;;;;
;; Adds a product of two images to accumulator
;; @param ((mask-obj (c "SCM_UNDEFINED")) >> (mask c:null))
;; {@ c:null <cv-arr>}
(define-cproc cv-multiply-acc (image1::<cv-arr> image2::<cv-arr> acc::<cv-arr>
                                                :optional (mask-obj (c "SCM_UNDEFINED"))) ::<void> 
  (ENSURE_NOT_NULL image1)
  (ENSURE_NOT_NULL image2)
  (ENSURE_NOT_NULL acc)
  (let* ([mask::CvArr*])
    (undef-or-cvarr mask-obj mask)
    (cvMultiplyAcc image1 image2 acc mask)))

;;;;;
;; Adds image to accumulator with weights: acc = acc*(1-alpha) + image*alpha
;; @param ((mask-obj (c "SCM_UNDEFINED")) >> (mask c:null))
;; {@ c:null <cv-arr>}
(define-cproc cv-running-ave (image::<cv-arr> acc::<cv-arr> alpha::<real>
                                              :optional (mask-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL image)
  (ENSURE_NOT_NULL acc)
  (let* ([mask::CvArr*])
    (undef-or-cvarr mask-obj mask)
    (cvRunningAvg image acc alpha mask)))


;;******************
;;Image Processing
;;******************

;;;;;
;; Copies source 2D array inside of the larger destination array and
;; makes a border of the specified type (IPL_BORDER_*) around the copied area.
;; @param ((value-obj (c "SCM_UNDEFINED")) >> (value c:null))
;; {@ c:null <cv-scalar>}
(define-cproc cv-copy-make-border (src::<cv-arr> dst::<cv-arr> offset::<cv-point> bordertype::<fixnum>
                                                 :optional (value-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([value::CvScalar])
    (undef-or-obj value-obj value <cv-scalar> (cvScalarAll 0))
    (cvCopyMakeBorder src dst offset bordertype value)))


;;-------------
;;Constants
;;;;;
;; Image smooth methods
(define-enum CV_BLUR_NO_SCALE)
;;;;;
;; Image smooth methods
(define-enum CV_BLUR)
;;;;;
;; Image smooth methods
(define-enum CV_GAUSSIAN)
;;;;;
;; Image smooth methods
(define-enum CV_MEDIAN)
;;;;;
;; Image smooth methods
(define-enum CV_BILATERAL)
;;;;;
;; Smoothes array (removes noise)
(define-cproc cv-smooth (src::<cv-arr> dst::<cv-arr>
                                       :optional (smoothtype::<fixnum> 2) ;;smoothtype 2 is CV_GAUSSIAN
                                       (size1::<fixnum> 3) (size2::<fixnum> 0)
                                       (sigma1::<real> 0) (sigma2::<real> 0)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvSmooth src dst smoothtype size1 size2 sigma1 sigma2))

;;;;;
;; Convolves the image with the kernel
;; @param ((anchor-obj (c "SCM_UNDEFINED")) >> (anchor c:null))
;; {@ c:null <cv-point>}
(define-cproc cv-filter-2d (src::<cv-arr> dst::<cv-arr> kernel::<cv-mat>
                                          :optional (anchor-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([anchor::CvPoint])
    (undef-or-obj anchor-obj anchor <cv-point> (cvPoint -1 -1))
    (cvFilter2D src dst kernel anchor)))

;;;;;
;; Finds integral image: SUM(X,Y) = sum(x<X,y<Y)I(x,y)
;; @param ((sqsum-obj (c "SCM_UNDEFINED")) >> (sqsum c:null))
;; {@ c:null <cv-arr>}
;; @param ((tilted-sum-obj (c "SCM_UNDEFINED")) >> (tilted-sum c:null))
;; {@ c:null <cv-arr>}
(define-cproc cv-integral (image::<cv-arr> sum::<cv-arr>
                                           :optional (sqsum-obj (c "SCM_UNDEFINED")) (tilted-sum-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL image)
  (ENSURE_NOT_NULL sum)
  (let* ([sqsum::CvArr*]
         [tilted-sum::CvArr*])
    (undef-or-cvarr sqsum-obj sqsum)
    (undef-or-cvarr tilted-sum-obj tilted-sum)
    (cvIntegral image sum sqsum tilted-sum)))

;;;;;
;; Filters used in pyramid decomposition 
(define-enum CV_GAUSSIAN_5x5)

;;;;;
;; Smoothes the input image with gaussian kernel and then down-samples it.
;; dst_width = floor(src_width/2)[+1],
;; dst_height = floor(src_height/2)[+1]
(define-cproc cv-pyr-down (src::<cv-arr> dst::<cv-arr>
                                         :optional (filter::<fixnum> 7)) ::<void> ;;filter 7 is CV_GAUSSIAN_5x5
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvPyrDown src dst filter))

;;;;;
;; Up-samples image and smoothes the result with gaussian kernel.
;; dst_width = src_width*2,
;; dst_height = src_height*2
(define-cproc cv-pyr-up (src::<cv-arr> dst::<cv-arr>
                                       :optional (filter::<fixnum> 7)) ::<void> ;;filter 7 is CV_GAUSSIAN_5x5
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvPyrUp src dst filter))


;;not support
;;cvCreatePyramid
;;cvReleaseaPyramid

;;;;;
;; Splits color or grayscale image into multiple connected components
;; of nearly the same color/brightness using modification of Burt algorithm.
;; comp with contain a pointer to sequence <cv-seq>
;; of connected components <cv-connected-comp>
(define-cproc cv-pyr-segmentation (src::<iplimage> dst::<iplimage> storage::<cv-mem-storage>
                                                   level::<fixnum> threshold1::<real> threshold2::<real>) ::<cv-seq>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (ENSURE_NOT_NULL storage)
  (let* ([comp::CvSeq*])
    (cvPyrSegmentation src dst storage (& comp) level threshold1 threshold2)
    (result comp)))

;;;;;
;; Filters image using meanshift algorithm
;; @param ((termcrit-obj (c "SCM_UNDEFINED")) >> (termcrit c:null))
;; {@ c:null <cv-term-criteria>}
(define-cproc cv-pyr-mean-shift-filtering (src::<cv-arr> dst::<cv-arr>
                                                         sp::<real> sr::<real>
                                                         :optional (max-level::<fixnum> 1) (termcrit-obj (c "SCM_UNDEFINED"))) ::<void>
  (let* ([termcrit::CvTermCriteria])
    (undef-or-obj termcrit-obj termcrit <cv-term-criteria> (cvTermCriteria 3 5 1)) ;;3 is CV_TERMCRIT_ITER + CV_TERMCRIT_EPS
    (cvPyrMeanShiftFiltering src dst sp sr max-level termcrit)))

;;;;;
;; Segments image using seed "markers"
(define-cproc cv-watershed (image::<cv-arr> markers::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL image)
  (ENSURE_NOT_NULL markers)
  (cvWatershed image markers))

;;;;;
;; Inpainting algorithms
(define-enum CV_INPAINT_NS)
;;;;;
;; Inpainting algorithms
(define-enum CV_INPAINT_TELEA)

;;;;;
;; Inpaints the selected region in the image
(define-cproc cv-inpaint (src::<cv-arr> inpaint_mask::<cv-arr> dst::<cv-arr>
                                        inpaint-range::<real> flags::<fixnum>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL inpaint_mask)
  (ENSURE_NOT_NULL dst)
  (cvInpaint src inpaint_mask dst inpaint-range flags))

;;;;;
;; Calculates an image derivative using generalized Sobel
;; Scharr can be used only for the first dx or dy derivative
;; @param (aperture-size 3) {@ -1 1 3 5 7 etc...}
(define-cproc cv-sobel (src::<cv-arr> dst::<cv-arr> xorder::<fixnum> yorder::<fixnum>
                                      :optional (aperture-size::<fixnum> 3)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvSobel src dst xorder yorder aperture-size))

;;;;;
;; Calculates the image Laplacian: (d2/dx + d2/dy)I
(define-cproc cv-laplace (src::<cv-arr> dst::<cv-arr>
                                        :optional (aperture-size::<fixnum> 3)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvLaplace src dst aperture-size))

;;-------------
;;Constants
(define-enum CV_BGR2BGRA)
(define-enum CV_RGB2RGBA)
(define-enum CV_BGRA2BGR)
(define-enum CV_RGBA2RGB)
(define-enum CV_BGR2RGBA)
(define-enum CV_RGB2BGRA)
(define-enum CV_RGBA2BGR)
(define-enum CV_BGRA2RGB)
(define-enum CV_BGR2RGB)
(define-enum CV_RGB2BGR)
(define-enum CV_BGRA2RGBA)
(define-enum CV_RGBA2BGRA)
(define-enum CV_BGR2GRAY)
(define-enum CV_RGB2GRAY)
(define-enum CV_GRAY2BGR)
(define-enum CV_GRAY2RGB)
(define-enum CV_GRAY2BGRA)
(define-enum CV_GRAY2RGBA)
(define-enum CV_BGRA2GRAY)
(define-enum CV_RGBA2GRAY)
(define-enum CV_BGR2BGR565)
(define-enum CV_RGB2BGR565)
(define-enum CV_BGR5652BGR)
(define-enum CV_BGR5652RGB)
(define-enum CV_BGRA2BGR565)
(define-enum CV_RGBA2BGR565)
(define-enum CV_BGR5652BGRA)
(define-enum CV_BGR5652RGBA)
(define-enum CV_GRAY2BGR565)
(define-enum CV_BGR5652GRAY)
(define-enum CV_BGR2BGR555)
(define-enum CV_RGB2BGR555)
(define-enum CV_BGR5552BGR)
(define-enum CV_BGR5552RGB)
(define-enum CV_BGRA2BGR555)
(define-enum CV_RGBA2BGR555)
(define-enum CV_BGR5552BGRA)
(define-enum CV_BGR5552RGBA)
(define-enum CV_GRAY2BGR555)
(define-enum CV_BGR5552GRAY)
(define-enum CV_BGR2XYZ)
(define-enum CV_RGB2XYZ)
(define-enum CV_XYZ2BGR)
(define-enum CV_XYZ2RGB)
(define-enum CV_BGR2YCrCb)
(define-enum CV_RGB2YCrCb)
(define-enum CV_YCrCb2BGR)
(define-enum CV_YCrCb2RGB)
(define-enum CV_BGR2HSV)
(define-enum CV_RGB2HSV)
(define-enum CV_BGR2Lab)
(define-enum CV_RGB2Lab)
(define-enum CV_BayerBG2BGR)
(define-enum CV_BayerGB2BGR)
(define-enum CV_BayerRG2BGR)
(define-enum CV_BayerGR2BGR)
(define-enum CV_BayerBG2RGB)
(define-enum CV_BayerGB2RGB)
(define-enum CV_BayerRG2RGB)
(define-enum CV_BayerGR2RGB)
(define-enum CV_BGR2Luv)
(define-enum CV_RGB2Luv)
(define-enum CV_BGR2HLS)
(define-enum CV_RGB2HLS)
(define-enum CV_HSV2BGR)
(define-enum CV_HSV2RGB)
(define-enum CV_Lab2BGR)
(define-enum CV_Lab2RGB)
(define-enum CV_Luv2BGR)
(define-enum CV_Luv2RGB)
(define-enum CV_HLS2BGR)
(define-enum CV_HLS2RGB)
(define-enum CV_BayerBG2BGR_VNG)
(define-enum CV_BayerGB2BGR_VNG)
(define-enum CV_BayerRG2BGR_VNG)
(define-enum CV_BayerGR2BGR_VNG)
(define-enum CV_BayerBG2RGB_VNG)
(define-enum CV_BayerGB2RGB_VNG)
(define-enum CV_BayerRG2RGB_VNG)
(define-enum CV_BayerGR2RGB_VNG)
(define-enum CV_BGR2HSV_FULL)
(define-enum CV_RGB2HSV_FULL)
(define-enum CV_BGR2HLS_FULL)
(define-enum CV_RGB2HLS_FULL)
(define-enum CV_HSV2BGR_FULL)
(define-enum CV_HSV2RGB_FULL)
(define-enum CV_HLS2BGR_FULL)
(define-enum CV_HLS2RGB_FULL)
(define-enum CV_LBGR2Lab)
(define-enum CV_LRGB2Lab)
(define-enum CV_LBGR2Luv)
(define-enum CV_LRGB2Luv)
(define-enum CV_Lab2LBGR)
(define-enum CV_Lab2LRGB)
(define-enum CV_Luv2LBGR)
(define-enum CV_Luv2LRGB)
(define-enum CV_BGR2YUV)
(define-enum CV_RGB2YUV)
(define-enum CV_YUV2BGR)
(define-enum CV_YUV2RGB)
;;;;;
;; Converts input array pixels from one color space to another
(define-cproc cv-cvt-color (src::<cv-arr> dst::<cv-arr> code::<fixnum>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvCvtColor src dst code))

;;-------------
;;Constants
(define-enum CV_INTER_NN)
(define-enum CV_INTER_LINEAR)
(define-enum CV_INTER_CUBIC)
(define-enum CV_INTER_AREA)
(define-enum CV_INTER_LANCZOS4)
(define-cproc cv-resize (src::<cv-arr> dst::<cv-arr>
                                       :optional (interpolation::<fixnum> 1)) ::<void> ;;interpolation 1 is CV_INTER_LINEAR
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvResize src dst interpolation))

;;-------------
;;Constants
(define-enum CV_WARP_FILL_OUTLIERS)
(define-enum CV_WARP_INVERSE_MAP)
;;;;;
;; Warps image with affine transform
;; @param ((fillval-obj (c "SCM_UNDEFINED")) >> (fillval c:null))
;; {@ c:null <cv-scalar>}
(define-cproc cv-warp-affine (src::<cv-arr> dst::<cv-arr> map-matrix::<cv-mat>
                                            :optional (flags::<fixnum> 9) ;; 9 is CV_INTER_LINEAR + CV_WARP_FILL_OUTLIERS
                                            (fillval-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([fillval::CvScalar])
    (undef-or-obj fillval-obj fillval <cv-scalar> (cvScalarAll 0))
    (cvWarpAffine src dst map-matrix flags fillval)))

;;;;;
;; Computes affine transform matrix for mapping src[i] to dst[i] (i=0,1,2)
;; @param src {@ <list of <cv-point-2d32f>> <vector of <cv-point-2d32f>>}
;; @param dst {@ <list of <cv-point-2d32f>> <vector of <cv-point-2d32f>>}
;; @param ((map-matrix (c "SCM_UNDEFINED")) >> (map c:null))
;; {@ c:null <cv-mat>}
;; @return <cv-mat> or #undef
(define-cproc cv-get-affine-transform (src::<top> dst::<top>
                                                  :optional (map-matrix (c "SCM_UNDEFINED"))) ::<top>
  (let* ([src-ary::(.array CvPoint2D32f (3))]
         [dst-ary::(.array CvPoint2D32f (3))]
         [map :: CvMat*])
    (cond
      [(is-type? src <list>)
       (when (!= (Scm_Length src) 3)
         (Scm_Error "src requires length 3, but got %d" (Scm_Length src)))
       (dotimes [i 3]
         (assign-obj (aref src-ary i) (SCM_CAR src) <cv-point-2d32f>)
        (set! src (SCM_CDR src)))]
      [(is-type? src <vector>)
       (when (!= (SCM_VECTOR_SIZE src) 3)
         (Scm_Error "src requires length 3, but got %d" (SCM_VECTOR_SIZE src)))
       (dotimes [i 3]
         (assign-obj (aref src-ary i) (SCM_VECTOR_ELEMENT src i) <cv-point-2d32f>))]
      [else (Scm_Error "<list> or <vector> required, but got %S." src)])
    (cond
      [(is-type? dst <list>)
       (when (!= (Scm_Length dst) 3)
         (Scm_Error "dst requires length 3, but got %d" (Scm_Length dst)))
       (dotimes [i 3]
         (assign-obj (aref dst-ary i) (SCM_CAR dst) <cv-point-2d32f>)
        (set! dst (SCM_CDR dst)))]
      [(is-type? dst <vector>)
       (when (!= (SCM_VECTOR_SIZE dst) 3)
         (Scm_Error "dst requires length 3, but got %d" (SCM_VECTOR_SIZE dst)))
       (dotimes [i 3]
         (assign-obj (aref dst-ary i) (SCM_VECTOR_ELEMENT dst i) <cv-point-2d32f>))]
      [else (Scm_Error "<list> or <vector> required, but got %S." dst)])
    (cond
      [(undefined? map-matrix) (set! map (cvCreateMat 2 3 CV_32FC1))]
      [(is-type? map-matrix <cv-mat>) (set! map (unboxing map-matrix <cv-mat>))]
      [else (Scm_Error "<cv-mat> or c:null required, but got %S." map-matrix)])
    (cvGetAffineTransform src-ary dst-ary map)
    (if (undefined? map-matrix)
      (result (boxing map <cv-mat>))
      (result SCM_UNDEFINED))))

;;;;;
;; Computes rotation_matrix matrix
(define-cproc cv-2d-rotation-matrix (center::<cv-point-2d32f> angle::<real> scale::<real> map-matrix::<cv-mat>) ::<void>
  (cv2DRotationMatrix center angle scale map-matrix))

;;;;;
;; Warps image with perspective (projective) transform
;; @param ((fillval-obj (c "SCM_UNDEFINED")) >> (fillval c:null))
;; {@ c:null <cv-scalar>}
(define-cproc cv-warp-perspective (src::<cv-arr> dst::<cv-arr> map-matrix::<cv-mat>
                                                 :optional (flags::<fixnum> 9) ;;flags 9 is CV_INTER_LINEAR + CV_WARP_FILL_OUTLIERS
                                                 (fillval-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (ENSURE_NOT_NULL map-matrix)
  (let* ([fillval::CvScalar])
    (undef-or-obj fillval-obj fillval <cv-scalar> (cvScalarAll 0))
    (cvWarpPerspective src dst map-matrix flags fillval)))

;;;;;
;; Computes perspective transform matrix for mapping src[i] to dst[i] (i=0,1,2,3)
;; @param src {@ <list of <cv-point-2d32f>> <vector of <cv-point-2d32f>>}
;; @param dst {@ <list of <cv-point-2d32f>> <vector of <cv-point-2d32f>>}
;; @param ((map-matrix (c "SCM_UNDEFINED")) >> (map c:null))
;; {@ c:null <cv-mat>}
;; @return <cv-mat> or #undef
(define-cproc cv-get-perspective-transform (src::<top> dst::<top>
                                            :optional (map-matrix (c "SCM_UNDEFINED"))) :: <top>
  (let* ([src-ary::(.array CvPoint2D32f (4))]
         [dst-ary::(.array CvPoint2D32f (4))]
         [map :: CvMat*]
         [create-mat? :: int 0])
    (cond
      [(is-type? src <list>)
       (when (!= (Scm_Length src) 4)
         (Scm_Error "src requires length 4, but got %d" (Scm_Length src)))
       (dotimes [i 4]
         (assign-obj (aref src-ary i) (SCM_CAR src) <cv-point-2d32f>)
        (set! src (SCM_CDR src)))]
      [(is-type? src <vector>)
       (when (!= (SCM_VECTOR_SIZE src) 4)
         (Scm_Error "src requires length 4, but got %d" (SCM_VECTOR_SIZE src)))
       (dotimes [i 4]
         (assign-obj (aref src-ary i) (SCM_VECTOR_ELEMENT src i) <cv-point-2d32f>))]
      [else (Scm_Error "<list> or <vector> required, but got %S." src)])
    (cond
      [(is-type? dst <list>)
       (when (!= (Scm_Length dst) 4)
         (Scm_Error "dst requires length 4, but got %d" (Scm_Length dst)))
       (dotimes [i 4]
         (assign-obj (aref dst-ary i) (SCM_CAR dst) <cv-point-2d32f>)
        (set! dst (SCM_CDR dst)))]
      [(is-type? dst <vector>)
       (when (!= (SCM_VECTOR_SIZE dst) 4)
         (Scm_Error "dst requires length 4, but got %d" (SCM_VECTOR_SIZE dst)))
       (dotimes [i 4]
         (assign-obj (aref dst-ary i) (SCM_VECTOR_ELEMENT dst i) <cv-point-2d32f>))]
      [else (Scm_Error "<list> or <vector> required, but got %S." dst)])
    (cond
      [(undefined? map-matrix)
       (set! map (cvCreateMat 3 3 CV_32FC1))
       (set! create-mat? 1)]
      [(is-type? map-matrix <cv-mat>)
       (set! map (unboxing map-matrix <cv-mat>))
       (ENSURE_NOT_NULL map)]
      [else (Scm_Error "CvMat or c:null required, but got %S" map-matrix)])
    (cvGetPerspectiveTransform src-ary dst-ary map)
    (if create-mat?
      (result (boxing map <cv-mat>))
      (return map-matrix-scm))))

;;;;;
;; Performs generic geometric transformation using the specified coordinate maps
;; @param ((fillval-obj (c "SCM_UNDEFINED")) >> (fillval c:null))
;; {@ c:null <cv-scalar>}
(define-cproc cv-remap (src::<cv-arr> dst::<cv-arr> mapx::<cv-arr> mapy::<cv-arr>
                                      :optional (flags::<fixnum> 9) ;;flags 9 is CV_INTER_LINEAR + CV_WARP_FILL_OUTLIERS
                                      (fillval-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (ENSURE_NOT_NULL mapx)
  (ENSURE_NOT_NULL mapy)
  (let* ([fillval::CvScalar])
    (undef-or-obj fillval-obj fillval <cv-scalar> (cvScalarAll 0))
    (cvRemap src dst mapx mapy flags fillval)))

;;;;;
;; Converts mapx & mapy from floating-point to integer formats for cvRemap
(define-cproc cv-convert-maps (mapx::<cv-arr> mapy::<cv-arr>
                                              mapxy::<cv-arr> mapalpha::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL mapx)
  (ENSURE_NOT_NULL mapy)
  (ENSURE_NOT_NULL mapxy)
  (ENSURE_NOT_NULL mapalpha)
  (cvConvertMaps mapx mapy mapxy mapalpha))

;;;;;
;; Performs forward or inverse log-polar image transform
(define-cproc cv-log-polar (src::<cv-arr> dst::<cv-arr>
                                          center::<cv-point-2d32f> m::<real>
                                          :optional (flags::<fixnum> 9)) ::<void> ;;flags 9 is CV_INTER_LINEAR + CV_WARP_FILL_OUTLIERS
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvLogPolar src dst center m flags))

;;;;;
;; Performs forward or inverse linear-polar image transform
(define-cproc cv-linear-polar (src::<cv-arr> dst::<cv-arr>
                                             center::<cv-point-2d32f> m::<real>
                                             :optional (flags::<fixnum> 9)) ::<void> ;;flags 9 is CV_INTER_LINEAR + CV_WARP_FILL_OUTLIERS
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvLinearPolar src dst center m flags))

;;;;;
;; Transforms the input image to compensate lens distortion
;; @param ((new-camera-matrix-obj (c "SCM_UNDEFINED")) >> (new-camera-matrix c:null))
;; {@ c:null <cv-mat>}
(define-cproc cv-undistort2 (src::<cv-arr> dst::<cv-arr>
                                           camera-matrix::<cv-mat> distortion-coeffs::<cv-mat>
                                           :optional (new-camera-matrix-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (ENSURE_NOT_NULL camera-matrix)
  (ENSURE_NOT_NULL distortion-coeffs)
  (let* ([new-camera-matrix::CvMat*])
    (undef-or-obj new-camera-matrix-obj new-camera-matrix <cv-mat> NULL)
    (cvUndistort2 src dst camera-matrix distortion-coeffs new-camera-matrix)))

;;;;;
;; Computes transformation map from intrinsic camera parameters that can used by cvRemap
(define-cproc cv-init-undistort-map (camera-matrix::<cv-mat> distortion-coeffs::<cv-mat>
                                                             mapx::<cv-arr> mapy::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL camera-matrix)
  (ENSURE_NOT_NULL distortion-coeffs)
  (ENSURE_NOT_NULL mapx)
  (ENSURE_NOT_NULL mapy)
  (cvInitUndistortMap camera-matrix distortion-coeffs mapx mapy))

;;;;;
;; Computes undistortion+rectification map for a head of stereo camera
(define-cproc cv-init-undistort-rectify-map (camera-matrix::<cv-mat> dist-coeffs::<cv-mat>
                                                                     r::<cv-mat> new-camera-matrix::<cv-mat>
                                                                     mapx::<cv-arr> mapy::<cv-arr>) ::<void>
  (ENSURE_NOT_NULL camera-matrix)
  (ENSURE_NOT_NULL dist-coeffs)
  (ENSURE_NOT_NULL r)
  (ENSURE_NOT_NULL new-camera-matrix)
  (ENSURE_NOT_NULL mapx)
  (ENSURE_NOT_NULL mapy)
  (cvInitUndistortRectifyMap camera-matrix dist-coeffs r new-camera-matrix mapx mapy))

;;;;;
;; Computes the original (undistorted) feature coordinates from the observed (distorted) coordinates
;; @param ((r-obj (c "SCM_UNDEFINED")) >> (r c:null))
;; {@ c:null <cv-mat>}
;; @param ((p-obj (c "SCM_UNDEFINED")) >> (p c:null))
;; {@ c:null <cv-mat>}
(define-cproc cv-undistort-points (src::<cv-mat> dst::<cv-mat>
                                                 camera-matrix::<cv-mat> dist-coeffs::<cv-mat>
                                                 :optional (r-obj (c "SCM_UNDEFINED")) (p-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (ENSURE_NOT_NULL camera-matrix)
  (ENSURE_NOT_NULL dist-coeffs)
  (let* ([r::CvMat*]
         [p::CvMat*])
    (undef-or-obj-null-check r-obj r <cv-mat>)
    (undef-or-obj-null-check p-obj p <cv-mat>)
    (cvUndistortPoints src dst camera-matrix dist-coeffs r p)))

;;-------------
;;Constants
(define-enum CV_SHAPE_RECT)
(define-enum CV_SHAPE_CROSS)
(define-enum CV_SHAPE_ELLIPSE)
(define-enum CV_SHAPE_CUSTOM)

(define-enum CV_MOP_ERODE)
(define-enum CV_MOP_DILATE)
(define-enum CV_MOP_OPEN)
(define-enum CV_MOP_CLOSE)
(define-enum CV_MOP_GRADIENT)
(define-enum CV_MOP_TOPHAT)
(define-enum CV_MOP_BLACKHAT)

;;;;;
;; creates structuring element used for morphological operations
;; @param ((values-obj (c "SCM_UNDEFINED")) >> (values c:null))
;; {@ c:null <list> <vector> <s32vector>}
(define-cproc cv-create-structuring-element-ex (cols::<fixnum> rows::<fixnum> anchor-x::<fixnum> anchor-y::<fixnum> shape::<fixnum>
                                                               :optional (values-obj (c "SCM_UNDEFINED"))) ::<iplconv-kernel>
  (let* ([values::int*]
         [len :: int (* cols rows)])
    (cond
      [(undefined? values-obj)(set! values NULL)]
      [(is-type? values-obj <list>)
       (when (!= shape CV_SHAPE_CUSTOM)
         (Scm_Error "shape != CV_SHAPE_CUSTOM"))
       (list-to-ary values-obj values len _int_t int-elem-assign)]
      [(is-type? values-obj <vector>)
       (set! len (SCM_VECTOR_SIZE values-obj))
       (vector-to-ary values-obj values _int_t int-elem-assign)]
      [(is-type? values-obj <s32vector>)
       (set! len (SCM_S32VECTOR_SIZE values-obj))
       (set! values (SCM_S32VECTOR_ELEMENTS values-obj))]
      [else (Scm_Error "<list> or <vector> or <s32vector> or c:null required, bug got %S" values-obj)])
    (unless (== len (* cols rows))
      (Scm_Error "values list length != cols * rows"))
    (result (cvCreateStructuringElementEx cols rows anchor-x anchor-y shape values))))

;;;;;
;; releases structuring element
(define-cproc cv-release-structuring-element (element::<iplconv-kernel>) ::<void>
  (if element
    (begin
      (cvReleaseStructuringElement (& element))
      (set! (-> (SCM_FOREIGN_POINTER element_scm) ptr) NULL))))

(define-cise-stmt (get-element element-obj element)
  (let* ([type (cgen-type-from-name '<iplconv-kernel>)])
    `(cond
       [(undefined? ,element-obj) (set! ,element NULL)]
       [(,(string->symbol (~ type'c-predicate)) ,element-obj) 
        (begin
          (set! ,element (,(string->symbol (~ type'unboxer)) ,element-obj))
          (ENSURE_NOT_NULL ,element))]
       [else (Scm_Error ,#`",(~ type'description) or c:null required, but got %S" ,element-obj)])))

;;;;;
;; erodes input image (applies minimum filter) one or more times.
;; If element pointer is c:null, 3x3 rectangular element is used
;; @param ((element-obj (c "SCM_UNDEFINED")) >> (element c:null))
;; {@ c:null <iplconv-kernel>}
(define-cproc cv-erode (src::<cv-arr> dst::<cv-arr>
                                      :optional (element-obj (c "SCM_UNDEFINED")) (iterations::<fixnum> 1)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([element::IplConvKernel*])
    (get-element element-obj element)
    (cvErode src dst element iterations)))

;;;;;
;; dilates input image (applies maximum filter) one or more times.
;; If element pointer is c:null, 3x3 rectangular element is used
;; @param ((element-obj (c "SCM_UNDEFINED")) >> (element c:null))
;; {@ c:null <iplconv-kernel>}
(define-cproc cv-dilate (src::<cv-arr> dst::<cv-arr>
                                       :optional (element-obj (c "SCM_UNDEFINED")) (iterations::<fixnum> 1)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([element::IplConvKernel*])
    (get-element element-obj element)
    (cvDilate src dst element iterations)))

;;;;;
;; Performs complex morphological transformation
(define-cproc cv-morphology-ex (src::<cv-arr> dst::<cv-arr> tmp::<cv-arr>
                                              element::<iplconv-kernel> operation::<fixnum>
                                              :optional (iterations::<fixnum> 1)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (ENSURE_NOT_NULL tmp)
  (cvMorphologyEx src dst tmp element operation iterations))


;;-----------------
;;CvMoments
;;
(define-cclass <cv-moments>
  :built-in :struct
  "ScmCvMoments" "Scm_CvMomentsClass"
  ()
  (;;slot
   )
  )

;;;;;
;; Calculates all spatial and central moments up to the 3rd order
(define-cproc cv-moments (arr::<cv-arr> 
                           :optional (binary?::<boolean> #f)) ::<cv-moments>
  (ENSURE_NOT_NULL arr)
  (let* ([moments::CvMoments])
    (cvMoments arr (& moments) binary?)
    (result moments)))

;;;;;;
;; Retrieve particular spatial central moments
(define-cproc cv-get-spatial-moment (moments::<cv-moments> x-order::<fixnum> y-order::<fixnum>) ::<real>
  (result (cvGetSpatialMoment (& moments) x-order y-order)))

;;;;;;
;; Retrieve particular central central moments
(define-cproc cv-get-central-moment (moments::<cv-moments> x-order::<fixnum> y-order::<fixnum>) ::<real>
  (result (cvGetCentralMoment (& moments) x-order y-order)))

;;;;;;
;; Retrieve particular normalized central moments
(define-cproc cv-get-normalized-central-moment (moments::<cv-moments> x-order::<fixnum> y-order::<fixnum>) ::<real>
  (result (cvGetNormalizedCentralMoment (& moments) x-order y-order)))

;;-----------------
;;CvHuMoments
;;
(define-cclass <cv-hu-moments>
  :built-in :struct
  "ScmCvHuMoments" "Scm_CvHuMomentsClass"
  ()
  (;;slot
   (hu1 :type <real>
        :setter #f)
   (hu2 :type <real>
        :setter #f)
   (hu3 :type <real>
        :setter #f)
   (hu4 :type <real>
        :setter #f)
   (hu5 :type <real>
        :setter #f)
   (hu6 :type <real>
        :setter #f)
   (hu7 :type <real>
        :setter #f)
   )
  )

;;;;;
;; Calculates 7 Hu's invariants from precalculated spatial and central moments
(define-cproc cv-get-hu-moments (moments::<cv-moments>) ::<cv-hu-moments>
  (let* ([hu-moments::CvHuMoments])
    (cvGetHuMoments (& moments) (& hu-moments))
    (result hu-moments)))


;;*************data sampling*********

"
static int _max(int x, int y)
{
return (x < y) ? y : x;
}
"

;;;;;
;; Fetches pixels that belong to the specified line segment and stores them to the buffer.
;; Returns the number of retrieved points.
(define-cproc cv-sample-line (image::<cv-arr> pt1::<cv-point> pt2::<cv-point>
                                              :optional (connectivity::<fixnum> 8)) ::<list>
  (ENSURE_NOT_NULL image)
  (let* ([size::int]
         [buffer::CvPoint*])
    (cond
      ;;calc buffer size
      [(== 4 connectivity)
       (set! size (+ (abs (- (ref pt2 x) (ref pt1 x))) (abs (- (ref pt2 y) (ref pt1 y))) 1))]
      [(== 8 connectivity)
       (set! size (_max (+ (abs (- (ref pt2 x) (ref pt1 x))) 1) (+ (abs (- (ref pt2 y) (ref pt1 y))) 1)))]
      [else (Scm_Error "connectivity requires 4 or 8, but got %d" connectivity)])
    (set! buffer  (SCM_MALLOC (* (sizeof CvPoint) size)))
    ;;call cvSampleLine
    (cvSampleLine image pt1 pt2 buffer connectivity)
    ;;array to list
    (let* ([list::ScmObj (Scm_MakeList size SCM_NIL)]
           [pair::ScmObj list])
      (dotimes [i size]
        (SCM_SET_CAR pair (Scm_MakeCvPoint (aref buffer i)))
        (set! pair (SCM_CDR pair)))
      (result list))))

;;;;;
;; Retrieves the rectangular image region with specified center from the input array.
;; dst(x,y) <- src(x + center.x - dst_width/2, y + center.y - dst_height/2).
;; Values of pixels with fractional coordinates are retrieved using bilinear interpolation.
(define-cproc cv-get-rect-sub-pix (src::<cv-arr> dst::<cv-arr> center::<cv-point-2d32f>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvGetRectSubPix src dst center))

;;;;;
;; Retrieves quadrangle from the input array.
;;  matrixarr = ( a11  a12 | b1 )   dst(x,y) <- src(A[x y]' + b)
;;              ( a21  a22 | b2 )   (bilinear interpolation is used to retrieve pixels
;;                                   with fractional coordinates)
(define-cproc cv-get-quadrangle-sub-pix (src::<cv-arr> dst::<cv-arr> map-matrix::<cv-mat>) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (ENSURE_NOT_NULL map-matrix)
  (cvGetQuadrangleSubPix src dst map-matrix))


;;-------------
;;Constants
(define-enum CV_TM_SQDIFF)
(define-enum CV_TM_SQDIFF_NORMED)
(define-enum CV_TM_CCORR)
(define-enum CV_TM_CCORR_NORMED)
(define-enum CV_TM_CCOEFF)
(define-enum CV_TM_CCOEFF_NORMED)
;;;;;
;; Measures similarity between template and overlapped windows in the source image
;; and fills the resultant image with the measurements
(define-cproc cv-match-template (image::<cv-arr> templ::<cv-arr>
                                                 result::<cv-arr> method::<fixnum>) ::<void>
  (ENSURE_NOT_NULL image)
  (ENSURE_NOT_NULL templ)
  (ENSURE_NOT_NULL result)
  (cvMatchTemplate image templ result method))


;;not support
;;cvCalcEMMD2



;;******************
;;Contours retrieving
;;******************


;;-------------
;;Constants
(define-enum CV_RETR_EXTERNAL)
(define-enum CV_RETR_LIST)
(define-enum CV_RETR_CCOMP)
(define-enum CV_RETR_TREE)

(define-enum CV_CHAIN_CODE)
(define-enum CV_CHAIN_APPROX_NONE)
(define-enum CV_CHAIN_APPROX_SIMPLE)
(define-enum CV_CHAIN_APPROX_TC89_L1)
(define-enum CV_CHAIN_APPROX_TC89_KCOS)
(define-enum CV_LINK_RUNS)

;;;;;
;; Retrieves outer and optionally inner boundaries of white (non-zero) connected
;; components in the black (zero) background
;; @param ((offset-obj (c "SCM_UNDEFINED")) >> (offset c:null))
;; {@ c:null <cv-point>}
(define-cproc cv-find-contours (image::<cv-arr> storage::<cv-mem-storage> 
                                                :optional (mode::<fixnum> 1) ;;mode 1 is CV_RETR_LIST
                                                (method::<fixnum> 2) ;;method 2 is CV_CHAIN_APPROX_SIMPLE
                                                (offset-obj (c "SCM_UNDEFINED"))) ::<top>
  (ENSURE_NOT_NULL image)
  (ENSURE_NOT_NULL storage)
  (let* ([offset::CvPoint]
         [header-size::int (?: (== method CV_CHAIN_CODE)
                               (sizeof CvChain) (sizeof CvContour))]
         [seq::CvSeq*])
    (undef-or-obj offset-obj offset <cv-point> (cvPoint 0 0))
    (cvFindContours image storage (& seq) header-size mode method offset)
    (if seq
      (result (boxing seq <cv-seq>))
      (result (boxing 0 <boolean>)))))

;;;;;
;; Initalizes contour retrieving process.
;; Calls cvStartFindContours.
;; Calls cvFindNextContour until null pointer is returned or some other condition becomes true.
;; Calls cvEndFindContours at the end.
;; @param ((offset-obj (c "SCM_UNDEFINED")) >> (offset c:null))
;; {@ c:null <cv-point>}
(define-cproc cv-start-find-contours (image::<cv-arr> storage::<cv-mem-storage>
                                                      :optional (mode::<fixnum> 1) ;;mode 1 is CV_RETR_LIST
                                                      (method::<fixnum> 2) ;;method 2 is CV_CHAIN_APPROX_SIMPLE
                                                      (offset-obj (c "SCM_UNDEFINED"))) ::<cv-contour-scanner>
  (ENSURE_NOT_NULL image)
  (ENSURE_NOT_NULL storage)
  (let* ([offset::CvPoint]
         [header-size::int (?: (== method CV_CHAIN_CODE)
                               (sizeof CvChain) (sizeof CvContour))])
    (undef-or-obj offset-obj offset <cv-point> (cvPoint 0 0))
    (result (cvStartFindContours image storage header-size mode method offset))))

;;;;;
;; Retrieves next contour
(define-cproc cv-find-next-contour (scanner::<cv-contour-scanner>) :: <top>
  (let* ([seq :: CvSeq* (cvFindNextContour scanner)])
    (if seq
      (result (boxing seq <cv-seq>))
      (result (boxing 0 <boolean>)))))

;;;;;
;; Substitutes the last retrieved contour with the new one
;; (if the substitutor is null, the last retrieved contour is removed from the tree) 
(define-cproc cv-substitute-contour (scanner::<cv-contour-scanner> new-contour::<cv-seq>) ::<void>
  (cvSubstituteContour scanner new-contour))

;;;;;
;; Releases contour scanner and returns pointer to the first outer contour
(define-cproc cv-end-find-contours (scanner::<cv-contour-scanner>) ::<cv-seq>
  (result (cvEndFindContours (& scanner))))

;;;;;
;; Approximates a single Freeman chain or a tree of chains to polygonal curves
(define-cproc cv-approx-chains (src-seq::<cv-seq> storage::<cv-mem-storage>
                                                  :optional (method::<fixnum> 2) ;;method 2 is CV_CHAIN_APPROX_SIMPLE
                                                  (parameter::<real> 0)
                                                  (minimal-permeter::<fixnum> 0)
                                                  (recursive::<boolean> #f)) ::<cv-seq>
  (ENSURE_NOT_NULL storage)
  (result (cvApproxChains src-seq storage method parameter minimal-permeter recursive)))

;;;;;
;; Initalizes Freeman chain reader.
;; The reader is used to iteratively get coordinates of all the chain points.
;; If the Freeman codes should be read as is, a simple sequence reader should be used
(define-cproc cv-start-read-chain-points (chain::<cv-chain>) ::<cv-chain-pt-reader>
  (let* ([reader::CvChainPtReader* (SCM_MALLOC (sizeof CvChainPtReader))])
    (cvStartReadChainPoints chain reader)
    (result reader)))

;;;;;
;; Retrieves the next chain point
(define-cproc cv-read-chain-point (reader::<cv-chain-pt-reader>) ::<cv-point>
  (result (cvReadChainPoint reader)))



;;******************
;;Planar subdivisions
;;******************

;;;;;
;; @type cmd
;; @@class-c->scm Scm_CvGraphClass <cv-graph>
;; @@class-c->scm Scm_CvSetClass <cv-set>
;; @@class-c->scm Scm_CvSeqClass <cv-seq>
;; @@class-c->scm Scm_CvTreeNodeClass <cv-tree-node>

(define-cclass <cv-subdiv-2d>
  :built-in
  "ScmSubdiv2D*" "Scm_CvSubdiv2DClass"
  ("Scm_CvGraphClass" "Scm_CvSetClass" "Scm_CvSeqClass" "Scm_CvTreeNodeClass")
  (;;slot
   (quad-edges :type <int>
               :setter #f
               :c-name "quad_edges")
   (geometry-valid? :type <boolean>
                    :setter #f
                    :c-name "is_geometry_valid")
   (recent-edge :type <fixnum>
                :setter #f
                :c-name "recent_edge")
   (top-left :type <cv-point-2d32f>
             :setter #f
             :c-name "topleft")
   (bottom-right :type <cv-point-2d32f>
                 :setter #f
                 :c-name "bottomright")
   ))

(define-cclass <cv-subdiv-2d-point>
  :built-in
  "ScmSubdiv2DPoint*" "Scm_CvSubdiv2DPointClass"
  ()
  (;;slot
   (flags :type <fixnum>
          :setter #f)
   (first :type <fixnum>
          :setter #f)
   (pt :type <cv-point-2d32f>
       :setter #f)
   (id :type <int>
       :setter #f)
   ))

;;;;;
;; Initializes Delaunay triangulation
(define-cproc cv-init-subdiv-delaunay2d (rect::<cv-rect>) ::<cv-subdiv-2d>
  (let* ([subdiv::CvSubdiv2D* (SCM_MALLOC (sizeof CvSubdiv2D))])
    (cvInitSubdivDelaunay2D subdiv rect)
    (result subdiv)))

;;cvCreateSubdiv2D not support

;;;;;
;; Simplified Delaunay diagram creation
(define-cproc cv-create-subdiv-delaunay2d (rect::<cv-rect> storage::<cv-mem-storage>) ::<cv-subdiv-2d>
  (ENSURE_NOT_NULL storage)
  (result (cvCreateSubdivDelaunay2D rect storage)))

;;;;;
;; Inserts new point to the Delaunay triangulation
(define-cproc cv-subdiv-delaunay-2d-insert (subdiv::<cv-subdiv-2d> pt::<cv-point-2d32f>) ::<cv-subdiv-2d-point>
  (result (cvSubdivDelaunay2DInsert subdiv pt)))


;;-------------
;;Constants
;;enum CvSubdiv2DPointLocation
(define-enum CV_PTLOC_ERROR)
(define-enum CV_PTLOC_OUTSIDE_RECT)
(define-enum CV_PTLOC_INSIDE)
(define-enum CV_PTLOC_VERTEX)
(define-enum CV_PTLOC_ON_EDGE)
;;;;;
;; Locates a point within the Delaunay triangulation (finds the edge
;; the point is left to or belongs to, or the triangulation point the given point coinsides with
(define-cproc cv-subdiv-2d-locate (subdiv::<cv-subdiv-2d> pt::<cv-point-2d32f>) ::(<fixnum> <int>)
  (let* ([e::CvSubdiv2DEdge]
         [ret::CvSubdiv2DPointLocation (cvSubdiv2DLocate subdiv pt (& e) 0)])
    (result ret e)))

;;;;;
;; Calculates Voronoi tesselation (i.e. coordinates of Voronoi points)
(define-cproc cv-calc-subdiv-voronoi-2d (subdiv::<cv-subdiv-2d>) ::<void>
  (cvCalcSubdivVoronoi2D subdiv))

;;;;;
;; Removes all Voronoi points from the tesselation
(define-cproc cv-clear-subdiv-voronoi-2d (subdiv::<cv-subdiv-2d>) ::<void>
  (cvClearSubdivVoronoi2D subdiv))

;;;;;
;; Finds the nearest to the given point vertex in subdivision.
(define-cproc cv-find-nearest-point-2d (subdiv::<cv-subdiv-2d> pt::<cv-point-2d32f>) ::<cv-subdiv-2d-point>
  (result (cvFindNearestPoint2D subdiv pt)))

(define-cproc cv-subdiv-2d-next-edge (edge::<fixnum>) ::<int>
  (result (cvSubdiv2DNextEdge edge)))

(define-cproc cv-subdiv-2d-rotate-edge (edge::<fixnum> rotate::<fixnum>) ::<int>
  (result (cvSubdiv2DRotateEdge edge rotate)))

(define-cproc cv-subdiv-2d-sym-edge (edge::<fixnum>) ::<int>
  (result (cvSubdiv2DSymEdge edge)))


;;-------------
;;Constants
;;enum CvNextEdgeType
(define-enum CV_NEXT_AROUND_ORG)
(define-enum CV_NEXT_AROUND_DST)
(define-enum CV_PREV_AROUND_ORG)
(define-enum CV_PREV_AROUND_DST)
(define-enum CV_NEXT_AROUND_LEFT)
(define-enum CV_NEXT_AROUND_RIGHT)
(define-enum CV_PREV_AROUND_LEFT)
(define-enum CV_PREV_AROUND_RIGHT)
(define-cproc cv-subdiv-2d-get-edge (edge::<fixnum> type::<fixnum>) ::<int>
  (result (cvSubdiv2DGetEdge edge type)))

(define-cproc cv-subdiv-2d-edge-org (edge::<fixnum>) ::<cv-subdiv-2d-point>
  (result (cvSubdiv2DEdgeOrg edge)))

(define-cproc cv-subdiv-2d-edge-dst (edge::<fixnum>) ::<cv-subdiv-2d-point>
  (result (cvSubdiv2DEdgeDst edge)))

(define-cproc cv-triangle-area (a::<cv-point-2d32f> b::<cv-point-2d32f> c::<cv-point-2d32f>) ::<real>
  (result (cvTriangleArea a b c)))


;;******************
;;Contour Processing and Shape Analysis
;;******************

;;;;;;
;; Approximates a single polygonal curve (contour) or a tree of polygonal curves (contours)
(define-cproc cv-approx-poly (src-seq::<cv-seq> storage::<cv-mem-storage> method::<fixnum> parameter::<real>
                                                :optional (parameter2::<fixnum> 0))::<cv-seq>
  (ENSURE_NOT_NULL storage)
  (result (cvApproxPoly src-seq 0
                        storage method parameter parameter2)))

;;;;;
;; Calculates perimeter of a contour or length of a part of contour
;; @param ((slice-obj (c "SCM_UNDEFINED")) >> (slice c:null))
;; {@ c:null <cv-slice>}
(define-cproc cv-arc-length (curve::<cv-seq>
                              :optional (slice-obj (c "SCM_UNDEFINED")) (is-closed::<fixnum> -1))::<real>
  (let* ([slice::CvSlice])
    (undef-or-obj slice-obj slice <cv-slice> CV_WHOLE_SEQ)
    (result (cvArcLength curve slice is-closed))))

(define-cproc cv-contour-perimeter (contour::<cv-seq>) ::<real>
  (result (cvContourPerimeter contour)))

(define-cise-stmt (sequence-to-point-seq seq seq-type cv-arr storage)
  `(cond
    [(is-type? ,seq <cv-arr>)
     (set! ,cv-arr (unboxing ,seq <cv-arr>))
     (ENSURE_NOT_NULL ,cv-arr)]
    [(is-type? ,seq <vector>)
     (set! ,storage (cvCreateMemStorage 0))
     (set! ,cv-arr (cvCreateSeq ,seq-type (sizeof CvSeq) (sizeof CvPoint) ,storage))
     (dotimes [i (SCM_VECTOR_SIZE ,seq)]
       (unless (is-type? (SCM_VECTOR_ELEMENT ,seq i) <cv-point>)
         (Scm_Error "vector elements must be <cv-point>."))
       (cvSeqPush ,cv-arr (& (unboxing (SCM_VECTOR_ELEMENT ,seq i) <cv-point>))))]
    [(is-type? ,seq <list>) 
     (set! ,storage (cvCreateMemStorage 0))
     (set! ,cv-arr (cvCreateSeq ,seq-type (sizeof CvSeq) (sizeof CvPoint) ,storage))
     (dolist [p ,seq]
       (unless (is-type? p <cv-point>)
         (Scm_Error "list elements must be <cv-point>."))
       (cvSeqPush ,cv-arr (& (unboxing p <cv-point>))))]
    [else (Scm_Error "<cv-arr> or <vector> or <list> required, but got %S." ,seq)]))

;;;;;
;; Calculates contour boundning rectangle (update=1) or
;; just retrieves pre-calculated rectangle (update=0)
(define-cproc cv-bounding-rect (points::<top>
                                 :optional (update::<fixnum> 0)) ::<cv-rect>
  (let* ([points-arr :: CvArr*]
         [storage :: CvMemStorage* 0])
    (sequence-to-point-seq points CV_SEQ_ELTYPE_POINT points-arr storage)
    (result (cvBoundingRect points-arr update))
    (when storage
      (cvReleaseMemStorage (& storage)))))

;;;;;
;; Calculates area of a contour or contour segment
;; @param contour {@ <cv-arr> <vector of <cv-point>> <list of <cv-point>>}
;; @param ((slice-obj (c "SCM_UNDEFINED")) >> (slice c:null))
;; {@ c:null <cv-slice>}
(define-cproc cv-contour-area (contour::<top>
                                :optional (slice-obj (c "SCM_UNDEFINED")) (oriented::<fixnum> 0))::<real>
  (let* ([contour-arr :: CvArr*]
         [storage :: CvMemStorage* 0]
         [slice::CvSlice])
    (sequence-to-point-seq contour CV_SEQ_POLYLINE contour-arr storage)
    (undef-or-obj slice-obj slice <cv-slice> CV_WHOLE_SEQ)
    (result (cvContourArea contour-arr slice oriented))
    (when storage
      (cvReleaseMemStorage (& storage)))))

;;;;;
;; Finds minimum area rotated rectangle bounding a set of points
;; @param points {@ <cv-arr> <vector of <cv-point>> <list of <cv-point>>}
;; @param ((storage-obj (c "SCM_UNDEFINED")) >> (storage c:null))
;; {@ c:null <cv-mem-storage>}
(define-cproc cv-min-area-rect2 (points::<top>
                                  :optional (storage-obj (c "SCM_UNDEFINED"))) ::<cv-box-2d>
  (let* ([points-arr :: CvArr*]
         [ss :: CvMemStorage* 0]
         [storage::CvMemStorage*])
    (sequence-to-point-seq points CV_SEQ_ELTYPE_POINT points-arr ss)
    (undef-or-obj-null-check storage-obj storage <cv-mem-storage>)
    (result (cvMinAreaRect2 points-arr storage))
    (when storage
      (cvReleaseMemStorage (& storage)))))

;;;;;
;; Finds minimum enclosing circle for a set of points
(define-cproc cv-min-enclosing-circle (points::<top>) ::(<top> <top>)
  (let* ([points-arr :: CvArr*]
         [storage :: CvMemStorage* 0]
         [center::CvPoint2D32f]
         [radius::float])
    (sequence-to-point-seq points CV_SEQ_ELTYPE_POINT points-arr storage)
    (if (cvMinEnclosingCircle points-arr (& center) (& radius))
      (result (boxing center <cv-point-2d32f>) (boxing radius <float>))
      (result (boxing 0 <boolean>) (boxing 0 <boolean>)))
    (when storage
      (cvReleaseMemStorage (& storage)))))

;;-------------
;;Constants
(define-enum CV_CONTOURS_MATCH_I1)
(define-enum CV_CONTOURS_MATCH_I2)
(define-enum CV_CONTOURS_MATCH_I3)
;;;;;
;; Compares two contours by matching their moments
(define-cproc cv-match-shapes (obj1 obj2 method::<fixnum>
                                    :optional (parameter::<real> 0)) ::<real>
  (let* ([object1::void* (?: (is-type? obj1 <cv-arr>)
                             (unboxing obj1 <cv-arr>) (unboxing obj1 <cv-seq>))]
         [object2::void* (?: (is-type? obj2 <cv-arr>)
                             (unboxing obj2 <cv-arr>) (unboxing obj2 <cv-seq>))])
    (ENSURE_NOT_NULL object1)
    (ENSURE_NOT_NULL object2)
    (result (cvMatchShapes object1 object2 method parameter))))


(define-cise-stmt (vec-to-mat vec elem-c-type assign var mat-type)
  (let ([ary (gensym "img__")]
        [mat (gensym "img__")])
    `(let* ([,ary :: void*]
            [,mat :: CvMat*])
       (vector-to-ary ,vec ,ary ,elem-c-type ,assign)
       (set! ,mat (cvCreateMatHeader 1 (SCM_VECTOR_SIZE ,vec) ,mat-type))
       (set! (ref (-> ,mat data) ptr) ,ary)
       (set! ,var ,mat))))

(define-cise-stmt (list-to-mat l setted-list-size elem-c-type assign var mat-type)
  (let ([ary (gensym "img__")]
        [mat (gensym "img__")]
        [len (gensym "img__")])
    `(let* ([,ary :: void*]
            [,mat :: CvMat*]
            [,len :: int])
       (list-to-ary ,l ,ary ,len ,elem-c-type ,assign)
       (set! ,mat (cvCreateMatHeader 1 ,len ,mat-type))
       (set! (ref (-> ,mat data) ptr) ,ary)
       (when ,setted-list-size
         (set! (* ,setted-list-size) ,len))
       (set! ,var ,mat))))

(define-cise-stmt (cv-point-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<cv-point>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (set! ,var (,(string->symbol (~ type 'unboxer)) ,obj))
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

(define-cise-stmt (cv-point-2d32f-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<cv-point-2d32f>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (set! ,var (,(string->symbol (~ type 'unboxer)) ,obj))
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

"
static int getElementChannels(CvArr* arr)
{
switch(cvGetElemType(arr))
{
case CV_8UC1:
case CV_8SC1:
case CV_16UC1:
case CV_16SC1:
case CV_32FC1:
case CV_32SC1:
case CV_64FC1:
return 1;

case CV_8UC2:
case CV_8SC2:
case CV_16UC2:
case CV_16SC2:
case CV_32FC2:
case CV_32SC2:
case CV_64FC2:
return 2;

case CV_8UC3:
case CV_8SC3:
case CV_16UC3:
case CV_16SC3:
case CV_32FC3:
case CV_32SC3:
case CV_64FC3:
return 3;

case CV_8UC4:
case CV_8SC4:
case CV_16UC4:
case CV_16SC4:
case CV_32FC4:
case CV_32SC4:
case CV_64FC4:
return 4;
}

Scm_Error(\"internal error\");
}
"

(define-cfn obj-to-cvarr (obj::ScmObj arr::void** length::int* 
                                      create-mat?::int* input-type::int*) ::void
  (cond
    [(is-type? obj <vector>) 
     (let* ([vec::ScmVector* (unboxing obj <vector>)])
       (set! (* create-mat?) 1)
       (when length
         (set! (* length) (SCM_VECTOR_SIZE vec)))
       (cond
         [(is-type? (SCM_VECTOR_ELEMENT vec 0) <cv-point>) 
          (when input-type
            (set! (* input-type) 0))
          (vec-to-mat vec CvPoint cv-point-elem-assign (* arr) CV_32SC2)]
         [(is-type? (SCM_VECTOR_ELEMENT vec 0) <cv-point-2d32f>) 
          (when input-type
            (set! (* input-type) 1))
          (vec-to-mat vec CvPoint2D32f cv-point-2d32f-elem-assign (* arr) CV_32FC2)]
         [else (Scm_Error "type of input vector elements must be <cv-point> or <cv-point-2d32f>")]))]

    [(is-type? obj <list>)
     (set! (* create-mat?) 1)
     (cond
       [(is-type? (SCM_CAR obj) <cv-point>)
        (when input-type
          (set! (* input-type) 0))
        (list-to-mat obj length CvPoint cv-point-elem-assign (* arr) CV_32SC2)]
       [(is-type? (SCM_CAR obj) <cv-point-2d32f>)
        (when input-type
          (set! (* input-type) 1))
        (list-to-mat obj length CvPoint2D32f cv-point-2d32f-elem-assign (* arr) CV_32FC2)]
       [else (Scm_Error "type of input list elements must be <cv-point> or <cv-point-2d32f>")])]

    [(is-type? obj <cv-seq>)
     (let* ([seq :: CvSeq* (unboxing obj <cv-seq>)])
       (ENSURE_NOT_NULL seq)
       (set! (* arr) seq)
       (when input-type
         (case (CV_SEQ_ELTYPE seq)
           [(CV_32SC2) (set! (* input-type) 0)]
           [(CV_32FC2) (set! (* input-type) 1)]
           [else (Scm_Error "unsupport seq element type. %S" (CV_SEQ_ELTYPE seq))]))
       (when length
         (set! (* length) (-> seq total))))]
    [(is-type? obj <cv-mat>)
     (ENSURE_NOT_NULL (unboxing obj <cv-mat>))
     (let* ([mat :: CvMat* (unboxing obj <cv-mat>)]
            [size :: CvSize (cvGetSize mat)])
       (set! (* arr) mat)
       (when input-type
         (case (CV_MAT_TYPE (-> mat type))
           [(CV_32SC2) (set! (* input-type) 0)]
           [(CV_32FC2) (set! (* input-type) 1)]
           [else (Scm_Error "unsupport matrix type. %S" (CV_MAT_TYPE (-> mat type)))]))
       (when length
         (set! (* length) (/ (* (ref size height)
                                (ref size width)
                                (getElementChannels mat))
                             2))))]
    [else (Scm_Error "<cv-seq> or <cv-mat> or <vector> or <list> required, but got %S" obj)]))


;;-------------
;;Constants
(define-enum CV_CLOCKWISE)
(define-enum CV_COUNTER_CLOCKWISE)

;;;;;
;; Calculates exact convex hull of 2d point set
(define-cproc cv-convex-hull2 (input-obj ;<cv-point> or <cv-point-2d32f> of vecotr or sequence
                                :optional (orientation::<fixnum> 1) ;orientation 1 is CV_CLOCKWISE
                                ) ::<vector>
  (let* ([input :: void*]
         [input-length :: int]
         [create-mat? :: int 0]
         [input-type :: int -1])
    ;;setting input
    (obj-to-cvarr input-obj (& input) (& input-length)
                  (& create-mat?) (& input-type))
    (if (and (!= input-type 0) (!= input-type 1))
      (Scm_Error "Unkown Input type"))

    (let* ([output-mat :: CvMat* (cvCreateMat 1 input-length (?: (== input-type 0)
                                                                 CV_32SC2 CV_32FC2))])
      ;;call cvConvexHull2
      (cvConvexHull2 input output-mat orientation 1)

      ;;constract output
      (let* ([out-vec::ScmVector* (cast ScmVector* (Scm_MakeVector (- (+ (-> output-mat rows)
                                                                         (-> output-mat cols))
                                                                      1)
                                                                   SCM_UNDEFINED))])
        (if (== input-type 0)
          (let* ([data::CvPoint* (cast CvPoint* (ref (-> output-mat data) ptr))])
            (dotimes [i (SCM_VECTOR_SIZE out-vec)]
              (set! (SCM_VECTOR_ELEMENT out-vec i) (boxing (aref data i) <cv-point>))))
          (let* ([data::CvPoint2D32f* (cast CvPoint2D32f* (ref (-> output-mat data) ptr))])
            (dotimes [i (SCM_VECTOR_SIZE out-vec)]
              (set! (SCM_VECTOR_ELEMENT out-vec i) (boxing (aref data i) <cv-point-2d32f>)))))
        (result out-vec))

      (cvReleaseMat (& output-mat)))

    (if create-mat?
      (cvReleaseMat (cast CvMat** (& input))))
    ))

;;;;;
;; Checks whether the contour is convex or not (returns #t if convex, #f if not)
(define-cproc cv-check-contour-convexity (contour) ::<boolean>
  (let* ([input :: void*]
         [create-mat? :: int 0])
    (obj-to-cvarr contour (& input) 0 (& create-mat?) 0)
    (result (cvCheckContourConvexity input))
    (if create-mat?
      (cvReleaseMat (cast CvMat** (& input))))))


;;not support cvConvexityDefects

;;;;;
;; Fits ellipse into a set of 2d points
(define-cproc cv-fit-ellipse2 (points::<cv-seq>) ::<cv-box-2d>
  (result (cvFitEllipse2 points)))

;;;;;
;; Finds minimum rectangle containing two given rectangles
(define-cproc cv-max-rect (rect1::<cv-rect> rect2::<cv-rect>)::<cv-rect>
  (result (cvMaxRect (& rect1) (& rect2))))

;;;;;
;; Finds coordinates of the box vertices
(define-cproc cv-box-points (box::<cv-box-2d>) ::<vector>
  (let* ([vec::ScmVector* (cast ScmVector* (Scm_MakeVector 4 SCM_UNDEFINED))]
         [pt::(.array CvPoint2D32f (4))])
    (cvBoxPoints box pt)
    (set! (SCM_VECTOR_ELEMENT vec 0) (boxing (aref pt 0) <cv-point-2d32f>))
    (set! (SCM_VECTOR_ELEMENT vec 1) (boxing (aref pt 1) <cv-point-2d32f>))
    (set! (SCM_VECTOR_ELEMENT vec 2) (boxing (aref pt 2) <cv-point-2d32f>))
    (set! (SCM_VECTOR_ELEMENT vec 3) (boxing (aref pt 3) <cv-point-2d32f>))
    (result vec)))

;;;;;
;; Initializes sequence header for a matrix (column or row vector) of points -
;; a wrapper for cvMakeSeqHeaderForArray (it does not initialize bounding rectangle!!!)
(define-cproc cv-point-polygon-test (contour-obj pt::<cv-point-2d32f> measure-dist::<boolean>) ::<real>
  (let* ([contour::void*])
    (cond
      [(is-type? contour-obj <cv-seq>)
       (set! contour (unboxing contour-obj <cv-seq>))]
      [(is-type? contour-obj <cv-chain>)
       (set! contour (unboxing contour-obj <cv-chain>))]
      [else (Scm_Error "<cv-seq> or <cv-chain> required, but got %S" contour-obj)])
    (result (cvPointPolygonTest contour pt measure-dist))))



;;******************
;;Histogram functions
;;******************

;;;;;
;; Creates new histogram
;; @param (sizes-obj >> sizes)
;; {@ c:null <list> <vector> <s32vector>}
;; @param ((ranges-obj (c "SCM_UNDEFINED")) >> (ranges c:null))
;; {@ c:null <list of <f32vector>> <vector of <f32vector>>}
(define-cproc cv-create-hist (sizes-obj type::<fixnum>
                                        :optional (ranges-obj (c "SCM_UNDEFINED"))
                                        (uniform::<boolean> #t)) :: <cv-histogram>
  (let* ([sizes :: int*]
         [dims :: int]
         [ranges :: float**])
    (cond
      [(is-type? sizes-obj <list>)
       (set! dims (Scm_Length sizes-obj))
       (list-to-ary sizes-obj sizes _int_t int-elem-assign)]
      [(is-type? sizes-obj <vector>)
       (set! dims (SCM_VECTOR_SIZE sizes-obj))
       (vector-to-ary sizes-obj sizes _int_t int-elem-assign)]
      [(is-type? sizes-obj <s32vector>)
       (set! dims (SCM_S32VECTOR_SIZE sizes-obj))
       (uvector.int-elem-assign sizes sizes-obj)]
      [else (Scm_Error "<list> or <vector> or <s32vector> required, but got %S" sizes-obj)]
      )
    (cond
      [(undefined? ranges-obj)
       (set! ranges 0)]
      [(is-type? ranges-obj <list>)
       (list-to-ary ranges-obj ranges _float_t* list.float-elem-assign)]
      [(is-type? ranges-obj <vector>)
       (if (is-type? (SCM_VECTOR_ELEMENT ranges-obj 0) <f32vector>)
         (vector-to-ary ranges-obj ranges _float_t* uvector.float-elem-assign)
         (vector-to-ary ranges-obj ranges _float_t* vector.float-elem-assign))]
      [else (Scm_Error "<list> or <vector> c:null required, but got %S" ranges-obj)]
      )
    (result (cvCreateHist dims sizes type ranges uniform))))

;;;;;
;; Assignes histogram bin ranges
(define-cproc cv-set-hist-bin-ranges (hist::<cv-histogram> ranges-obj
                                                           :optional (uniform::<boolean> #t)) ::<void>
  (ENSURE_NOT_NULL hist)
  (let* ([ranges :: float**])
    (cond
      [(undefined? ranges-obj)
       (set! ranges 0)]
      [(is-type? ranges-obj <list>)
       (list-to-ary ranges-obj ranges _float_t* list.float-elem-assign)]
      [(is-type? ranges-obj <vector>)
       (if (is-type? (SCM_VECTOR_ELEMENT ranges-obj 0) <f32vector>)
         (vector-to-ary ranges-obj ranges _float_t* uvector.float-elem-assign)
         (vector-to-ary ranges-obj ranges _float_t* vector.float-elem-assign))]
      [else (Scm_Error "<list> or <vector> or c:null required, but got %S" ranges-obj)]
      )
    (cvSetHistBinRanges hist ranges uniform)))

;;not support cvMakeHistHeaderForArray

;;;;;
;; Releases histogram
(define-cproc cv-release-hist (hist::<cv-histogram>) ::<void>
  (if hist
    (begin
      (cvReleaseHist (& hist))
      (set! (-> (SCM_FOREIGN_POINTER hist_scm) ptr) NULL))))

;;;;;
;; Clears all the histogram bins
(define-cproc cv-clear-hist (hist::<cv-histogram>) ::<void>
  (ENSURE_NOT_NULL hist)
  (cvClearHist hist))

;;;;;
;; Finds indices and values of minimum and maximum histogram bins
(define-cproc cv-get-minmax-hist-value (hist::<cv-histogram>) ::(<float> <float>)
  (ENSURE_NOT_NULL hist)
  (let* ([min :: float]
         [max :: float])
    (cvGetMinMaxHistValue hist (& min) (& max) 0 0)
    (result min max)))

;;;;;
;; Normalizes histogram by dividing all bins by sum of the bins, multiplied by <factor>.
;; After that sum of histogram bins is equal to <factor>
(define-cproc cv-normalize-hist (hist::<cv-histogram> factor::<real>) ::<void>
  (ENSURE_NOT_NULL hist)
  (cvNormalizeHist hist factor))

;;;;;
;; Clear all histogram bins that are below the threshold
(define-cproc cv-thresh-hist (hist::<cv-histogram> threshold::<real>) ::<void>
  (ENSURE_NOT_NULL hist)
  (cvThreshHist hist threshold))

;;-------------
;;Constants
(define-enum CV_COMP_CORREL)
(define-enum CV_COMP_CHISQR)
(define-enum CV_COMP_INTERSECT)
(define-enum CV_COMP_BHATTACHARYYA)
;;;;;
;; Compares two histogram
(define-cproc cv-compare-hist (hist1::<cv-histogram> hist2::<cv-histogram>
                                                     method::<fixnum>) ::<real>
  (ENSURE_NOT_NULL hist1)
  (ENSURE_NOT_NULL hist2)
  (result (cvCompareHist hist1 hist2 method)))

;;;;;
;; Copies one histogram to another. Destination histogram is created if the destination pointer is c:null
;; @param ((out-obj (c "SCM_UNDEFINED")) >> (out c:null))
;; {@ c:null <cv-histogram> }
(define-cproc cv-copy-hist (hist::<cv-histogram>
                             :optional (out-obj (c "SCM_UNDEFINED"))) ::<cv-histogram>
  (ENSURE_NOT_NULL hist)
  (let* ([out :: CvHistogram*])
    (undef-or-obj-null-check out-obj out <cv-histogram>)
    (cvCopyHist hist (& out))
    (result out)))

;;not support cvCalcBayesianProb


(define-cise-stmt (cvarr-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<cv-arr>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (begin
         (set! ,var (,(string->symbol (~ type 'unboxer)) ,obj))
         (ENSURE_NOT_NULL ,var))
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

"
#define CALC_HIST_TMP_SIZE 10
"

;;;;;
;; Calculates array histogram
;; @param arr {@ <list> <vector> <cv-arr>}
;; @param ((mask-obj (c "SCM_UNDEFINED")) >> (mask c:null))
;; {@ c:null <cv-arr>}
(define-cproc cv-calc-arr-hist (arr hist::<cv-histogram>
                                    :optional (accumulate::<fixnum> 0)
                                    (mask-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL hist)
  (let* ([array-tmp :: (.array CvArr* (CALC_HIST_TMP_SIZE))]
         [array :: CvArr**]
         [mask :: CvArr*])
    (cond
      [(is-type? arr <list>)
       (list-to-ary arr array array-tmp CALC_HIST_TMP_SIZE CvArr* cvarr-elem-assign)]
      [(is-type? arr <vector>)
       (vector-to-ary arr array array-tmp CALC_HIST_TMP_SIZE CvArr* cvarr-elem-assign)]
      [(is-type? arr <cv-arr>)
       (set! (aref array-tmp 0) (unboxing arr <cv-arr>))
       (ENSURE_NOT_NULL (aref array-tmp 0))
       (set! array array-tmp)]
      [else (Scm_Error "<list> or <vector> or <cv-arr> required, but got %S" arr)])
    (undef-or-cvarr mask-obj mask)
    (cvCalcArrHist array hist accumulate mask)))

;;;;;
;; @param image {@ <list> <vector> <cv-arr>}
;; @param ((mask-obj (c "SCM_UNDEFINED")) >> (mask c:null))
;; {@ c:null <cv-arr>}
(define-cproc cv-calc-hist (image hist::<cv-histogram>
                                  :optional (accumulate::<fixnum> 0)
                                  (mask-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL hist)
  (let* ([array-tmp :: (.array CvArr* (CALC_HIST_TMP_SIZE))]
         [array :: CvArr**]
         [mask :: CvArr*])
    (cond
      [(is-type? image <list>)
       (list-to-ary image array array-tmp CALC_HIST_TMP_SIZE CvArr* cvarr-elem-assign)]
      [(is-type? image <vector>)
       (vector-to-ary image array array-tmp CALC_HIST_TMP_SIZE CvArr* cvarr-elem-assign)]
      [(is-type? image <cv-arr>)
       (set! (aref array-tmp 0) (unboxing image <cv-arr>))
       (ENSURE_NOT_NULL (aref array-tmp 0))
       (set! array array-tmp)]
      [else (Scm_Error "<list> or <vector> or <cv-arr> required, but got %S" image)])
    (undef-or-cvarr mask-obj mask)
    (cvCalcArrHist array hist accumulate mask)))

;;;;;
;; equalizes histogram of 8-bit single-channel image
(define-cproc cv-equalize-hist (src::<cv-arr> dst::<cv-arr>)
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvEqualizeHist src dst))


;;-------------
;;Constants
(define-enum CV_DIST_USER)
(define-enum CV_DIST_L1)
(define-enum CV_DIST_L2)
(define-enum CV_DIST_C)
(define-enum CV_DIST_L12)
(define-enum CV_DIST_FAIR)
(define-enum CV_DIST_WELSCH)
(define-enum CV_DIST_HUBER)
;;;;;
;; Applies distance transform to binary image
;; @param ((mask-obj (c "SCM_UNDEFINED")) >> (mask c:null))
;; {@ c:null <f32vector> <list> <vector>}
;; @param ((labels-obj (c "SCM_UNDEFINED")) >> (labels c:null))
;; {@ c:null <cv-arr>}
(define-cproc cv-dist-transform (src::<cv-arr> dst::<cv-arr>
                                               :optional (distance-type::<fixnum> 2) ;;distance-type 2 is CV_DIST_L2
                                               (mask-size::<fixnum> 3)
                                               (mask-obj (c "SCM_UNDEFINED")) (labels-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (let* ([mask::float*]
         [labels::CvArr*])
    (cond
      [(undefined? mask-obj)
       (set! mask 0)]
      [(is-type? mask-obj <list>)
       (list-to-ary mask-obj mask _float_t float-elem-assign)]
      [(is-type? mask-obj <f32vector>)
       (set! mask (SCM_F32VECTOR_ELEMENTS (unboxing mask-obj <f32vector>)))]
      [(is-type? mask-obj <vector>)
       (vector-to-ary mask-obj mask _float_t float-elem-assign)]
      [else (Scm_Error "<list> or <vector> or <f32vector> or c:null required, but got %S" mask-obj)])
    (undef-or-cvarr labels-obj labels)
    (cvDistTransform src dst distance-type mask-size mask labels)))


;;-------------
;;Constants
(define-enum CV_THRESH_BINARY)
(define-enum CV_THRESH_BINARY_INV)
(define-enum CV_THRESH_TRUNC)
(define-enum CV_THRESH_TOZERO)
(define-enum CV_THRESH_TOZERO_INV)
(define-enum CV_THRESH_MASK)
(define-enum CV_THRESH_OTSU)
;;;;;
;; Applies fixed-level threshold to grayscale image.
;; This is a basic operation applied before retrieving contours
;; @param threshold-type {@
;; CV_THRESH_BINARY CV_THRESH_BINARY_INV
;; CV_THRESH_TRUNC
;; CV_THRESH_TOZERO CV_THRESH_TOZERO_INV
;; CV_THRESH_MASK CV_THRESH_OTSU }
(define-cproc cv-threshold (src::<cv-arr> dst::<cv-arr>
                                          threshold::<real> max-value::<real> 
                                          threshold-type::<fixnum>) ::<real>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (result (cvThreshold src dst threshold max-value threshold-type)))

;;-------------
;;Constants
(define-enum CV_ADAPTIVE_THRESH_MEAN_C)
(define-enum CV_ADAPTIVE_THRESH_GAUSSIAN_C)
;;;;;
;; Applies adaptive threshold to grayscale image.
;; @param ((adaptive-method 0) >> (adaptive-method CV_ADAPTIVE_THRESH_MEAN_C))
;; {@ CV_ADAPTIVE_THRESH_MEAN_C CV_ADAPTIVE_THRESH_GAUSSIAN_C}
;; @param ((threshold-type 0) >> (threshold-type CV_THRESH_BINARY))
;; {@ CV_THRESH_BINARY CV_THRESH_BINARY_INV}
;; @param (block-size 3) {@ 3 5 7 etc...}
(define-cproc cv-adaptive-threshold (src::<cv-arr> dst::<cv-arr> max-value::<real>
                                                   :optional (adaptive-method::<fixnum> 0) ;adaptive-method 0 is CV_ADAPTIVE_THRESH_MEAN_C
                                                   (threshold-type::<fixnum> 0) ;threshold-type 0 is CV_THRESH_BINARY
                                                   (block-size::<fixnum> 3)
                                                   (param1::<real> 5)) ::<void>
  (ENSURE_NOT_NULL src)
  (ENSURE_NOT_NULL dst)
  (cvAdaptiveThreshold src dst max-value adaptive-method threshold-type block-size param1))


(define-cclass <cv-connected-comp>
  :built-in :struct
  "ScmCvConnectedComp" "Scm_CvConnectedCompClass"
  ()
  (;;slot
   (area :type <double>
         :setter #f)
   (value :type <cv-scalar>
          :setter #f)
   (rect :type <cv-rect>
         :setter #f)
   (contour :type <cv-seq>
            :setter #f)
   )
  (print #t)
  )

;;-------------
;;Constants
(define-enum CV_FLOODFILL_FIXED_RANGE)
(define-enum CV_FLOODFILL_MASK_ONLY)
;;;;;
;; Fills the connected component until the color difference gets large enough
;; @param ((lo-diff-obj (c "SCM_UNDEFINED")) >> (lo-diff c:null))
;; {@ c:null <cv-scalar>}
;; @param ((up-diff-obj (c "SCM_UNDEFINED")) >> (up-diff c:null))
;; {@ c:null <cv-scalar>}
;; @param ((mask-obj (c "SCM_UNDEFINED")) >> (mask c:null))
;; {@ c:null <cv-arr>}
(define-cproc cv-flood-fill (image::<cv-arr> seed-point::<cv-point> new-val::<cv-scalar>
                                             :optional (lo-diff-obj (c "SCM_UNDEFINED")) (up-diff-obj (c "SCM_UNDEFINED")) 
                                             (flags::<fixnum> 4) (mask-obj (c "SCM_UNDEFINED"))) ::<cv-connected-comp>
  (ENSURE_NOT_NULL image)
  (let* ([lo-diff :: CvScalar]
         [up-diff :: CvScalar]
         [mask :: CvArr*]
         [comp :: CvConnectedComp])
    (undef-or-obj lo-diff-obj lo-diff <cv-scalar> (cvScalarAll 0))
    (undef-or-obj up-diff-obj up-diff <cv-scalar> (cvScalarAll 0))
    (undef-or-cvarr mask-obj mask)
    (cvFloodFill image seed-point new-val lo-diff up-diff (& comp) flags mask)
    (result comp)))


;;******************
;;Feature detection
;;******************

;;;;;
;; Runs canny edge detector
(define-cproc cv-canny (image::<cv-arr> edges::<cv-arr> 
                                        threshold1::<real> threshold2::<real>
                                        :optional (aperture-size::<fixnum> 3)) ::<void>
  (ENSURE_NOT_NULL image)
  (ENSURE_NOT_NULL edges)
  (cvCanny image edges threshold1 threshold2 aperture-size))

;;;;;
;; Calculates constraint image for corner detection
;; Dx^2 * Dyy + Dxx * Dy^2 - 2 * Dx * Dy * Dxy.
;; Applying threshold to the result gives coordinates of corners
(define-cproc cv-pre-corner-detect (image::<cv-arr> corners::<cv-arr>
                                                    :optional (aperture-size::<fixnum> 3)) ::<void>
  (ENSURE_NOT_NULL image)
  (ENSURE_NOT_NULL corners)
  (cvPreCornerDetect image corners aperture-size))

;;;;;
;; Calculates eigen values and vectors of 2x2 gradient covariation matrix at every image pixel
(define-cproc cv-corner-eigen-vals-and-vecs (image::<cv-arr> eigenvv::<cv-arr> block-size::<fixnum>
                                                             :optional (aperture-size::<fixnum> 3)) ::<void>
  (ENSURE_NOT_NULL image)
  (ENSURE_NOT_NULL eigenvv)
  (cvCornerEigenValsAndVecs image eigenvv block-size aperture-size))

;;;;;
;; Calculates minimal eigenvalue for 2x2 gradient covariation matrix at every image pixel
(define-cproc cv-corner-min-eigen-val (image::<cv-arr> eigenval::<cv-arr> block-size::<fixnum>
                                                       :optional (aperture-size::<fixnum> 3)) ::<void>
  (ENSURE_NOT_NULL image)
  (ENSURE_NOT_NULL eigenval)
  (cvCornerMinEigenVal image eigenval block-size aperture-size))

;;;;;
;; Harris corner detector:
;; Calculates det(M) - k*(trace(M)^2), where M is 2x2 gradient covariation matrix for each pixel
(define-cproc cv-corner-harris (image::<cv-arr> harris-response::<cv-arr> block-size::<fixnum>
                                                :optional (aperture-size::<fixnum> 3)
                                                (k::<real> 0.04)) ::<void>
  (ENSURE_NOT_NULL image)
  (ENSURE_NOT_NULL harris-response)
  (cvCornerHarris image harris-response block-size aperture-size k))

"
#define TEMP_CORNER_COUNT 150
"
;;;;;
;; Adjust corner position using some sort of gradient search
(define-cproc cv-find-corner-sub-pix (image::<cv-arr> corners-obj::<top>
                                                      win::<cv-size> zero-zone::<cv-size>
                                                      criteria::<cv-term-criteria>) ::<void>
  (ENSURE_NOT_NULL image)
  (let* ([tmp-corners :: (.array CvPoint2D32f (TEMP_CORNER_COUNT))]
         [corners :: CvPoint2D32f*]
         [count :: int])
    (cond
      [(is-type? corners-obj <list>)
       (list-to-ary corners-obj corners tmp-corners TEMP_CORNER_COUNT count CvPoint2D32f cv-point-2d32f-elem-assign)]
      [(is-type? corners-obj <vector>)
       (set! count (SCM_VECTOR_SIZE corners-obj))
       (vector-to-ary corners-obj corners tmp-corners TEMP_CORNER_COUNT CvPoint2D32f cv-point-2d32f-elem-assign)]
      [else (Scm_Error "<list> or <vector> required, but got %S" corners-obj)])
    (cvFindCornerSubPix image corners count win zero-zone criteria)))

;;;;;
;; Finds a sparse set of points within the selected region that seem to be easy to track
;; @param ((mask-obj (c "SCM_UNDEFINED")) >> (mask c:null))
;; {@ c:null <cv-arr>}
(define-cproc cv-good-features-to-track (image::<cv-arr> eig-image::<top> temp-image::<top>
                                                         corner-count::<fixnum>
                                                         quality-level::<real> min-distance::<real>
                                                         :optional (mask-obj (c "SCM_UNDEFINED"))
                                                         (block-size::<fixnum> 3) (use-harris::<boolean> #f)
                                                         (k::<real> 0.04)) ::<vector>
  (ENSURE_NOT_NULL image)
  (let* ([temp-corners :: (.array CvPoint2D32f (TEMP_CORNER_COUNT))]
         [corners :: CvPoint2D32f* (?: (< TEMP_CORNER_COUNT corner-count)
                                       (SCM_NEW_ARRAY CvPoint2D32f corner-count)
                                       temp-corners)]
         [eig :: CvArr*]
         [temp :: CvArr*]
         [mask :: CvArr*]
         [vec :: ScmVector*])
    (undef-or-cvarr eig-image eig)
    (undef-or-cvarr temp-image temp)
    (undef-or-cvarr mask-obj mask)
    (cvGoodFeaturesToTrack image eig temp corners (& corner-count) quality-level min-distance 
                           mask block-size use-harris k)
    (set! vec (cast ScmVector* (Scm_MakeVector corner-count SCM_UNDEFINED)))
    (dotimes [i corner-count]
      (set! (SCM_VECTOR_ELEMENT vec i) (boxing (aref corners i) <cv-point-2d32f>)))
    (result vec)))


;;-------------
;;Constants
(define-enum CV_HOUGH_STANDARD)
(define-enum CV_HOUGH_PROBABILISTIC)
(define-enum CV_HOUGH_MULTI_SCALE)
(define-enum CV_HOUGH_GRADIENT)
;;;;;
;; Finds lines on binary image using one of several methods.
;; @param (line-storage-obj >> line-storage) {@ <cv-mem-storage> <cv-mat>}
;; line-storage is either memory storage 
;; or 1 x <max number of lines> CvMat, its number of columns is changed by the function.
;; @param method {@ CV_HOUGH_STANDARD CV_HOUGH_PROBABILISTIC CV_HOUGH_MULTI_SCALE CV_HOUGH_GRADIENT}
;; rho, theta and threshold are used for each of those methods;
;; param1 ~ line length, param2 ~ line gap - for probabilistic,
;; param1 ~ srn, param2 ~ stn - for multi-scale
(define-cproc cv-hough-lines2 (image::<cv-arr> line-storage-obj::<top> method::<fixnum>
                                               rho::<real> theta::<real> threshold::<fixnum>
                                               :optional (param1::<real> 0) (param2::<real> 0)) ::<cv-seq>
  (ENSURE_NOT_NULL image)
  (let* ([line-storage :: void*])
    (cond
      [(is-type? line-storage-obj <cv-mem-storage>)
       (set! line-storage (unboxing line-storage-obj <cv-mem-storage>))]
      [(is-type? line-storage-obj <cv-mat>)
       (set! line-storage (unboxing line-storage-obj <cv-mat>))]
      [else (Scm_Error "<cv-mem-storage> or <cv-mat> required, but got %S" line-storage-obj)])
    (ENSURE_NOT_NULL line-storage)
    (result (cvHoughLines2 image line-storage method rho theta threshold param1 param2))))

;;;;;
;; Finds circles in the image
(define-cproc cv-hough-circles (image::<cv-arr> circle-storage-obj::<top> method::<fixnum>
                                                dp::<real> min-dist::<real>
                                                :optional (param1::<real> 100) (param2::<real> 100)
                                                (min-radius::<fixnum> 0) (max-radius::<fixnum> 0)) ::<cv-seq>
  (ENSURE_NOT_NULL image)
  (let* ([circle-storage :: void*])
    (cond
      [(is-type? circle-storage-obj <cv-mem-storage>)
       (set! circle-storage (unboxing circle-storage-obj <cv-mem-storage>))]
      [(is-type? circle-storage-obj <cv-mat>)
       (set! circle-storage (unboxing circle-storage-obj <cv-mat>))]
      [else (Scm_Error "<cv-mem-storage> or <cv-mat> required, but got %S" circle-storage-obj)])
    (ENSURE_NOT_NULL circle-storage)
    (result (cvHoughCircles image circle-storage method dp min-dist
                            param1 param2 min-radius max-radius))))


(define-cise-stmt (cv-point-3d32f-elem-assign var obj)
  (let* ([type (cgen-type-from-name '<cv-point-3d32f>)])
    `(if (,(string->symbol (~ type 'c-predicate)) ,obj)
       (set! ,var (,(string->symbol (~ type 'unboxer)) ,obj))
       (Scm_Error ,#`",(~ type 'description) required, but got %S" ,obj))))

;;-------------
;;Constants
(define-enum CV_DIST_USER)
(define-enum CV_DIST_L1)
(define-enum CV_DIST_L2)
(define-enum CV_DIST_C)
(define-enum CV_DIST_L12)
(define-enum CV_DIST_FAIR)
(define-enum CV_DIST_WELSCH)
(define-enum CV_DIST_HUBER)
;;;;;
;; Fits a line into set of 2d or 3d points in a robust way (M-estimator technique)
;; @param dist-type {@
;; CV_DIST_USER CV_DIST_L1 CV_DIST_L2 CV_DIST_C
;; CV_DIST_L12 CV_DIST_FAIR CV_DIST_WELSCH CV_DIST_HUBER
;; }
;; @param dims {@ 2 3}
;; dims is original parameter of gauche-cv.
;; specify points dimention(2 or 3).
(define-cproc cv-fit-line (points-obj::<top> dist-type::<fixnum> param::<real>
                                             reps::<real> aeps::<real>
                                             dims::<fixnum>)::<vector>
  (if (or (== dims 2) (== dims 3))
    (Scm_Error "dims: 2 or 3 required."))
  (let* ([points :: void*]
         [line :: (.array float (6))])
    (cond
      [(is-type? points-obj <cv-seq>)
       (set! points (unboxing points-obj <cv-seq>))]
      [(is-type? points-obj <cv-mat>)
       (set! points (unboxing points-obj <cv-mat>))
       (ENSURE_NOT_NULL points)]
      [(is-type? points-obj <list>)
       (if (null? points-obj)
         (Scm_Error "poins parameter is null"))
       (cond
         [(is-type? (SCM_CAR points-obj) <cv-point-2d32f>)
          (list-to-ary points-obj points CvPoint2D32f cv-point-2d32f-elem-assign)]
         [(is-type? (SCM_CAR points-obj) <cv-point-3d32f>)
          (list-to-ary points-obj points CvPoint3D32f cv-point-3d32f-elem-assign)]
         [else (Scm_Error "each element of list is <cv-point-2d32f> or <cv-point-3d32f> required.")])]
      [(is-type? points-obj <vector>)
       (if (zero? (SCM_VECTOR_SIZE points-obj))
         (Scm_Error "poins parameter is 0 size"))
       (cond
         [(is-type? (SCM_VECTOR_ELEMENT points-obj 0) <cv-point-2d32f>)
          (vector-to-ary points-obj points CvPoint2D32f cv-point-2d32f-elem-assign)]
         [(is-type? (SCM_VECTOR_ELEMENT points-obj 0) <cv-point-3d32f>)
          (vector-to-ary points-obj points CvPoint3D32f cv-point-3d32f-elem-assign)]
         [else (Scm_Error "each element of vector is <cv-point-2d32f> or <cv-point-3d32f> required.")])]
      [else (Scm_Error "<cv-arr> or <cv-mat> or <list> or <vector> required, but got %S" points-obj)]
      )

    (cvFitLine points dist-type param reps aeps line)

    (let* ([vec :: ScmVector* (cast ScmVector* (Scm_MakeVector (* dims 2) SCM_UNDEFINED))])
      (dotimes [i (* dims 2)]
        (set! (SCM_VECTOR_ELEMENT vec i) (boxing (aref line i) <float>)))
      (result vec))))


;;;;;
;; Constructs kd-tree from set of feature descriptors 
(define-cproc cv-create-kd-tree (desc::<cv-mat>) ::<cv-feature-tree>
  (ENSURE_NOT_NULL desc)
  (result (cvCreateKDTree desc)))

;;;;;
;; Constructs spill-tree from set of feature descriptors
(define-cproc cv-create-spill-tree (raw-data::<cv-mat>
                                     :optional (naive::<fixnum> 60)
                                     (rho::<real> 0.7) (tau::<real> 0.1)) ::<cv-feature-tree>
  (ENSURE_NOT_NULL raw-data)
  (result (cvCreateSpillTree raw-data naive rho tau)))

;;;;;
;; Release feature tree
(define-cproc cv-release-feature-tree (tree::<cv-feature-tree>) ::<void>
  (if tree
    (begin
      (cvReleaseFeatureTree tree)
      (set! (-> (SCM_FOREIGN_POINTER tree_scm) ptr) NULL))))

;;;;;
;; Searches feature tree for k nearest neighbors of given reference points,
;; searching (in case of kd-tree/bbf) at most emax leaves.
(define-cproc cv-find-features (tree::<cv-feature-tree> query-points::<cv-mat>
                                                        indices::<cv-mat> dist::<cv-mat>
                                                        :optional (k::<fixnum> 2) (emax::<fixnum> 20)) ::<void>
  (ENSURE_NOT_NULL tree)
  (ENSURE_NOT_NULL query-points)
  (ENSURE_NOT_NULL indices)
  (ENSURE_NOT_NULL dist)
  (cvFindFeatures tree query-points indices dist k emax))

;;;;;
;; Search feature tree for all points that are inlier to given rect region.
;; Only implemented for kd trees
(define-cproc cv-find-features-boxed (tree::<cv-feature-tree> bounds-min::<cv-mat> bounds-max::<cv-mat>
                                                              out-indices::<cv-mat>) ::<fixnum>
  (ENSURE_NOT_NULL tree)
  (ENSURE_NOT_NULL bounds-min)
  (ENSURE_NOT_NULL bounds-max)
  (ENSURE_NOT_NULL out-indices)
  (result (cvFindFeaturesBoxed tree bounds-min bounds-max out-indices)))

;;;;;
;; Construct in-memory LSH table, with n bins.
(define-cproc cv-create-memory-lsh (d::<fixnum> n::<fixnum>
                                                :optional (L::<fixnum> 10) (k::<fixnum> 10)
                                                (type::<fixnum> 6) ;type 6 is CV_64FC1
                                                (r::<real> 4) (seed::<long> -1)) ::<cv-lsh>
  (result (cvCreateMemoryLSH d n L k type r seed)))

;;;;;
;; Free the given LSH structure.
(define-cproc cv-release-lsh (lsh::<cv-lsh>)::<void>
  (if lsh
    (begin
      (cvReleaseLSH (& lsh))
      (set! (-> (SCM_FOREIGN_POINTER lsh_scm) ptr) NULL))))

;;;;;
;; Return the number of vectors in the LSH.
(define-cproc lsh-size (lsh::<cv-lsh>) ::<uint32>
  (ENSURE_NOT_NULL lsh)
  (result (LSHSize lsh)))

;;;;;
;; Add vectors to the LSH structure, optionally returning indices.
;; @param ((indices-obj (c "SCM_UNDEFINED")) >> (indices c:null))
;; {@ c:null <cv-mat>}
(define-cproc cv-lsh-add (lsh::<cv-lsh> data::<cv-mat>
                                        :optional (indices-obj (c "SCM_UNDEFINED"))) ::<void>
  (ENSURE_NOT_NULL lsh)
  (ENSURE_NOT_NULL data)
  (let* ([indices :: CvMat*])
    (undef-or-obj indices-obj indices <cv-mat> 0)
    (cvLSHAdd lsh data indices)))

;;;;;
;; Remove vectors from LSH, as addressed by given indices.
(define-cproc cv-lsh-remove (lsh::<cv-lsh> indices::<cv-mat>) ::<void>
  (ENSURE_NOT_NULL lsh)
  (ENSURE_NOT_NULL indices)
  (cvLSHRemove lsh indices))

;;;;;
;; Query the LSH n times for at most k nearest points; data is n x d,
;; indices and dist are n x k. At most emax stored points will be accessed.
(define-cproc cv-lsh-query (lsh::<cv-lsh> query-points::<cv-mat>
                                          indices::<cv-mat> dist::<cv-mat> k::<fixnum> emax::<fixnum>) ::<void>
  (ENSURE_NOT_NULL lsh)
  (ENSURE_NOT_NULL query-points)
  (ENSURE_NOT_NULL indices)
  (ENSURE_NOT_NULL dist)
  (cvLSHQuery lsh query-points indices dist k emax))


